<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MeshNotes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: #041D31;
        }

        /* Header */
        #header {
            height: 50px;
            background: #0A3559;
            border-bottom: 1px solid #1A5A8A;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 500;
        }

        #header h1 {
            font-size: 18px;
            font-weight: 600;
            color: #eee;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #header h1 span.icon {
            font-size: 22px;
        }

        #header h1 .subtitle {
            font-size: 14px;
            font-weight: 400;
            color: #aaa;
        }

        #btn-about, #btn-legal {
            padding: 8px 16px;
            background: #1A5A8A;
            border: none;
            border-radius: 6px;
            color: #eee;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        #btn-about:hover, #btn-legal:hover {
            background: #2A6A9A;
        }

        .header-buttons {
            display: flex;
            gap: 10px;
        }

        #container {
            display: flex;
            height: calc(100vh - 50px);
            margin-top: 50px;
        }

        #viewport {
            flex: 1;
            position: relative;
        }

        #canvas {
            display: block;
        }

        /* Toolbar */
        #toolbar {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            max-width: calc(100% - 340px);
            z-index: 100;
        }

        .tool-btn {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            background: #0A3559;
            color: #eee;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
            white-space: nowrap;
        }

        .tool-btn:hover {
            background: #1A5A8A;
        }

        .tool-btn.active {
            background: #AA8101;
        }

        .tool-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .tool-separator {
            width: 1px;
            background: #1A5A8A;
            margin: 0 4px;
        }

        #file-input, #import-input, #obj-material-input, #ply-texture-input {
            display: none;
        }

        /* OBJ Material Dialog */
        #obj-dialog-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 300;
            align-items: center;
            justify-content: center;
        }

        #obj-dialog-overlay.visible {
            display: flex;
        }

        #ply-dialog-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 300;
            align-items: center;
            justify-content: center;
        }

        #ply-dialog-overlay.visible {
            display: flex;
        }

        .obj-dialog {
            background: #0A3559;
            border: 1px solid #1A5A8A;
            border-radius: 8px;
            padding: 24px;
            max-width: 420px;
            text-align: center;
        }

        .obj-dialog h3 {
            color: #eee;
            margin-bottom: 8px;
            font-size: 16px;
        }

        .obj-dialog p {
            color: #aaa;
            margin-bottom: 20px;
            line-height: 1.5;
            font-size: 13px;
        }

        .obj-dialog .btn-row {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .obj-dialog button {
            padding: 10px 18px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }

        .obj-dialog .btn-primary {
            background: #EDC040;
            color: #041D31;
            font-weight: 600;
        }

        .obj-dialog .btn-primary:hover {
            background: #f0cc60;
        }

        .obj-dialog .btn-secondary {
            background: #1A5A8A;
            color: #eee;
        }

        .obj-dialog .btn-secondary:hover {
            background: #2A6A9A;
        }

        /* Sidebar */
        #sidebar {
            width: 320px;
            background: #0A3559;
            color: #eee;
            display: flex;
            flex-direction: column;
            border-left: 1px solid #1A5A8A;
        }

        .sidebar-section {
            padding: 16px;
            border-bottom: 1px solid #1A5A8A;
        }

        .sidebar-section h2 {
            font-size: 14px;
            margin-bottom: 12px;
            color: #EDC040;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .sidebar-section h2 button {
            padding: 4px 8px;
            font-size: 11px;
        }

        /* Search Box */
        #search-box {
            padding: 0 16px 12px 16px;
        }

        #search-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #1A5A8A;
            border-radius: 4px;
            background: #041D31;
            color: #eee;
            font-size: 13px;
            box-sizing: border-box;
        }

        #search-input:focus {
            outline: none;
            border-color: #EDC040;
        }

        #search-input::placeholder {
            color: #666;
        }

        .annotation-item.search-hidden {
            display: none !important;
        }

        .group-item.search-hidden {
            display: none !important;
        }

        #annotations-section {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        /* Group List */
        .group-item {
            background: #041D31;
            border-radius: 6px;
            margin-bottom: 8px;
            overflow: hidden;
        }

        .group-header {
            padding: 10px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .group-header:hover {
            background: #1A5A8A;
        }

        .group-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.3);
            cursor: pointer;
        }

        .group-name {
            flex: 1;
            font-weight: 500;
            font-size: 13px;
        }

        .group-visibility {
            padding: 2px 6px;
            background: none;
            border: none;
            color: #eee;
            cursor: pointer;
            font-size: 14px;
            opacity: 0.7;
        }

        .group-visibility:hover {
            opacity: 1;
        }

        .group-visibility.hidden {
            opacity: 0.3;
        }

        .group-actions {
            display: flex;
            gap: 4px;
        }

        .group-actions button {
            padding: 2px 6px;
            background: none;
            border: none;
            color: #aaa;
            cursor: pointer;
            font-size: 12px;
        }

        .group-actions button:hover {
            color: #EDC040;
        }

        /* Model Information Section */
        #model-info-section {
            padding: 0 8px 12px 8px;
            border-bottom: 1px solid #1A5A8A;
            margin-bottom: 12px;
        }

        .model-info-item {
            padding: 12px;
            background: #0A3559;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
            border: 1px solid #1A5A8A;
        }

        .model-info-item:hover {
            background: #1A5A8A;
            border-color: #EDC040;
        }

        .model-info-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }

        .model-info-icon {
            font-size: 16px;
        }

        .model-info-title {
            font-weight: 600;
            font-size: 13px;
            color: #EDC040;
        }

        .model-info-subtitle {
            font-size: 11px;
            color: #888;
            padding-left: 24px;
        }

        /* Annotation List */
        .annotation-list {
            padding: 0 8px 8px 8px;
        }

        .annotation-item {
            padding: 10px;
            background: #0A3559;
            border-radius: 4px;
            margin-bottom: 6px;
            cursor: pointer;
            transition: background 0.2s;
            border-left: 3px solid transparent;
        }

        .annotation-item:hover {
            background: #1A5A8A;
        }

        .annotation-item.selected {
            background: #1A5A8A;
            border-left-color: #EDC040;
        }

        .annotation-item .header {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 4px;
        }

        .annotation-item .type-icon {
            font-size: 12px;
        }

        .annotation-item .name {
            font-weight: 500;
            font-size: 13px;
            flex: 1;
        }

        .annotation-item .description {
            font-size: 11px;
            color: #888;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Popups */
        .popup {
            display: none;
            position: absolute;
            background: #0A3559;
            border: 1px solid #1A5A8A;
            border-radius: 8px;
            padding: 16px;
            z-index: 200;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .popup.visible {
            display: block;
        }

        .popup h3 {
            color: #EDC040;
            margin-bottom: 12px;
            font-size: 14px;
            cursor: move;
            user-select: none;
            padding: 4px 8px;
            margin: -4px -8px 12px -8px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .popup h3:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .popup h3:active {
            background: rgba(255, 255, 255, 0.15);
        }

        .popup label {
            display: block;
            color: #aaa;
            font-size: 12px;
            margin-bottom: 4px;
        }

        .popup input,
        .popup textarea,
        .popup select {
            width: 100%;
            padding: 8px;
            border: 1px solid #1A5A8A;
            border-radius: 4px;
            background: #041D31;
            color: #eee;
            font-size: 13px;
            margin-bottom: 10px;
        }

        .popup textarea {
            height: 70px;
            resize: vertical;
            font-family: inherit;
        }

        .popup .btn-row {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-top: 4px;
        }

        .popup button {
            padding: 8px 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        .popup .btn-save {
            background: #AA8101;
            color: white;
        }

        .popup .btn-cancel {
            background: #1A5A8A;
            color: #eee;
        }

        .popup .btn-delete {
            background: #dc3545;
            color: white;
            margin-right: auto;
        }

        #annotation-popup {
            width: 400px;
            max-height: 80vh;
            overflow-y: auto;
        }

        /* Entries in annotation popup */
        #entries-container {
            margin: 12px 0;
            border-top: 1px solid #1A5A8A;
            padding-top: 12px;
        }

        #entries-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 12px;
        }

        .entry-card {
            background: #041D31;
            border: 1px solid #1A5A8A;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .entry-card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .entry-card-meta {
            color: #888;
        }

        .entry-card-meta .author {
            color: #EDC040;
            font-weight: 500;
        }

        .entry-card-actions {
            display: flex;
            gap: 4px;
        }

        .entry-card-actions button {
            padding: 4px 8px;
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 11px;
            border-radius: 3px;
        }

        .entry-card-actions button:hover {
            background: #1A5A8A;
            color: #EDC040;
        }

        .entry-card-description {
            color: #ccc;
            font-size: 13px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .entry-card-links {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #1A5A8A;
        }

        .entry-card-links a {
            display: inline-block;
            color: #EDC040;
            text-decoration: none;
            font-size: 12px;
            margin-right: 12px;
            margin-bottom: 4px;
        }

        .entry-card-links a:hover {
            text-decoration: underline;
        }

        /* Entry edit mode */
        .entry-card.editing {
            border-color: #EDC040;
        }

        .entry-edit-form {
            display: none;
        }

        .entry-card.editing .entry-card-description,
        .entry-card.editing .entry-card-links,
        .entry-card.editing .entry-card-actions {
            display: none;
        }

        .entry-card.editing .entry-edit-form {
            display: block;
        }

        .entry-edit-form textarea {
            width: 100%;
            height: 60px;
            margin-bottom: 8px;
        }

        .entry-edit-form input {
            width: 100%;
            margin-bottom: 8px;
        }

        .entry-edit-buttons {
            display: flex;
            gap: 6px;
            justify-content: flex-end;
        }

        .entry-edit-buttons button {
            padding: 6px 12px;
            font-size: 12px;
        }

        .btn-add-entry {
            width: 100%;
            padding: 10px;
            background: #1A5A8A;
            border: 1px dashed #EDC040;
            border-radius: 6px;
            color: #EDC040;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }

        .btn-add-entry:hover {
            background: #2A6A9A;
        }

        #new-entry-form {
            border-top: 1px solid #1A5A8A;
            padding-top: 12px;
            margin-top: 12px;
        }

        /* Confirmation dialog */
        .confirm-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 300;
            align-items: center;
            justify-content: center;
        }

        .confirm-overlay.visible {
            display: flex;
        }

        .confirm-dialog {
            background: #0A3559;
            border: 1px solid #1A5A8A;
            border-radius: 8px;
            padding: 20px;
            max-width: 350px;
            text-align: center;
        }

        .confirm-dialog p {
            color: #ccc;
            margin-bottom: 16px;
            line-height: 1.5;
        }

        .confirm-dialog .btn-row {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .confirm-dialog button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        #group-popup {
            width: 260px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Links section in popup */
        .links-section {
            margin-bottom: 10px;
        }

        .links-list {
            max-height: 80px;
            overflow-y: auto;
            margin-bottom: 6px;
        }

        .link-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 6px;
            background: #041D31;
            border-radius: 3px;
            margin-bottom: 4px;
            font-size: 12px;
        }

        .link-item a {
            color: #EDC040;
            text-decoration: none;
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .link-item button {
            padding: 2px 6px;
            background: none;
            border: none;
            color: #AA8101;
            cursor: pointer;
            font-size: 10px;
        }

        .add-link-row {
            display: flex;
            gap: 6px;
        }

        .add-link-row input {
            flex: 1;
            margin-bottom: 0;
            font-size: 12px;
            padding: 6px;
        }

        .add-link-row button {
            padding: 6px 10px;
            font-size: 12px;
        }

        /* Measurement display */
        #measurement-display {
            display: none;
            position: absolute;
            top: 70px;
            left: 10px;
            background: rgba(10, 53, 89, 0.95);
            color: #EDC040;
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 14px;
            z-index: 100;
            min-width: 200px;
            max-height: 300px;
            overflow-y: auto;
        }

        #measurement-display.visible {
            display: block;
        }

        #measurements-list {
            margin-bottom: 8px;
        }

        .measurement-item {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid rgba(237, 192, 64, 0.2);
        }

        .measurement-item:last-child {
            border-bottom: none;
        }

        .measurement-item .label {
            color: #aaa;
        }

        .measurement-item .value {
            font-weight: 600;
            color: #EDC040;
        }

        #measurement-display .hint {
            font-size: 11px;
            color: #888;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        /* Brush Display for Surface Tool */
        #brush-display {
            display: none;
            position: absolute;
            top: 70px;
            left: 10px;
            background: rgba(10, 53, 89, 0.95);
            color: #EDC040;
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 14px;
            z-index: 100;
            min-width: 200px;
        }

        #brush-display.visible {
            display: block;
        }

        .brush-controls label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            color: #aaa;
            font-size: 12px;
        }

        .brush-controls label span:last-child {
            color: #EDC040;
            font-weight: 600;
        }

        #brush-slider {
            width: 100%;
            cursor: pointer;
        }

        #brush-display .hint {
            font-size: 11px;
            color: #888;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        /* Camera toggle button */
        #camera-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 128px;
            text-align: center;
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            background: #0A3559;
            color: #eee;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
            z-index: 100;
        }

        #camera-toggle:hover {
            background: #1A5A8A;
        }

        #camera-toggle.active {
            background: #AA8101;
        }

        /* Instructions */
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(10, 53, 89, 0.9);
            color: #aaa;
            padding: 10px 14px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 100;
        }

        #instructions strong {
            color: #EDC040;
        }

        /* Model Stats */
        #model-stats {
            display: none;
            position: absolute;
            bottom: 10px;
            right: 230px;
            background: rgba(10, 53, 89, 0.8);
            color: #888;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 11px;
            z-index: 100;
        }

        #model-stats.visible {
            display: block;
        }

        #model-stats .warning {
            color: #e8a33c;
        }

        /* ViewHelper (orientation gizmo) */
        #viewhelper-container {
            position: absolute;
            top: 48px;
            right: 10px;
            width: 128px;
            height: 128px;
            z-index: 100;
            cursor: pointer;
        }

        #viewhelper-canvas {
            display: block;
            width: 128px;
            height: 128px;
        }

        /* Status message */
        #status {
            position: absolute;
            bottom: 50px;
            left: 10px;
            color: #EDC040;
            font-size: 13px;
            z-index: 100;
            background: rgba(10, 53, 89, 0.9);
            padding: 8px 12px;
            border-radius: 4px;
            display: none;
        }

        #status.visible {
            display: block;
        }

        /* Loading overlay */
        #loading {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #eee;
            font-size: 18px;
            z-index: 300;
            background: rgba(4, 29, 49, 0.9);
            padding: 20px 30px;
            border-radius: 8px;
        }

        #loading.visible {
            display: block;
        }

        /* Color picker */
        input[type="color"] {
            width: 40px;
            height: 30px;
            padding: 0;
            border: none;
            cursor: pointer;
        }

        /* Empty state */
        .empty-state {
            color: #666;
            font-size: 13px;
            text-align: center;
            padding: 20px;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #041D31;
        }

        ::-webkit-scrollbar-thumb {
            background: #1A5A8A;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #2A6A9A;
        }

        /* Sliders panel */
        #sliders-panel {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(10, 53, 89, 0.95);
            border-radius: 6px;
            z-index: 100;
            min-width: 210px;
        }

        #sliders-panel.collapsed {
            min-width: auto;
            background: transparent;
        }

        #sliders-panel-toggle {
            position: absolute;
            top: 6px;
            right: 6px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #aaa;
            font-size: 12px;
            background: rgba(10, 53, 89, 0.8);
            border-radius: 4px;
            user-select: none;
            z-index: 1;
        }

        #sliders-panel-toggle:hover {
            background: rgba(26, 90, 138, 0.9);
            color: #eee;
        }

        #sliders-panel.collapsed #sliders-panel-toggle {
            position: relative;
            top: auto;
            right: auto;
            background: rgba(10, 53, 89, 0.95);
        }

        #sliders-panel-content {
            padding: 12px 16px;
            padding-top: 32px;
        }

        #sliders-panel.collapsed #sliders-panel-content {
            display: none;
        }

        /* Light mode toggle */
        .light-mode-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .light-mode-row label {
            color: #aaa;
            font-size: 12px;
        }

        .light-toggle-btn {
            padding: 4px 10px;
            background: #041D31;
            border: 1px solid #1A5A8A;
            border-radius: 4px;
            color: #eee;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        .light-toggle-btn:hover {
            border-color: #EDC040;
        }

        .light-toggle-btn.active {
            background: #AA8101;
            border-color: #AA8101;
        }

        #light-direction-row {
            display: none;
        }

        #light-direction-row.visible {
            display: block;
        }

        /* Light direction sliders */
        .light-sliders-group {
            border-top: 1px solid rgba(255,255,255,0.1);
            padding-top: 10px;
            margin-top: 10px;
        }

        .light-sliders-group .slider-row {
            margin-bottom: 8px;
        }

        .light-sliders-group .slider-row:last-child {
            margin-bottom: 0;
        }

        /* About Modal */
        #about-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        #about-overlay.visible {
            display: flex;
        }

        /* Legal Modal */
        #legal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        #legal-overlay.visible {
            display: flex;
        }

        #legal-modal {
            background: #0A3559;
            border-radius: 12px;
            width: 90%;
            max-width: 700px;
            max-height: 85vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        #legal-modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid #1A5A8A;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        #legal-modal-header h2 {
            font-size: 18px;
            color: #eee;
        }

        #legal-modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        #legal-modal-close:hover {
            background: #1A5A8A;
            color: #eee;
        }

        #legal-modal-content {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
        }

        #legal-modal-content section {
            margin-bottom: 24px;
        }

        #legal-modal-content section:last-child {
            margin-bottom: 0;
        }

        #legal-modal-content h3 {
            font-size: 16px;
            color: #EDC040;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #1A5A8A;
        }

        #legal-modal-content p {
            color: #ccc;
            line-height: 1.6;
            margin-bottom: 12px;
        }

        #legal-modal-content a {
            color: #EDC040;
            text-decoration: none;
        }

        #legal-modal-content a:hover {
            text-decoration: underline;
        }

        #legal-modal-content h4 {
            font-size: 14px;
            color: #EDC040;
            margin: 20px 0 8px 0;
            font-weight: 600;
        }

        #legal-modal-content strong {
            color: #eee;
        }

        #about-modal {
            background: #0A3559;
            border-radius: 12px;
            width: 90%;
            max-width: 700px;
            max-height: 85vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        #about-modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid #1A5A8A;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        #about-modal-header h2 {
            font-size: 20px;
            color: #eee;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #about-modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        #about-modal-close:hover {
            background: #1A5A8A;
            color: #eee;
        }

        #about-modal-content {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
        }

        #about-modal-content section {
            margin-bottom: 24px;
        }

        #about-modal-content section:last-child {
            margin-bottom: 0;
        }

        #about-modal-content h3 {
            font-size: 16px;
            color: #EDC040;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #1A5A8A;
        }

        #about-modal-content p {
            color: #ccc;
            line-height: 1.6;
            margin-bottom: 12px;
        }

        #about-modal-content a {
            color: #EDC040;
            text-decoration: none;
        }

        #about-modal-content a:hover {
            text-decoration: underline;
        }

        /* Manual section */
        #about-modal-content h4 {
            font-size: 14px;
            color: #EDC040;
            margin: 20px 0 8px 0;
            font-weight: 600;
        }

        #about-modal-content h4:first-of-type {
            margin-top: 0;
        }

        /* Collapsible manual items */
        .manual-item {
            background: #041D31;
            border-radius: 6px;
            margin-bottom: 8px;
            overflow: hidden;
        }

        .manual-item-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 14px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            color: #EDC040;
            transition: background 0.2s;
        }

        .manual-item-header:hover {
            background: #0A3559;
        }

        .manual-item-header .toggle-icon {
            font-size: 10px;
            color: #888;
            transition: transform 0.2s;
        }

        .manual-item-header.expanded .toggle-icon {
            transform: rotate(90deg);
        }

        .manual-item-content {
            display: none;
            padding: 0 14px 14px 14px;
            color: #ccc;
            font-size: 13px;
            line-height: 1.6;
        }

        .manual-item-content.expanded {
            display: block;
        }

        .manual-item-content p {
            margin: 0;
        }

        .beta-tag {
            background: #e8a33c;
            color: #000;
            font-size: 9px;
            padding: 2px 5px;
            border-radius: 3px;
            margin-left: 8px;
            font-weight: 700;
            text-transform: uppercase;
        }

        .limitation-note {
            background: rgba(232, 163, 60, 0.15);
            border-left: 3px solid #e8a33c;
            padding: 10px 12px;
            margin-top: 10px;
            border-radius: 0 4px 4px 0;
            font-size: 12px;
            color: #ccc;
        }

        .limitation-note strong {
            color: #e8a33c;
        }

        .btn-download-manual {
            width: 100%;
            padding: 12px 16px;
            margin-top: 16px;
            background: #1A5A8A;
            border: 1px solid #EDC040;
            border-radius: 6px;
            color: #EDC040;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .btn-download-manual:hover {
            background: #2A6A9A;
            border-color: #FFD54F;
            color: #FFD54F;
        }

        #about-modal-content code {
            background: #1A5A8A;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 13px;
            color: #EDC040;
        }

        .contact-info {
            background: #041D31;
            padding: 16px;
            border-radius: 6px;
        }

        .contact-info p {
            margin-bottom: 8px;
        }

        .contact-info p:last-child {
            margin-bottom: 0;
        }

        .slider-row {
            margin-bottom: 10px;
        }

        .slider-row:last-child {
            margin-bottom: 0;
        }

        .slider-row.slider-divider {
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .slider-row label {
            display: flex;
            justify-content: space-between;
            color: #aaa;
            font-size: 12px;
            margin-bottom: 4px;
        }

        .slider-row input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: #041D31;
            border-radius: 3px;
            outline: none;
        }

        .slider-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #EDC040;
            border-radius: 50%;
            cursor: pointer;
        }

        .slider-row input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #EDC040;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header id="header">
        <h1>MeshNotes <span class="subtitle">– 3D Annotation Tool for Research & Heritage</span></h1>
        <div class="header-buttons">
            <button id="btn-about">About / Help</button>
            <button id="btn-legal">Legal / Data</button>
        </div>
    </header>

    <!-- About Modal -->
    <div id="about-overlay">
        <div id="about-modal">
            <div id="about-modal-header">
                <h2>MeshNotes</h2>
                <button id="about-modal-close">✕</button>
            </div>
            <div id="about-modal-content">
                <section>
                    <h3>About</h3>
                    <p>
                        <strong>MeshNotes</strong> is a free, browser-based tool for annotating 3D models with points, lines, polygons, and surfaces, 
                        designed for cultural heritage documentation. It allows teams to collaboratively mark and describe features 
                        on 3D models of archaeological sites, architecture, and artifacts (e.g. from photogrammetry, laser scanning, or structured light scanning).
                    </p>
                    <p>
                        Key features include multi-entry annotations (multiple users can add observations to the same feature with individual timestamps), 
                        measurement tools, customizable groups with color coding, draggable points for editing, and <strong>W3C Web Annotation</strong> compliant export/import for interoperability and team collaboration.
                    </p>
                    <p>
                        The tool runs entirely in your browser — no installation or server required. Simply open the HTML file and start annotating. 
                        Your data stays on your computer unless you share the exported file. The export format follows the 
                        <a href="https://www.w3.org/TR/annotation-model/" target="_blank">W3C Web Annotation Data Model</a>, 
                        ensuring compatibility with IIIF-based systems and other annotation tools.
                    </p>
                </section>

                <section>
                    <h3>Contact</h3>
                    <div class="contact-info">
                        <p><strong>Developer:</strong> Nils Schnorr</p>
                        <p><strong>Email:</strong> <a href="mailto:nils.schnorr@uni-saarland.de">nils.schnorr@uni-saarland.de</a></p>
                        <p><strong>Institution:</strong> Department of Classical Archaeology, Saarland University, Saarbrücken, Germany</p>
                    </div>
                </section>

                <section>
                    <h3>Quick Start</h3>
                    <div style="background: #041D31; padding: 16px; border-radius: 6px;">
                        <p style="margin-bottom: 12px;"><strong>1. Load a model</strong> — Click <strong>Load Model</strong> and select a 3D model file (.glb, .gltf, .obj, or .ply format). For OBJ files, you will be prompted to optionally add material (.mtl) and texture files.</p>
                        <p style="margin-bottom: 12px;"><strong>2. Add annotations</strong> — Select a tool (Point, Line, Polygon, or Surface) and click on the model. Double-click to finish lines/polygons/surfaces.</p>
                        <p style="margin-bottom: 12px;"><strong>3. Navigate annotations</strong> — Single-click an annotation in the sidebar to focus the camera on it. Double-click to open it for editing.</p>
                        <p style="margin-bottom: 12px;"><strong>4. Adjust annotations</strong> — When no tool is active, drag any annotation point to reposition it. Use groups to organize and color-code your work.</p>
                        <p style="margin-bottom: 12px;"><strong>5. Take measurements</strong> — Use the Measure tool to click two points and get the distance. Press Escape to clear.</p>
                        <p style="margin-bottom: 0;"><strong>6. Export your work</strong> — Click <strong>JSON</strong> to save annotations for backup or team sharing. Click <strong>PDF</strong> to generate a documentation report with screenshots.</p>
                    </div>
                </section>

                <section>
                    <h3>Manual</h3>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Loading a Model</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Click <strong>Load Model</strong> to open a 3D model file. The tool supports <code>.glb</code>, <code>.gltf</code>, <code>.obj</code>, and <code>.ply</code> formats. PLY files with vertex colors and textures are fully supported. After loading, the face count is displayed in the bottom-right corner.</p>
                            
                            <p style="margin-top: 10px;"><strong>PLY Files:</strong> When loading a PLY file, you will be asked whether to add a texture image. If your PLY contains UV coordinates, the texture will be mapped onto the model. PLY files with vertex colors are loaded automatically without requiring a separate texture.</p>
                            
                            <p style="margin-top: 10px;"><strong>OBJ Files:</strong> When loading an OBJ file, you will be asked whether to add material and texture files. You can select a <code>.mtl</code> file together with texture images (<code>.jpg</code>, <code>.png</code>), or only texture images, or load the geometry without any materials. If only a texture is provided without an MTL file, it will be applied as a diffuse map (works best for single-texture models).</p>
                            
                            <p style="margin-top: 10px;"><strong>Model Orientation:</strong> Ensure your model is oriented correctly (typically Y-up or Z-up) before exporting. The viewer's navigation is based on the model's original orientation and cannot be changed after loading. If your model appears upside down or sideways, re-export it with the correct orientation in your 3D software.</p>
                            <p style="margin-top: 10px;"><strong>Tip:</strong> GLB is recommended for best compatibility as it embeds textures in a single file. If your model is in another format, you can convert it using <a href="https://www.blender.org/" target="_blank">Blender</a>.</p>
                            <div class="limitation-note" style="margin-top: 12px;">
                                <strong>Exporting Vertex Colors from Blender:</strong> To include vertex colors in your GLB export, go to <code>File → Export → glTF 2.0</code>. In the export panel, expand <strong>Mesh</strong>, then <strong>Vertex Colors</strong>, and set <strong>Use Vertex Color</strong> to <strong>Active</strong>. This ensures that vertex color data is included in the GLB file and will be available in the Colors display mode.
                            </div>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Texture &amp; Display Controls</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p><strong>Display Mode:</strong> Click the display button to cycle through three modes: <strong>Texture</strong> (shows the model's texture maps), <strong>Colors</strong> (shows vertex colors only, if present), and <strong>Gray</strong> (plain geometry without any color). The Colors mode is only available if the model contains vertex color data.</p>
                            <p style="margin-top: 10px;"><strong>Brightness slider:</strong> Adjust scene lighting from 0% to 300%. <strong>Opacity slider:</strong> Make the model transparent (10-100%) to see annotations that pass through it.</p>
                            <p style="margin-top: 10px;"><strong>Annotation Display:</strong> Use the <strong>Point Size</strong> slider (25-500%) to adjust the size of annotation markers, and the <strong>Text Size</strong> slider (25-300%) to adjust annotation label sizes. These settings are saved automatically.</p>
                            <p style="margin-top: 10px;"><strong>Light Source:</strong> By default, the main light follows your camera view, ensuring consistent illumination from any angle. Click the toggle to switch to <strong>Fixed Direction</strong> mode, which reveals two sliders: <strong>Horizontal</strong> (0°-360°) rotates the light around the model, and <strong>Vertical</strong> (-90° to +90°) adjusts the light height from below (-90°) through the horizon (0°) to directly above (+90°). This is ideal for raking light analysis of surface details like tool marks, inscriptions, or weathering patterns. The light is automatically boosted in fixed mode for better shadow visibility.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Point Annotations</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Click <strong>Point</strong>, then click on the model surface to place a point marker. A popup will appear where you can enter a name, description, author, and external links. Points are useful for marking specific features or locations.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Line Annotations</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Click <strong>Line</strong> to start drawing a polyline. Single-click to add points along the line, double-click to finish and open the annotation popup. Lines are useful for marking edges, boundaries, cracks, or linear features.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Polygon Annotations</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Click <strong>Polygon</strong> to start drawing a closed shape. Single-click to add vertices, double-click to close the polygon and open the annotation popup. Polygons are useful for marking areas, surfaces, or regions of interest.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Surface Annotations <span class="beta-tag">Beta</span></span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Click <strong>Surface</strong> to paint directly on the 3D model's mesh faces. Adjust the brush size using the slider (0.1-20% of model size), then click and drag to highlight faces. <strong>Right-click and drag</strong> to rotate the view while painting — this lets you paint a continuous surface annotation from multiple angles (e.g., wrapping around a statue's arm). Hold <strong>Shift</strong> while painting to erase. Double-click to finish and open the annotation popup.</p>
                            <p style="margin-top: 10px;">Surface annotations are ideal for marking 3D regions like weathered areas, specific architectural features, or body parts on sculptures that can't be easily captured with flat polygons.</p>
                            <div class="limitation-note">
                                <strong>Performance Note:</strong> The Surface tool works best on smaller models (statues, ceramics, artifacts). Performance depends on face count:
                                <ul style="margin: 8px 0 0 20px; padding: 0;">
                                    <li><strong>&lt; 500k faces:</strong> Smooth painting</li>
                                    <li><strong>500k - 1M faces:</strong> May experience slight lag</li>
                                    <li><strong>&gt; 1M faces:</strong> Painting may be slow (consider decimating the model)</li>
                                </ul>
                                The face count is shown in the bottom-right corner after loading a model.
                            </div>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Measurement Tool</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Click <strong>Measure</strong> to activate the measurement tool. Click two points on the model to measure the distance between them. Multiple measurements can be taken and all stay visible with their distance labels. Take a screenshot to document your measurements, then press <code>Esc</code> to clear all. Distances are displayed in "units" — the actual unit (meters, millimeters, etc.) depends on how your 3D model was created or exported.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Groups</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Groups help organize annotations by category, phase, or team member. Click <strong>+ Group</strong> in the sidebar to create a new group with a custom name and color. All annotations within a group share that color. Use the eye icon to show/hide all annotations in a group, and the edit icon to modify the group name/color or delete the entire group. A default group is created automatically when you first annotate.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Model Information</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>At the top of the sidebar is a <strong>Model Information</strong> section for general notes about the entire model. Double-click it to add an introduction, context, or overview that applies to the whole model rather than a specific location. Like annotations, it supports multiple entries from different team members with timestamps — useful for documenting the model's origin, processing history, or general observations.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Multi-Entry Annotations</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Each annotation can have multiple entries from different users. When editing an annotation, you'll see all existing entries with their author and timestamp. Click <strong>+ Add Entry</strong> to add your own observation without overwriting previous ones. Each entry has its own description, author name, and links. This is ideal for collaborative documentation where multiple team members contribute observations to the same feature.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Editing Annotations</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Single-click an annotation in the sidebar to focus the camera on it. Double-click to open it for editing. In the edit popup you can: change the annotation name and group, view all entries, edit existing entries (with confirmation to encourage adding new entries), delete individual entries, or delete the entire annotation. Your author name is remembered for convenience.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Moving Annotation Points</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>When no tool is active, you can click and drag any annotation point to reposition it. The cursor changes to a hand when hovering over draggable points. While dragging, the point follows the model surface and lines/polygons update in real-time. This allows you to adjust annotations without recreating them. Note: Surface annotations cannot be edited after creation.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Export &amp; Import</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p><strong>JSON Export:</strong> Click to download all annotations in <strong>W3C Web Annotation</strong> format (.jsonld). This standard format ensures interoperability with other annotation tools and IIIF-compatible viewers. The export includes all entries, timestamps, metadata, groups, and model information.</p>
                            <p style="margin-top: 10px;"><strong>Import:</strong> Click to load annotations from a .json or .jsonld file. MeshNotes supports both the new W3C format and legacy MeshNotes files for backward compatibility. Imported annotations merge with existing ones — groups with the same name are combined.</p>
                            <p style="margin-top: 10px; font-size: 12px; color: #888;">The W3C Web Annotation Data Model is a standard for interoperable annotations. Learn more at <a href="https://www.w3.org/TR/annotation-model/" target="_blank">w3.org/TR/annotation-model</a></p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>PDF Report</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Click <strong>PDF</strong> to generate a professional PDF report of your annotations. The report includes: a title page with model overview and model information, a table of contents, and one page per annotation with an auto-captured screenshot and all entry details. Only visible annotations are included — hide groups you don't want in the report. The PDF is formatted for A4 paper and suitable for academic documentation and publication.</p>
                            <p style="margin-top: 10px;"><strong>Note:</strong> PDF screenshots always use camera-linked lighting for consistent illumination across all views, regardless of your current light source setting.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Screenshots</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Click <strong>Screenshot</strong> to save the current view as a PNG image. The screenshot includes all visible annotations, name labels, and measurement lines exactly as shown on screen — useful for documentation, reports, and publications.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Navigation Controls</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p><strong>Left-click + drag:</strong> Rotate the view around the model. <strong>Right-click + drag:</strong> Pan the view. <strong>Scroll wheel:</strong> Zoom in/out. <strong>Escape:</strong> Cancel current drawing action, deselect tool, or clear all measurements.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Camera View</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Click the <strong>Perspective/Orthographic</strong> button in the top-right corner of the viewport to toggle between camera modes. <strong>Perspective</strong> view shows depth with natural foreshortening. <strong>Orthographic</strong> view removes perspective distortion, making parallel lines appear parallel — useful for accurate measurements, technical drawings, and architectural documentation.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Tips</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Use the opacity slider to see annotations on the back side of the model. Group annotations by excavation phase, feature type, or team member for better organization. Export frequently to back up your work. The tool runs entirely in your browser — your data stays on your computer unless you share the exported JSON file.</p>
                        </div>
                    </div>

                    <button class="btn-download-manual" id="btn-download-manual">📄 Download Manual as PDF</button>

                </section>

                <section>
                    <h3>Credits & License</h3>
                    <p>MeshNotes uses the following open-source libraries:</p>
                    <ul style="margin: 12px 0 12px 20px; color: #ccc;">
                        <li><a href="https://threejs.org/" target="_blank">Three.js</a> (MIT License) — 3D rendering</li>
                        <li><a href="https://github.com/gkjohnson/three-mesh-bvh" target="_blank">three-mesh-bvh</a> (MIT License) — Accelerated raycasting &amp; surface projection</li>
                        <li><a href="https://github.com/parallax/jsPDF" target="_blank">jsPDF</a> (MIT License) — PDF generation</li>
                    </ul>
                    <p>MeshNotes itself is licensed under the <strong>MIT License</strong> — free to use, modify, and distribute. See the <a href="https://github.com/NilsSchnorr/MeshNotes/blob/main/LICENSE" target="_blank">LICENSE file</a> for details.</p>
                </section>
            </div>
        </div>
    </div>

    <!-- Legal Modal -->
    <div id="legal-overlay">
        <div id="legal-modal">
            <div id="legal-modal-header">
                <h2>Legal Information and Data Policy / Impressum und Datenschutz</h2>
                <button id="legal-modal-close">✕</button>
            </div>
            <div id="legal-modal-content">
                <section>
                    <div style="background: #041D31; padding: 16px; border-radius: 6px; margin-bottom: 24px;">
                        <p style="margin-bottom: 8px;"><strong>🔗 Open Source Repository</strong></p>
                        <p style="margin-bottom: 0;">Want to use the tool without accessing this website? Feel free to download or clone the repository at <a href="https://github.com/NilsSchnorr/MeshNotes" target="_blank">github.com/NilsSchnorr/MeshNotes</a></p>
                    </div>
                </section>

                <!-- ENGLISH VERSION -->
                <section>
                    <h3>Legal Notice (English)</h3>
                    <p>
                        <strong>Nils Schnorr</strong><br>
                        <a href="mailto:nils.schnorr@uni-saarland.de">nils.schnorr@uni-saarland.de</a><br>
                        Universität des Saarlandes<br>
                        Fakultät P - Altertumswissenschaften<br>
                        Klassische Archäologie<br>
                        Campus Gebäude B3.1 Raum 1.22<br>
                        66123 Saarbrücken, Germany
                    </p>
                    
                    <h4>Disclaimer</h4>
                    
                    <p><strong>Liability for Content</strong><br>
                    As a service provider, we are responsible for our own content on these pages in accordance with general legislation pursuant to Section 7 (1) of the German Telemedia Act (TMG). However, according to Sections 8 to 10 TMG, we are not obligated to monitor transmitted or stored third-party information or to investigate circumstances that indicate illegal activity. Obligations to remove or block the use of information under general law remain unaffected. However, liability in this regard is only possible from the time of knowledge of a specific infringement. Upon becoming aware of such violations, we will remove this content immediately.</p>
                    
                    <p><strong>Liability for Links</strong><br>
                    Our website contains links to external third-party websites over whose content we have no control. Therefore, we cannot accept any liability for this third-party content. The respective provider or operator of the linked pages is always responsible for the content of those pages. The linked pages were checked for possible legal violations at the time of linking. Illegal content was not recognizable at the time of linking. Permanent content control of the linked pages is not reasonable without concrete evidence of a violation of the law. Upon becoming aware of legal violations, we will remove such links immediately.</p>
                    
                    <p><strong>Copyright</strong><br>
                    The content and works created by the site operators on these pages are subject to German copyright law. Duplication, processing, distribution, and any kind of exploitation outside the limits of copyright law require the written consent of the respective author or creator. Insofar as the content on this site was not created by the operator, the copyrights of third parties are respected. In particular, third-party content is marked as such. Should you nevertheless become aware of a copyright infringement, please inform us accordingly. Upon becoming aware of legal violations, we will remove such content immediately.</p>
                </section>

                <section>
                    <h3>Data Policy (English)</h3>
                    
                    <p>The GDPR requires transparency about how and why your personal data is processed.</p>
                    
                    <h4>Hosting</h4>
                    <p>The host operates a web server to deliver static pages.</p>
                    
                    <p><strong>Hosting via GitHub Pages</strong><br>
                    This tool is open source and hosted on "GitHub Pages". GitHub declares its handling of data in their <a href="https://docs.github.com/en/site-policy/privacy-policies/github-general-privacy-statement" target="_blank">Privacy Policy</a>.</p>
                    
                    <p style="font-style: italic; padding-left: 16px; border-left: 3px solid #1A5A8A;">"... we only collect the minimum amount of personal information that is necessary to fulfill the purpose of your interaction with us ..."</p>
                    
                    <p>As a US company, GitHub complies with the Privacy Shield requirements for users from the EU.</p>
                    
                    <p><strong>Hosting as a Static Website</strong><br>
                    This is a static website, meaning this "tool" is pre-built on the host's web server and delivered unchanged when you open the tool in your browser. During such an HTTP request, your browser transmits your IP address and the path of the requested page. This is necessary for the server to load and deliver the requested page to your browser.</p>
                    
                    <p><strong>Server Logs</strong><br>
                    During the HTTP request, in addition to your IP address and the requested page, the referrer (the page where you clicked the link), information about your browser, and your operating system are transmitted to the web server. The host stores this information in server logs to monitor operations so that disruptions and misuse can be quickly detected and resolved.</p>
                    
                    <h4>Business-Related Processing</h4>
                    <p>This tool is open-source and non-commercial. No data from you is processed in this regard by the author of "MeshNotes".</p>
                    
                    <h4>Open Source Contributions</h4>
                    <p>"MeshNotes" is an open-source project hosted at <a href="https://github.com/NilsSchnorr/MeshNotes" target="_blank">github.com/NilsSchnorr/MeshNotes</a>. You can contribute if you wish, for example by submitting a pull request on GitHub. Please note: This project is published under an MIT license, which will also apply to your contributions if the pull requests are accepted.</p>
                </section>

                <hr style="border: none; border-top: 2px solid #1A5A8A; margin: 32px 0;">

                <!-- GERMAN VERSION -->
                <section>
                    <h3>Legal / Impressum (Deutsch)</h3>
                    <p>
                        <strong>Nils Schnorr</strong><br>
                        <a href="mailto:nils.schnorr@uni-saarland.de">nils.schnorr@uni-saarland.de</a><br>
                        Universität des Saarlandes<br>
                        Fakultät P - Altertumswissenschaften<br>
                        Klassische Archäologie<br>
                        Campus Gebäude B3.1 Raum 1.22<br>
                        66123 Saarbrücken, Germany
                    </p>
                    
                    <h4>Haftungsausschluss (Disclaimer)</h4>
                    
                    <p><strong>Haftung für Inhalte</strong><br>
                    Als Diensteanbieter sind wir gemäß § 7 Abs.1 TMG für eigene Inhalte auf diesen Seiten nach den allgemeinen Gesetzen verantwortlich. Nach §§ 8 bis 10 TMG sind wir als Diensteanbieter jedoch nicht verpflichtet, übermittelte oder gespeicherte fremde Informationen zu überwachen oder nach Umständen zu forschen, die auf eine rechtswidrige Tätigkeit hinweisen. Verpflichtungen zur Entfernung oder Sperrung der Nutzung von Informationen nach den allgemeinen Gesetzen bleiben hiervon unberührt. Eine diesbezügliche Haftung ist jedoch erst ab dem Zeitpunkt der Kenntnis einer konkreten Rechtsverletzung möglich. Bei Bekanntwerden von entsprechenden Rechtsverletzungen werden wir diese Inhalte umgehend entfernen.</p>
                    
                    <p><strong>Haftung für Links</strong><br>
                    Unser Angebot enthält Links zu externen Webseiten Dritter, auf deren Inhalte wir keinen Einfluss haben. Deshalb können wir für diese fremden Inhalte auch keine Gewähr übernehmen. Für die Inhalte der verlinkten Seiten ist stets der jeweilige Anbieter oder Betreiber der Seiten verantwortlich. Die verlinkten Seiten wurden zum Zeitpunkt der Verlinkung auf mögliche Rechtsverstöße überprüft. Rechtswidrige Inhalte waren zum Zeitpunkt der Verlinkung nicht erkennbar. Eine permanente inhaltliche Kontrolle der verlinkten Seiten ist jedoch ohne konkrete Anhaltspunkte einer Rechtsverletzung nicht zumutbar. Bei Bekanntwerden von Rechtsverletzungen werden wir derartige Links umgehend entfernen.</p>
                    
                    <p><strong>Urheberrecht</strong><br>
                    Die durch die Seitenbetreiber erstellten Inhalte und Werke auf diesen Seiten unterliegen dem deutschen Urheberrecht. Die Vervielfältigung, Bearbeitung, Verbreitung und jede Art der Verwertung außerhalb der Grenzen des Urheberrechtes bedürfen der schriftlichen Zustimmung des jeweiligen Autors bzw. Erstellers. Soweit die Inhalte auf dieser Seite nicht vom Betreiber erstellt wurden, werden die Urheberrechte Dritter beachtet. Insbesondere werden Inhalte Dritter als solche gekennzeichnet. Sollten Sie trotzdem auf eine Urheberrechtsverletzung aufmerksam werden, bitten wir um einen entsprechenden Hinweis. Bei Bekanntwerden von Rechtsverletzungen werden wir derartige Inhalte umgehend entfernen.</p>
                    
                    <p style="color: #888; font-size: 12px;">Quelle: eRecht24</p>
                </section>

                <section>
                    <h3>Datenschutz (Deutsch)</h3>
                    
                    <p>Die DSGVO sieht vor, dass Sie Transparenz darüber erhalten, wie und wozu Ihre personenbezogenen Daten verarbeitet werden.</p>
                    
                    <h4>Hosting</h4>
                    <p>Der Hoster betreibt einen Web-Server zur Auslieferung der statischer Seiten.</p>
                    
                    <p><strong>Hosting durch GitHub Pages</strong><br>
                    Dieses Tool ist Open Source und wird bei "GitHub Pages" gehosted. GitHub deklariert seinen Umgang mit Daten in dieser <a href="https://docs.github.com/en/site-policy/privacy-policies/github-general-privacy-statement" target="_blank">Privacy Policy</a>.</p>
                    
                    <p style="font-style: italic; padding-left: 16px; border-left: 3px solid #1A5A8A;">"... we only collect the minimum amount of personal information that is necessary to fulfill the purpose of your interaction with us ..."</p>
                    
                    <p>GitHub erfüllt als US-Unternehmen die Anforderungen des Privacy Shield für Nutzer aus der EU.</p>
                    
                    <p><strong>Hosting als statische Website</strong><br>
                    Dies ist eine statische Website, d.h. dieses „Tool" liegt vorgefertigt auf dem Web-Server des Hosters und wird unverändert ausgeliefert, sobald Sie das Tool im Browser öffnen. Bei einem solchen http-Request überträgt Ihr Browser Ihre IP-Adresse und den Pfad der angeforderten Seite. Dies ist notwendig, damit der Browser die angeforderte Seite laden und an Ihren Browser ausliefern kann.</p>
                    
                    <p><strong>Server-Logs</strong><br>
                    Beim http-Request werden neben Ihrer IP-Adresse und der angeforderten Seite auch der Referrer (die Seite auf der Sie den Link geklickt haben), Informationen über Ihren Browser und Ihr Betriebssystem an den Web-Server übermittelt. Der Hoster speichert diese Informationen in Server-Logs, um den Betrieb zu überwachen, damit Störungen und Missbrauchsfälle schnell erkannt und behoben werden können.</p>
                    
                    <h4>Geschäftsbezogene Verarbeitung</h4>
                    <p>Dieses Tool ist Open-Source und nicht kommerziell. Es werden keine Daten von Ihnen in diesem Hinblick vom Autor von „MeshNotes" verarbeitet.</p>
                    
                    <h4>Open-Source-Beiträge</h4>
                    <p>„MeshNotes" ist ein Open-Source-Projekt, gehostet auf <a href="https://github.com/NilsSchnorr/MeshNotes" target="_blank">github.com/NilsSchnorr/MeshNotes</a>. Sie können dazu beitragen, wenn Sie möchten, z. B. durch einen Pull-Request auf GitHub. Beachten Sie dabei: Dieses Projekt ist unter einer MIT Lizenz veröffentlicht, diese gilt dann auch für Ihre Beiträge, wenn die Pull-Requests angenommen werden.</p>
                </section>
            </div>
        </div>
    </div>

    <div id="container">
        <div id="viewport">
            <canvas id="canvas"></canvas>
            
            <button id="camera-toggle" title="Toggle Orthographic/Perspective View">Perspective</button>
            
            <div id="toolbar">
                <input type="file" id="file-input" accept=".glb,.gltf,.obj,.ply">
                <input type="file" id="import-input" accept=".json,.jsonld">
                <input type="file" id="obj-material-input" accept=".mtl,.jpg,.jpeg,.png,.tif,.tiff" multiple>
                <input type="file" id="ply-texture-input" accept=".jpg,.jpeg,.png,.tif,.tiff">
                
                <button class="tool-btn" id="btn-load" title="Load 3D Model (GLB, GLTF, OBJ, PLY)">📂 Load Model</button>
                <button class="tool-btn" id="btn-texture" disabled title="Toggle Texture">🖼️ Texture</button>
                
                <div class="tool-separator"></div>
                
                <button class="tool-btn" id="btn-point" disabled title="Add Point Annotation">📍 Point</button>
                <button class="tool-btn" id="btn-line" disabled title="Add Line Annotation">📏 Line</button>
                <button class="tool-btn" id="btn-polygon" disabled title="Add Polygon Annotation">⬡ Polygon</button>
                <button class="tool-btn" id="btn-surface" disabled title="Add Surface Annotation (Beta)">🎨 Surface</button>
                <button class="tool-btn" id="btn-measure" disabled title="Measure Distance">📐 Measure</button>
                
                <div class="tool-separator"></div>
                
                <button class="tool-btn" id="btn-screenshot" disabled title="Take Screenshot">📷 Screenshot</button>
                <button class="tool-btn" id="btn-export" disabled title="Export Annotations as JSON">💾 JSON</button>
                <button class="tool-btn" id="btn-export-pdf" disabled title="Export as PDF Report">📄 PDF</button>
                <button class="tool-btn" id="btn-import" title="Import Annotations">📥 Import</button>
            </div>

            <div id="measurement-display">
                <div id="measurements-list"></div>
                <div class="hint">Click two points to measure. Press Esc to clear all.</div>
            </div>

            <div id="brush-display">
                <div class="brush-controls">
                    <label>
                        <span>Brush Size</span>
                        <span id="brush-value">5%</span>
                    </label>
                    <input type="range" id="brush-slider" min="0.1" max="20" value="5" step="0.1">
                </div>
                <div class="hint">Click/drag to paint. Hold Shift to erase. Double-click to finish.</div>
            </div>

            <div id="instructions">
                <strong>Controls:</strong> Left-drag rotate · Right-drag pan · Scroll zoom
            </div>

            <div id="model-stats">
                <span id="face-count"></span>
            </div>

            <div id="viewhelper-container">
                <canvas id="viewhelper-canvas" width="128" height="128"></canvas>
            </div>

            <div id="sliders-panel">
                <div id="sliders-panel-toggle">▼</div>
                <div id="sliders-panel-content">
                    <div class="light-mode-row">
                    <label>Light Source</label>
                    <button class="light-toggle-btn active" id="light-toggle" title="Toggle between camera-linked and fixed light">Follows Camera</button>
                </div>
                <div id="light-direction-row">
                    <div class="light-sliders-group">
                        <div class="slider-row">
                            <label>
                                <span>Horizontal</span>
                                <span id="light-azimuth-value">0°</span>
                            </label>
                            <input type="range" id="light-azimuth-slider" min="0" max="360" value="0">
                        </div>
                        <div class="slider-row">
                            <label>
                                <span>Vertical</span>
                                <span id="light-elevation-value">45°</span>
                            </label>
                            <input type="range" id="light-elevation-slider" min="-90" max="90" value="45">
                        </div>
                    </div>
                </div>
                <div class="slider-row">
                    <label>
                        <span>Brightness</span>
                        <span id="brightness-value">100%</span>
                    </label>
                    <input type="range" id="brightness-slider" min="0" max="300" value="100">
                </div>
                <div class="slider-row slider-divider">
                    <label>
                        <span>Model Opacity</span>
                        <span id="opacity-value">100%</span>
                    </label>
                    <input type="range" id="opacity-slider" min="10" max="100" value="100">
                </div>
                <div class="slider-row">
                    <label>
                        <span>Point Size</span>
                        <span id="point-size-value">100%</span>
                    </label>
                    <input type="range" id="point-size-slider" min="25" max="500" value="100">
                </div>
                <div class="slider-row">
                    <label>
                        <span>Text Size</span>
                        <span id="text-size-value">100%</span>
                    </label>
                    <input type="range" id="text-size-slider" min="25" max="300" value="100">
                </div>
                </div>
            </div>

            <div id="status"></div>
            <div id="loading">Loading model...</div>

            <!-- Annotation Popup -->
            <div class="popup" id="annotation-popup">
                <h3 id="popup-title">New Annotation</h3>
                
                <div id="popup-main-fields">
                    <label for="ann-name">Name *</label>
                    <input type="text" id="ann-name" placeholder="e.g., Door remains">
                    
                    <label for="ann-group">Group</label>
                    <select id="ann-group"></select>
                </div>
                
                <!-- Entries container (shown when editing) -->
                <div id="entries-container" style="display: none;">
                    <div id="entries-list"></div>
                    <button class="btn-add-entry" id="btn-add-entry">+ Add Entry</button>
                </div>
                
                <!-- New entry form (shown when creating or adding entry) -->
                <div id="new-entry-form">
                    <label for="ann-description">Description</label>
                    <textarea id="ann-description" placeholder="Describe what you observe..."></textarea>
                    
                    <label for="ann-author">Author</label>
                    <input type="text" id="ann-author" placeholder="Your name">
                    
                    <div class="links-section">
                        <label>External Links</label>
                        <div class="links-list" id="ann-links"></div>
                        <div class="add-link-row">
                            <input type="text" id="ann-new-link" placeholder="https://...">
                            <button class="btn-save" id="btn-add-link">+</button>
                        </div>
                    </div>
                </div>
                
                <div class="btn-row">
                    <button class="btn-delete" id="btn-popup-delete" style="display: none;">Delete Annotation</button>
                    <button class="btn-cancel" id="btn-popup-cancel">Cancel</button>
                    <button class="btn-save" id="btn-popup-save">Save</button>
                </div>
            </div>

            <!-- Confirmation Dialog -->
            <div class="confirm-overlay" id="confirm-overlay">
                <div class="confirm-dialog">
                    <p id="confirm-message">Are you sure?</p>
                    <div class="btn-row">
                        <button class="btn-cancel" id="confirm-cancel">Cancel</button>
                        <button class="btn-save" id="confirm-ok">Confirm</button>
                    </div>
                </div>
            </div>

            <!-- Scalebar Confirmation Dialog -->
            <div class="confirm-overlay" id="scalebar-confirm-overlay">
                <div class="confirm-dialog" style="max-width: 450px;">
                    <p id="scalebar-confirm-message">You are currently in <strong>Perspective</strong> view. A scalebar can only be included in <strong>Orthographic</strong> view where scale is uniform across the image.</p>
                    <p style="margin-top: 12px; font-size: 12px; color: #888;">Would you like to switch to Orthographic view to include a scalebar?</p>
                    <div class="btn-row" style="margin-top: 16px;">
                        <button class="btn-cancel" id="scalebar-no-switch">Continue without scalebar</button>
                        <button class="btn-save" id="scalebar-switch">Switch & include scalebar</button>
                    </div>
                </div>
            </div>

            <!-- OBJ Material Dialog -->
            <div id="obj-dialog-overlay">
                <div class="obj-dialog">
                    <h3>OBJ File Detected</h3>
                    <p>Would you like to add material (.mtl) and/or texture files (.jpg, .png)?<br>You can select one or multiple files.</p>
                    <div class="btn-row">
                        <button class="btn-secondary" id="obj-load-plain">Load without materials</button>
                        <button class="btn-primary" id="obj-add-materials">Add Textures & Materials</button>
                    </div>
                </div>
            </div>

            <div id="ply-dialog-overlay">
                <div class="obj-dialog">
                    <h3>PLY File Detected</h3>
                    <p>Would you like to add a texture image (.jpg, .png)?<br>This requires your PLY to contain UV coordinates.</p>
                    <div class="btn-row">
                        <button class="btn-secondary" id="ply-load-plain">Load without texture</button>
                        <button class="btn-primary" id="ply-add-texture">Add Texture</button>
                    </div>
                </div>
            </div>

            <!-- Group Popup -->
            <div class="popup" id="group-popup">
                <h3 id="group-popup-title">New Group</h3>
                <label for="group-name">Name</label>
                <input type="text" id="group-name" placeholder="e.g., Phase 1 features">
                
                <label for="group-color">Color</label>
                <input type="color" id="group-color" value="#EDC040">
                
                <div class="btn-row">
                    <button class="btn-delete" id="btn-group-delete" style="display: none;">Delete</button>
                    <button class="btn-cancel" id="btn-group-cancel">Cancel</button>
                    <button class="btn-save" id="btn-group-save">Save</button>
                </div>
            </div>
        </div>

        <div id="sidebar">
            <div class="sidebar-section" style="flex: 1; overflow-y: auto;">
                <h2>
                    Annotations
                    <button class="tool-btn" id="btn-add-group">+ Group</button>
                </h2>
                
                <!-- Search Box -->
                <div id="search-box">
                    <input type="text" id="search-input" placeholder="Search annotations...">
                </div>
                
                <!-- Model Information -->
                <div id="model-info-section">
                    <div class="model-info-item" id="model-info-item">
                        <div class="model-info-header">
                            <span class="model-info-icon">📋</span>
                            <span class="model-info-title">Model Information</span>
                        </div>
                        <div class="model-info-subtitle" id="model-info-subtitle">No entries yet</div>
                    </div>
                </div>
                
                <div id="groups-container">
                    <div class="empty-state" id="no-groups">No annotations yet. Load a model and use the tools to annotate.</div>
                </div>
            </div>
        </div>
    </div>

    <!-- jsPDF library for PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "three-mesh-bvh": "https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.8.0/+esm"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';
        import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';
        import { Line2 } from 'three/addons/lines/Line2.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
        import { ViewHelper } from 'three/addons/helpers/ViewHelper.js';
        import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh';

        // Register BVH extensions for accelerated raycasting and spatial queries
        THREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;
        THREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;
        THREE.Mesh.prototype.raycast = acceleratedRaycast;

        // ============ State ============
        let scene, camera, renderer, controls;
        let perspectiveCamera, orthographicCamera;
        let viewHelper, viewHelperRenderer;
        const clock = new THREE.Clock();
        let isOrthographic = false;
        let ambientLight, dirLight1, dirLight2;
        let currentModel = null;
        let modelFileName = '';
        let originalMaterials = new Map();
        let displayMode = 'texture'; // 'texture', 'vertexColors', 'gray'
        let hasVertexColors = false; // Detected on model load
        let modelOpacity = 1.0;
        let pointSizeMultiplier = 1.0;
        let textSizeMultiplier = 1.0;
        
        // Light controls
        let lightFollowsCamera = true;
        let fixedLightAzimuth = 0; // degrees (horizontal angle, 0 = front)
        let fixedLightElevation = 45; // degrees (vertical angle, 0 = horizon, 90 = top, -90 = bottom)
        
        // Tools
        let currentTool = null; // 'point', 'line', 'polygon', 'measure'
        let tempPoints = [];
        let tempProjectedEdges = []; // Cached projected edges during drawing
        let tempLine = null;
        let surfaceProjectionEnabled = true; // Project lines/polygons onto mesh surface
        let projectionDeviationRelative = 0.20; // Max deviation as fraction of edge length
        let projectionDeviationAbsolute = 0.03; // Max deviation as fraction of model bounding size
        let measurePoints = [];
        let measureMarkers = [];
        let measureLine = null;
        let measurements = []; // Array of {id, distance, markers, line}

        // Data
        let groups = [];
        let annotations = [];
        let selectedAnnotation = null;
        let editingAnnotation = null;
        
        // Model Information (general info about the whole model)
        let modelInfo = {
            entries: []
        };
        let editingModelInfo = false;

        // Point dragging
        let isDraggingPoint = false;
        let draggedAnnotation = null;
        let draggedPointIndex = -1;
        let draggedMarker = null;
        let wasDragging = false; // Prevent click event after drag
        
        // Point tool - capture position on mousedown to prevent slipping
        let pendingPointPosition = null;

        // Surface painting
        let isPaintingSurface = false;
        let surfaceBrushSize = 5; // Percentage of model size
        let paintedFaces = new Set(); // Set of face indices
        let surfaceHighlightMesh = null; // Mesh showing painted areas
        let surfaceHighlightDirty = false; // Flag for throttled highlight updates
        let surfaceHighlightRAF = null; // requestAnimationFrame ID for throttle
        let isErasingMode = false;
        let modelMeshes = []; // Cache of meshes in the model
        let modelBoundingSize = 1; // For brush size calculation

        // Three.js objects for annotations
        let annotationObjects = new THREE.Group();

        // ============ DOM Elements ============
        const canvas = document.getElementById('canvas');
        const fileInput = document.getElementById('file-input');
        const importInput = document.getElementById('import-input');
        const objMaterialInput = document.getElementById('obj-material-input');
        const objDialogOverlay = document.getElementById('obj-dialog-overlay');
        const objLoadPlain = document.getElementById('obj-load-plain');
        const objAddMaterials = document.getElementById('obj-add-materials');
        let pendingObjFile = null; // Holds OBJ file while dialog is open
        const plyTextureInput = document.getElementById('ply-texture-input');
        const plyDialogOverlay = document.getElementById('ply-dialog-overlay');
        const plyLoadPlain = document.getElementById('ply-load-plain');
        const plyAddTexture = document.getElementById('ply-add-texture');
        let pendingPlyFile = null; // Holds PLY file while dialog is open
        
        const btnLoad = document.getElementById('btn-load');
        const btnTexture = document.getElementById('btn-texture');
        const btnPoint = document.getElementById('btn-point');
        const btnLine = document.getElementById('btn-line');
        const btnPolygon = document.getElementById('btn-polygon');
        const btnSurface = document.getElementById('btn-surface');
        const btnMeasure = document.getElementById('btn-measure');
        const btnScreenshot = document.getElementById('btn-screenshot');
        const btnExport = document.getElementById('btn-export');
        const btnExportPdf = document.getElementById('btn-export-pdf');
        const btnImport = document.getElementById('btn-import');
        const btnAddGroup = document.getElementById('btn-add-group');
        
        const brushDisplay = document.getElementById('brush-display');
        const brushSlider = document.getElementById('brush-slider');
        const brushValue = document.getElementById('brush-value');

        const annotationPopup = document.getElementById('annotation-popup');
        const popupTitle = document.getElementById('popup-title');
        const annName = document.getElementById('ann-name');
        const annGroup = document.getElementById('ann-group');
        const annDescription = document.getElementById('ann-description');
        const annAuthor = document.getElementById('ann-author');
        const annLinks = document.getElementById('ann-links');
        const annNewLink = document.getElementById('ann-new-link');
        const btnAddLink = document.getElementById('btn-add-link');
        const btnPopupSave = document.getElementById('btn-popup-save');
        const btnPopupCancel = document.getElementById('btn-popup-cancel');
        const btnPopupDelete = document.getElementById('btn-popup-delete');
        
        const entriesContainer = document.getElementById('entries-container');
        const entriesList = document.getElementById('entries-list');
        const btnAddEntry = document.getElementById('btn-add-entry');
        const newEntryForm = document.getElementById('new-entry-form');
        
        const confirmOverlay = document.getElementById('confirm-overlay');
        const confirmMessage = document.getElementById('confirm-message');
        const confirmOk = document.getElementById('confirm-ok');
        const confirmCancel = document.getElementById('confirm-cancel');
        
        const scalebarConfirmOverlay = document.getElementById('scalebar-confirm-overlay');
        const scalebarNoSwitch = document.getElementById('scalebar-no-switch');
        const scalebarSwitch = document.getElementById('scalebar-switch');
        
        const modelInfoItem = document.getElementById('model-info-item');
        const modelInfoSubtitle = document.getElementById('model-info-subtitle');
        
        const modelStats = document.getElementById('model-stats');
        const faceCountDisplay = document.getElementById('face-count');

        const groupPopup = document.getElementById('group-popup');
        const groupPopupTitle = document.getElementById('group-popup-title');
        const groupName = document.getElementById('group-name');
        const groupColor = document.getElementById('group-color');
        const btnGroupSave = document.getElementById('btn-group-save');
        const btnGroupCancel = document.getElementById('btn-group-cancel');
        const btnGroupDelete = document.getElementById('btn-group-delete');

        const groupsContainer = document.getElementById('groups-container');
        const noGroups = document.getElementById('no-groups');
        const searchInput = document.getElementById('search-input');

        const measurementDisplay = document.getElementById('measurement-display');
        const measurementsList = document.getElementById('measurements-list');
        const loading = document.getElementById('loading');
        const status = document.getElementById('status');

        const brightnessSlider = document.getElementById('brightness-slider');
        const brightnessValue = document.getElementById('brightness-value');
        const opacitySlider = document.getElementById('opacity-slider');
        const opacityValue = document.getElementById('opacity-value');
        const lightToggle = document.getElementById('light-toggle');
        const lightDirectionRow = document.getElementById('light-direction-row');
        const lightAzimuthSlider = document.getElementById('light-azimuth-slider');
        const lightAzimuthValue = document.getElementById('light-azimuth-value');
        const lightElevationSlider = document.getElementById('light-elevation-slider');
        const lightElevationValue = document.getElementById('light-elevation-value');
        const pointSizeSlider = document.getElementById('point-size-slider');
        const pointSizeValue = document.getElementById('point-size-value');
        const textSizeSlider = document.getElementById('text-size-slider');
        const textSizeValue = document.getElementById('text-size-value');
        const slidersPanel = document.getElementById('sliders-panel');
        const slidersPanelToggle = document.getElementById('sliders-panel-toggle');

        const aboutOverlay = document.getElementById('about-overlay');
        const btnAbout = document.getElementById('btn-about');
        const aboutModalClose = document.getElementById('about-modal-close');
        const btnDownloadManual = document.getElementById('btn-download-manual');
        const legalOverlay = document.getElementById('legal-overlay');
        const btnLegal = document.getElementById('btn-legal');
        const legalModalClose = document.getElementById('legal-modal-close');
        const cameraToggle = document.getElementById('camera-toggle');

        let pendingLinks = [];
        let editingGroup = null;
        let editingEntryId = null;
        let isAddingEntry = false;
        let confirmCallback = null;
        let scalebarConfirmCallback = null;
        let scalebarNoSwitchCallback = null;
        
        // Popup dragging
        let isDraggingPopup = false;
        let popupDragOffsetX = 0;
        let popupDragOffsetY = 0;
        
        function resetPopupPosition() {
            // Center the popup in the viewport
            const viewportWidth = window.innerWidth - 320;
            const viewportHeight = window.innerHeight - 50;
            annotationPopup.style.left = Math.max(20, (viewportWidth - 400) / 2) + 'px';
            annotationPopup.style.top = Math.max(20, (viewportHeight - 400) / 2) + 'px';
            annotationPopup.style.right = 'auto';
            annotationPopup.style.bottom = 'auto';
        }
        
        // Get last used author from localStorage
        const AUTHOR_STORAGE_KEY = 'meshnotes_author';
        function getLastAuthor() {
            return localStorage.getItem(AUTHOR_STORAGE_KEY) || '';
        }
        function saveLastAuthor(author) {
            if (author) localStorage.setItem(AUTHOR_STORAGE_KEY, author);
        }

        // ============ Initialize Three.js ============
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x041D31);

            const width = window.innerWidth - 320;
            const height = window.innerHeight - 50;

            // Create both cameras
            perspectiveCamera = new THREE.PerspectiveCamera(60, width / height, 0.001, 1000);
            perspectiveCamera.position.set(2, 2, 2);

            const frustumSize = 5;
            const aspect = width / height;
            orthographicCamera = new THREE.OrthographicCamera(
                -frustumSize * aspect / 2, frustumSize * aspect / 2,
                frustumSize / 2, -frustumSize / 2,
                0.001, 1000
            );
            orthographicCamera.position.set(2, 2, 2);

            // Start with perspective camera
            camera = perspectiveCamera;

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputColorSpace = THREE.SRGBColorSpace;

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // ViewHelper (orientation gizmo)
            const vhCanvas = document.getElementById('viewhelper-canvas');
            viewHelperRenderer = new THREE.WebGLRenderer({ canvas: vhCanvas, alpha: true, antialias: true });
            viewHelperRenderer.setPixelRatio(window.devicePixelRatio);
            viewHelperRenderer.setSize(128, 128);

            viewHelper = new ViewHelper(camera, viewHelperRenderer.domElement);
            viewHelper.center = controls.target;

            // Click on ViewHelper axes to animate camera
            vhCanvas.addEventListener('pointerup', (event) => {
                if (viewHelper.handleClick(event)) {
                    // ViewHelper handles the camera animation
                }
            });

            // When ViewHelper animation changes camera, update controls
            viewHelper.addEventListener('change', () => {
                controls.update();
            });

            // Lights
            ambientLight = new THREE.AmbientLight(0xffffff, 0.72);
            scene.add(ambientLight);

            dirLight1 = new THREE.DirectionalLight(0xffffff, 0.96);
            dirLight1.position.set(5, 10, 7);
            dirLight1.target = new THREE.Object3D(); // Add target for camera-linked mode
            scene.add(dirLight1);
            scene.add(dirLight1.target);

            dirLight2 = new THREE.DirectionalLight(0xffffff, 0.48);
            dirLight2.position.set(-5, -5, -5);
            scene.add(dirLight2);

            // Annotation objects group
            scene.add(annotationObjects);

            // Grid helper
            const gridHelper = new THREE.GridHelper(10, 10, 0x1A5A8A, 0x1A5A8A);
            gridHelper.name = 'gridHelper';
            scene.add(gridHelper);

            window.addEventListener('resize', onWindowResize);
            animate();

            // Create default group
            createDefaultGroup();
        }

        function onWindowResize() {
            const width = window.innerWidth - 320;
            const height = window.innerHeight - 50;
            const aspect = width / height;

            // Update perspective camera
            perspectiveCamera.aspect = aspect;
            perspectiveCamera.updateProjectionMatrix();

            // Update orthographic camera
            const frustumSize = orthographicCamera.top * 2; // Current frustum size
            orthographicCamera.left = -frustumSize * aspect / 2;
            orthographicCamera.right = frustumSize * aspect / 2;
            orthographicCamera.updateProjectionMatrix();

            renderer.setSize(width, height);
            
            // Update line material resolutions
            annotationObjects.traverse((child) => {
                if (child.material && child.material.isLineMaterial) {
                    child.material.resolution.set(width, height);
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            controls.update();
            
            // Update light position if following camera
            if (lightFollowsCamera) {
                updateLightFromCamera();
            }
            
            renderer.render(scene, camera);

            // Update and render ViewHelper
            if (viewHelper.animating) {
                viewHelper.update(delta);
            }
            viewHelperRenderer.clear();
            viewHelper.render(viewHelperRenderer);
        }

        // ============ Camera Toggle ============
        function toggleCamera() {
            isOrthographic = !isOrthographic;

            if (isOrthographic) {
                // Switch to orthographic
                // Copy position and rotation from perspective camera
                orthographicCamera.position.copy(perspectiveCamera.position);
                orthographicCamera.quaternion.copy(perspectiveCamera.quaternion);

                // Calculate frustum size based on distance to target
                const distance = perspectiveCamera.position.distanceTo(controls.target);
                const fov = perspectiveCamera.fov * Math.PI / 180;
                const frustumHeight = 2 * distance * Math.tan(fov / 2);
                const aspect = (window.innerWidth - 320) / (window.innerHeight - 50);

                orthographicCamera.left = -frustumHeight * aspect / 2;
                orthographicCamera.right = frustumHeight * aspect / 2;
                orthographicCamera.top = frustumHeight / 2;
                orthographicCamera.bottom = -frustumHeight / 2;
                orthographicCamera.updateProjectionMatrix();

                camera = orthographicCamera;
                cameraToggle.textContent = 'Orthographic';
                cameraToggle.classList.add('active');
            } else {
                // Switch to perspective
                // Copy position and rotation from orthographic camera
                perspectiveCamera.position.copy(orthographicCamera.position);
                perspectiveCamera.quaternion.copy(orthographicCamera.quaternion);

                camera = perspectiveCamera;
                cameraToggle.textContent = 'Perspective';
                cameraToggle.classList.remove('active');
            }

            // Update controls to use new camera
            controls.object = camera;
            controls.update();

            // Recreate ViewHelper with new camera
            viewHelper.dispose();
            viewHelper = new ViewHelper(camera, viewHelperRenderer.domElement);
            viewHelper.center = controls.target;
            viewHelper.addEventListener('change', () => {
                controls.update();
            });
        }

        // ============ Model Loading ============
        function loadModel(file) {
            const ext = file.name.split('.').pop().toLowerCase();
            
            if (ext === 'obj') {
                // Store OBJ file and show material dialog
                pendingObjFile = file;
                objDialogOverlay.classList.add('visible');
                return;
            }
            
            if (ext === 'ply') {
                // Store PLY file and show texture dialog
                pendingPlyFile = file;
                plyDialogOverlay.classList.add('visible');
                return;
            }
            
            // GLB/GLTF path
            loading.classList.add('visible');
            modelFileName = file.name;
            
            // Reset model info for new model
            modelInfo = { entries: [] };
            updateModelInfoDisplay();
            
            const loader = new GLTFLoader();
            const url = URL.createObjectURL(file);

            loader.load(
                url,
                (gltf) => {
                    setupLoadedModel(gltf.scene, file.name);
                    URL.revokeObjectURL(url);
                },
                undefined,
                (error) => {
                    console.error('Error loading model:', error);
                    loading.classList.remove('visible');
                    showStatus('Error loading model!');
                }
            );
        }
        
        // Shared setup after any model (GLB/GLTF/OBJ) is loaded
        function setupLoadedModel(model, fileName) {
            if (currentModel) {
                scene.remove(currentModel);
            }

            const grid = scene.getObjectByName('gridHelper');
            if (grid) scene.remove(grid);

            currentModel = model;
            scene.add(currentModel);

            originalMaterials.clear();
            modelMeshes = []; // Clear mesh cache
            hasVertexColors = false; // Reset vertex color detection
            let totalFaces = 0;
            currentModel.traverse((child) => {
                if (child.isMesh) {
                    originalMaterials.set(child.uuid, child.material.clone());
                    modelMeshes.push(child); // Cache meshes for surface painting
                    
                    // Build BVH for accelerated raycasting and surface projection
                    if (!child.geometry.boundsTree) {
                        child.geometry.computeBoundsTree();
                    }
                    
                    // Check for vertex colors (COLOR_0 attribute)
                    if (child.geometry.attributes.color) {
                        hasVertexColors = true;
                    }
                    
                    // Count faces
                    const geometry = child.geometry;
                    if (geometry.index) {
                        totalFaces += geometry.index.count / 3;
                    } else if (geometry.attributes.position) {
                        totalFaces += geometry.attributes.position.count / 3;
                    }
                }
            });
            
            // Display face count
            updateFaceCountDisplay(totalFaces);

            // Center and fit
            const box = new THREE.Box3().setFromObject(currentModel);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            modelBoundingSize = maxDim; // Store for brush size calculation

            currentModel.position.sub(center);
            camera.position.set(maxDim * 1.5, maxDim * 1.5, maxDim * 1.5);
            controls.target.set(0, 0, 0);
            controls.update();

            // Enable tools
            btnTexture.disabled = false;
            btnPoint.disabled = false;
            btnLine.disabled = false;
            btnPolygon.disabled = false;
            btnSurface.disabled = false;
            btnMeasure.disabled = false;
            btnScreenshot.disabled = false;
            btnExport.disabled = false;
            btnExportPdf.disabled = false;
            displayMode = 'texture';
            updateTextureButtonLabel();
            
            // Apply display mode to fix vertex color multiplicative issue on first load
            applyDisplayMode();
            
            // Log vertex color detection result
            if (hasVertexColors) {
                console.log('Vertex colors detected in model');
            }

            // Apply current opacity setting
            if (modelOpacity < 1.0) {
                setModelOpacity(parseInt(opacitySlider.value));
            }

            loading.classList.remove('visible');
            showStatus(`Loaded: ${fileName}`);
        }
        
        // Load OBJ model with optional material/texture files
        function loadOBJModel(objFile, materialFiles) {
            loading.classList.add('visible');
            modelFileName = objFile.name;
            
            // Reset model info for new model
            modelInfo = { entries: [] };
            updateModelInfoDisplay();
            
            const objUrl = URL.createObjectURL(objFile);
            
            // Separate material files by type
            let mtlFile = null;
            const textureFiles = [];
            
            if (materialFiles && materialFiles.length > 0) {
                for (const f of materialFiles) {
                    const fExt = f.name.split('.').pop().toLowerCase();
                    if (fExt === 'mtl') {
                        mtlFile = f;
                    } else {
                        textureFiles.push(f);
                    }
                }
            }
            
            // Create object URLs for texture files (for MTLLoader to find them)
            const textureUrlMap = {};
            for (const tf of textureFiles) {
                textureUrlMap[tf.name] = URL.createObjectURL(tf);
            }
            
            if (mtlFile) {
                // Path A: MTL + Textures
                // Read MTL as text and use custom loading manager to resolve texture URLs
                const mtlReader = new FileReader();
                mtlReader.onload = (e) => {
                    const mtlText = e.target.result;
                    
                    // Custom loading manager that resolves texture filenames to our object URLs
                    const loadingManager = new THREE.LoadingManager();
                    loadingManager.setURLModifier((url) => {
                        // Extract just the filename from the URL path
                        const fileName = url.split('/').pop().split('\\').pop();
                        if (textureUrlMap[fileName]) {
                            return textureUrlMap[fileName];
                        }
                        return url;
                    });
                    
                    const mtlLoader = new MTLLoader(loadingManager);
                    const materials = mtlLoader.parse(mtlText, '');
                    materials.preload();
                    
                    const objLoader = new OBJLoader(loadingManager);
                    objLoader.setMaterials(materials);
                    
                    objLoader.load(
                        objUrl,
                        (obj) => {
                            // Ensure correct color space on all texture maps
                            obj.traverse((child) => {
                                if (child.isMesh && child.material) {
                                    const mat = child.material;
                                    if (mat.map) mat.map.colorSpace = THREE.SRGBColorSpace;
                                }
                            });
                            setupLoadedModel(obj, objFile.name);
                            // Clean up object URLs
                            URL.revokeObjectURL(objUrl);
                            Object.values(textureUrlMap).forEach(u => URL.revokeObjectURL(u));
                        },
                        undefined,
                        (error) => {
                            console.error('Error loading OBJ:', error);
                            loading.classList.remove('visible');
                            showStatus('Error loading OBJ model!');
                        }
                    );
                };
                mtlReader.onerror = () => {
                    console.error('Error reading MTL file');
                    showStatus('MTL failed, loading OBJ without materials...');
                    loadOBJPlain(objUrl, textureUrlMap, objFile.name);
                };
                mtlReader.readAsText(mtlFile);
            } else if (textureFiles.length > 0) {
                // Path B: Texture only (no MTL) - apply as diffuse map to all meshes
                loadOBJPlain(objUrl, textureUrlMap, objFile.name);
            } else {
                // Path C: No materials at all
                loadOBJPlain(objUrl, {}, objFile.name);
            }
        }
        
        // Load OBJ without MTL, optionally applying a single texture as diffuse map
        function loadOBJPlain(objUrl, textureUrlMap, fileName) {
            const objLoader = new OBJLoader();
            
            objLoader.load(
                objUrl,
                (obj) => {
                    // If we have texture files, apply the first one as diffuse map
                    const textureUrls = Object.values(textureUrlMap);
                    if (textureUrls.length > 0) {
                        const textureLoader = new THREE.TextureLoader();
                        const texture = textureLoader.load(textureUrls[0]);
                        texture.colorSpace = THREE.SRGBColorSpace;
                        
                        obj.traverse((child) => {
                            if (child.isMesh) {
                                child.material = new THREE.MeshStandardMaterial({
                                    map: texture,
                                    roughness: 0.7,
                                    metalness: 0.0
                                });
                            }
                        });
                    }
                    
                    setupLoadedModel(obj, fileName);
                    URL.revokeObjectURL(objUrl);
                    Object.values(textureUrlMap).forEach(u => URL.revokeObjectURL(u));
                },
                undefined,
                (error) => {
                    console.error('Error loading OBJ:', error);
                    loading.classList.remove('visible');
                    showStatus('Error loading OBJ model!');
                }
            );
        }

        // Load PLY with optional texture
        function loadPLYModel(plyFile, textureFile) {
            loading.classList.add('visible');
            modelFileName = plyFile.name;
            modelInfo = { entries: [] };
            updateModelInfoDisplay();
            
            const loader = new PLYLoader();
            const url = URL.createObjectURL(plyFile);
            
            loader.load(
                url,
                (geometry) => {
                    geometry.computeVertexNormals();
                    
                    const hasColors = !!geometry.attributes.color;
                    const hasUVs = !!geometry.attributes.uv;
                    
                    let material;
                    
                    if (textureFile && hasUVs) {
                        // Apply texture using UV coordinates
                        const texUrl = URL.createObjectURL(textureFile);
                        const textureLoader = new THREE.TextureLoader();
                        const texture = textureLoader.load(texUrl, () => {
                            URL.revokeObjectURL(texUrl);
                        });
                        texture.colorSpace = THREE.SRGBColorSpace;
                        texture.flipY = true;
                        
                        material = new THREE.MeshStandardMaterial({
                            map: texture,
                            roughness: 0.7,
                            metalness: 0.0,
                            side: THREE.DoubleSide
                        });
                    } else if (textureFile && !hasUVs) {
                        // User provided texture but PLY has no UVs
                        showStatus('Warning: PLY has no UV coordinates — texture ignored');
                        material = new THREE.MeshStandardMaterial({
                            roughness: 0.7,
                            metalness: 0.0,
                            vertexColors: hasColors,
                            color: hasColors ? 0xffffff : 0xcccccc,
                            side: THREE.DoubleSide
                        });
                    } else {
                        // No texture — use vertex colors or plain gray
                        material = new THREE.MeshStandardMaterial({
                            roughness: 0.7,
                            metalness: 0.0,
                            vertexColors: hasColors,
                            color: hasColors ? 0xffffff : 0xcccccc,
                            side: THREE.DoubleSide
                        });
                    }
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    const group = new THREE.Group();
                    group.add(mesh);
                    
                    setupLoadedModel(group, plyFile.name);
                    URL.revokeObjectURL(url);
                },
                undefined,
                (error) => {
                    console.error('Error loading PLY:', error);
                    loading.classList.remove('visible');
                    showStatus('Error loading PLY model!');
                }
            );
        }

        // ============ Texture Toggle (3-mode cycle) ============
        function toggleTexture() {
            if (!currentModel) return;
            
            // Cycle through modes: texture -> vertexColors (if available) -> gray -> texture
            if (displayMode === 'texture') {
                displayMode = hasVertexColors ? 'vertexColors' : 'gray';
            } else if (displayMode === 'vertexColors') {
                displayMode = 'gray';
            } else {
                displayMode = 'texture';
            }

            applyDisplayMode();
            updateTextureButtonLabel();
            
            const modeLabels = {
                'texture': 'Texture',
                'vertexColors': 'Vertex Colors',
                'gray': 'Gray'
            };
            showStatus(`Display: ${modeLabels[displayMode]}`);
        }
        
        function applyDisplayMode() {
            if (!currentModel) return;
            
            currentModel.traverse((child) => {
                if (child.isMesh) {
                    const original = originalMaterials.get(child.uuid);
                    
                    if (displayMode === 'texture') {
                        // Restore original material with textures, but disable vertex colors
                        // to prevent multiplicative darkening (glTF 2.0 multiplies vertex colors with texture)
                        if (original) {
                            child.material = original.clone();
                            child.material.vertexColors = false;
                        }
                    } else if (displayMode === 'vertexColors') {
                        // Show vertex colors only (no texture)
                        child.material = new THREE.MeshStandardMaterial({
                            vertexColors: true,
                            roughness: 0.7,
                            metalness: 0.0
                        });
                    } else {
                        // Gray mode - no texture, no vertex colors
                        child.material = new THREE.MeshStandardMaterial({
                            color: 0x888888,
                            roughness: 0.7,
                            metalness: 0.0
                        });
                    }
                    
                    // Preserve opacity setting
                    child.material.transparent = true;
                    child.material.opacity = modelOpacity;
                    child.material.depthWrite = modelOpacity > 0.9;
                }
            });
        }
        
        function updateTextureButtonLabel() {
            // Update button text and style based on current mode
            const labels = {
                'texture': '🖼️ Texture',
                'vertexColors': '🎨 Colors',
                'gray': '⬜ Gray'
            };
            btnTexture.innerHTML = labels[displayMode] || '🖼️ Texture';
            
            // Button is "active" (highlighted) when NOT in texture mode
            btnTexture.classList.toggle('active', displayMode !== 'texture');
        }

        // ============ Brightness Control ============
        function setBrightness(value) {
            const factor = value / 100;
            ambientLight.intensity = 0.72 * factor;
            // Apply 1.5x boost when in fixed direction mode for better raking light effect
            const dirLightMultiplier = lightFollowsCamera ? 1.0 : 1.5;
            dirLight1.intensity = 0.96 * factor * dirLightMultiplier;
            dirLight2.intensity = 0.48 * factor;
            brightnessValue.textContent = `${value}%`;
        }

        // ============ Opacity Control ============
        function setModelOpacity(value) {
            modelOpacity = value / 100;
            opacityValue.textContent = `${value}%`;
            
            if (!currentModel) return;

            currentModel.traverse((child) => {
                if (child.isMesh) {
                    child.material.transparent = true;
                    child.material.opacity = modelOpacity;
                    child.material.depthWrite = modelOpacity > 0.9;
                    child.material.needsUpdate = true;
                }
            });
        }

        // ============ Point Size Control ============
        function setPointSize(value) {
            pointSizeMultiplier = value / 100;
            pointSizeValue.textContent = `${value}%`;
            localStorage.setItem('meshnotes_pointSize', value);
            renderAnnotations();
        }

        // ============ Text Size Control ============
        function setTextSize(value) {
            textSizeMultiplier = value / 100;
            textSizeValue.textContent = `${value}%`;
            localStorage.setItem('meshnotes_textSize', value);
            renderAnnotations();
        }

        // ============ Light Controls ============
        function toggleLightMode() {
            lightFollowsCamera = !lightFollowsCamera;
            
            if (lightFollowsCamera) {
                lightToggle.textContent = 'Follows Camera';
                lightToggle.classList.add('active');
                lightDirectionRow.classList.remove('visible');
                // Restore normal light intensity
                dirLight1.intensity = 0.96 * (parseInt(brightnessSlider.value) / 100);
                updateLightFromCamera();
            } else {
                lightToggle.textContent = 'Fixed Direction';
                lightToggle.classList.remove('active');
                lightDirectionRow.classList.add('visible');
                // Boost light intensity 1.5x for better raking light shadow visibility
                dirLight1.intensity = 0.96 * (parseInt(brightnessSlider.value) / 100) * 1.5;
                updateFixedLightDirection();
            }
        }
        
        function updateLightFromCamera() {
            // Position light relative to camera direction
            const cameraDir = new THREE.Vector3();
            camera.getWorldDirection(cameraDir);
            
            // Light comes from camera direction (slightly above)
            const lightDistance = 10;
            const lightPos = camera.position.clone().sub(cameraDir.multiplyScalar(lightDistance));
            lightPos.y += 5; // Slightly above camera level
            
            dirLight1.position.copy(lightPos);
            dirLight1.target.position.copy(controls.target);
        }
        
        function updateFixedLightDirection() {
            // Convert spherical coordinates to Cartesian
            const azimuthRad = (fixedLightAzimuth * Math.PI) / 180;
            const elevationRad = (fixedLightElevation * Math.PI) / 180;
            
            const distance = 10;
            
            // Spherical to Cartesian conversion
            // Elevation: 0° = horizon, 90° = straight up, -90° = straight down
            const y = Math.sin(elevationRad) * distance;
            const horizontalDist = Math.cos(elevationRad) * distance;
            const x = Math.sin(azimuthRad) * horizontalDist;
            const z = Math.cos(azimuthRad) * horizontalDist;
            
            dirLight1.position.set(x, y, z);
            dirLight1.target.position.set(0, 0, 0);
        }
        
        function setLightAzimuth(value) {
            fixedLightAzimuth = value;
            lightAzimuthValue.textContent = `${value}°`;
            if (!lightFollowsCamera) {
                updateFixedLightDirection();
            }
        }
        
        function setLightElevation(value) {
            fixedLightElevation = value;
            lightElevationValue.textContent = `${value}°`;
            if (!lightFollowsCamera) {
                updateFixedLightDirection();
            }
        }

        // ============ Text Sprite Helper ============
        function createTextSprite(text, color = '#EDC040', backgroundColor = null, fontSize = 48) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            
            // Measure text to size canvas appropriately
            context.font = `bold ${fontSize}px Arial`;
            const metrics = context.measureText(text);
            const textWidth = metrics.width;
            const textHeight = fontSize;
            
            // Add small padding for text outline
            const padding = 8;
            canvas.width = textWidth + padding * 2;
            canvas.height = textHeight + padding * 2;
            
            // Draw text with outline for readability
            context.font = `bold ${fontSize}px Arial`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // Dark outline for contrast
            context.strokeStyle = 'rgba(0, 0, 0, 0.8)';
            context.lineWidth = 4;
            context.strokeText(text, canvas.width / 2, canvas.height / 2);
            
            // Main text color
            context.fillStyle = color;
            context.fillText(text, canvas.width / 2, canvas.height / 2);
            
            // Create sprite
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                depthTest: false,
                depthWrite: false
            });
            
            const sprite = new THREE.Sprite(spriteMaterial);
            
            // Scale sprite based on canvas aspect ratio
            const aspect = canvas.width / canvas.height;
            sprite.scale.set(aspect * 0.15, 0.15, 1);
            
            return sprite;
        }

        function createScaledTextSprite(text, color, position, scaleFactor = 1) {
            const sprite = createTextSprite(text, color);
            sprite.position.copy(position);
            
            // Scale using power of 0.7 - keeps large model labels the same, shrinks small model labels more
            if (currentModel) {
                const box = new THREE.Box3().setFromObject(currentModel);
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                sprite.scale.multiplyScalar(Math.pow(maxDim, 0.7) * 0.085 * scaleFactor * textSizeMultiplier);
            }
            
            return sprite;
        }

        // ============ Tool Selection ============
        function setTool(tool) {
            // Clear previous tool state
            clearTempDrawing();
            
            // If switching away from measure tool, clear all measurements
            if (currentTool === 'measure' && tool !== 'measure') {
                clearAllMeasurements();
                measurementDisplay.classList.remove('visible');
            }
            
            // If switching away from surface tool, clear temp surface
            if (currentTool === 'surface' && tool !== 'surface') {
                clearTempSurface();
                brushDisplay.classList.remove('visible');
            }

            if (currentTool === tool) {
                // If clicking same tool, deactivate it
                if (currentTool === 'measure') {
                    clearAllMeasurements();
                }
                if (currentTool === 'surface') {
                    clearTempSurface();
                }
                currentTool = null;
                canvas.style.cursor = 'default';
                measurementDisplay.classList.remove('visible');
                brushDisplay.classList.remove('visible');
            } else {
                currentTool = tool;
                canvas.style.cursor = 'crosshair';
            }

            // Update button states
            btnPoint.classList.toggle('active', currentTool === 'point');
            btnLine.classList.toggle('active', currentTool === 'line');
            btnPolygon.classList.toggle('active', currentTool === 'polygon');
            btnSurface.classList.toggle('active', currentTool === 'surface');
            btnMeasure.classList.toggle('active', currentTool === 'measure');

            if (currentTool === 'measure') {
                measurementDisplay.classList.add('visible');
                updateMeasurementsDisplay();
            }
            
            if (currentTool === 'surface') {
                brushDisplay.classList.add('visible');
                // Change right-click from pan to rotate for easier multi-angle painting
                controls.mouseButtons.RIGHT = THREE.MOUSE.ROTATE;
            } else {
                // Restore default right-click = pan behavior
                controls.mouseButtons.RIGHT = THREE.MOUSE.PAN;
            }

            updateInstructions();
        }

        function updateInstructions() {
            const instr = document.getElementById('instructions');
            let text = '<strong>Controls:</strong> Left-drag rotate · Right-drag pan · Scroll zoom';
            
            if (currentTool === 'point') {
                text = '<strong>Point:</strong> Click on model to place point';
            } else if (currentTool === 'line') {
                text = '<strong>Line:</strong> Click to add points · Double-click to finish';
            } else if (currentTool === 'polygon') {
                text = '<strong>Polygon:</strong> Click to add points · Double-click to close';
            } else if (currentTool === 'surface') {
                text = '<strong>Surface:</strong> Click/drag to paint · Right-drag to rotate · Hold Shift to erase · Double-click to finish';
            } else if (currentTool === 'measure') {
                text = '<strong>Measure:</strong> Click two points to measure distance';
            }
            
            instr.innerHTML = text;
        }

        function clearTempDrawing() {
            tempPoints = [];
            tempProjectedEdges = [];
            if (tempLine) {
                annotationObjects.remove(tempLine);
                tempLine = null;
            }
            // Only clear in-progress measurement points, not saved measurements
            measurePoints = [];
            measureMarkers.forEach(m => annotationObjects.remove(m));
            measureMarkers = [];
            if (measureLine) {
                annotationObjects.remove(measureLine);
                measureLine = null;
            }
            // Clear temp surface painting
            clearTempSurface();
        }

        // ============ Surface Painting ============
        function clearTempSurface() {
            paintedFaces.clear();
            isPaintingSurface = false;
            surfaceHighlightDirty = false;
            if (surfaceHighlightRAF) {
                cancelAnimationFrame(surfaceHighlightRAF);
                surfaceHighlightRAF = null;
            }
            if (surfaceHighlightMesh) {
                annotationObjects.remove(surfaceHighlightMesh);
                surfaceHighlightMesh.geometry.dispose();
                surfaceHighlightMesh.material.dispose();
                surfaceHighlightMesh = null;
            }
        }

        function getIntersectionWithFace(event) {
            if (!currentModel) return null;

            const rect = canvas.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(modelMeshes, false);

            if (intersects.length > 0) {
                return {
                    point: intersects[0].point.clone(),
                    faceIndex: intersects[0].faceIndex,
                    mesh: intersects[0].object
                };
            }
            return null;
        }

        function paintAtPoint(point, mesh, faceIndex) {
            if (!mesh || !mesh.geometry) return;

            const brushRadius = (surfaceBrushSize / 100) * modelBoundingSize;
            const geometry = mesh.geometry;
            const position = geometry.attributes.position;
            const meshIndex = modelMeshes.indexOf(mesh);
            
            // Use BVH shapecast for fast spatial query if available
            if (geometry.boundsTree) {
                // Transform brush center to local space
                const invMatrix = new THREE.Matrix4().copy(mesh.matrixWorld).invert();
                const localCenter = point.clone().applyMatrix4(invMatrix);
                
                // Compute local-space brush radius (account for non-uniform scale)
                const scale = new THREE.Vector3();
                mesh.matrixWorld.decompose(new THREE.Vector3(), new THREE.Quaternion(), scale);
                const avgScale = (scale.x + scale.y + scale.z) / 3;
                const localRadius = brushRadius / avgScale;
                
                const localRadiusSq = localRadius * localRadius;
                
                geometry.boundsTree.shapecast({
                    intersectsBounds: (box) => {
                        // Quick AABB vs sphere test
                        const closestPoint = new THREE.Vector3();
                        box.clampPoint(localCenter, closestPoint);
                        return closestPoint.distanceToSquared(localCenter) <= localRadiusSq;
                    },
                    intersectsTriangle: (triangle, triIndex) => {
                        // Check face center distance
                        const faceCenter = new THREE.Vector3()
                            .addVectors(triangle.a, triangle.b)
                            .add(triangle.c)
                            .divideScalar(3);
                        
                        if (faceCenter.distanceToSquared(localCenter) <= localRadiusSq) {
                            const faceId = `${meshIndex}_${triIndex}`;
                            if (isErasingMode) {
                                paintedFaces.delete(faceId);
                            } else {
                                paintedFaces.add(faceId);
                            }
                        }
                        return false; // Continue traversal
                    }
                });
            } else {
                // Fallback: brute-force for geometries without BVH
                const faceCount = geometry.index 
                    ? geometry.index.count / 3 
                    : position.count / 3;

                for (let i = 0; i < faceCount; i++) {
                    let a, b, c;
                    if (geometry.index) {
                        a = geometry.index.getX(i * 3);
                        b = geometry.index.getX(i * 3 + 1);
                        c = geometry.index.getX(i * 3 + 2);
                    } else {
                        a = i * 3;
                        b = i * 3 + 1;
                        c = i * 3 + 2;
                    }

                    const vA = new THREE.Vector3().fromBufferAttribute(position, a);
                    const vB = new THREE.Vector3().fromBufferAttribute(position, b);
                    const vC = new THREE.Vector3().fromBufferAttribute(position, c);
                    vA.applyMatrix4(mesh.matrixWorld);
                    vB.applyMatrix4(mesh.matrixWorld);
                    vC.applyMatrix4(mesh.matrixWorld);

                    const faceCenter = new THREE.Vector3()
                        .addVectors(vA, vB)
                        .add(vC)
                        .divideScalar(3);

                    if (faceCenter.distanceTo(point) <= brushRadius) {
                        const faceId = `${meshIndex}_${i}`;
                        if (isErasingMode) {
                            paintedFaces.delete(faceId);
                        } else {
                            paintedFaces.add(faceId);
                        }
                    }
                }
            }

            // Schedule throttled highlight update (batches rapid paint strokes)
            scheduleSurfaceHighlight();
        }

        function scheduleSurfaceHighlight() {
            surfaceHighlightDirty = true;
            if (!surfaceHighlightRAF) {
                surfaceHighlightRAF = requestAnimationFrame(() => {
                    surfaceHighlightRAF = null;
                    if (surfaceHighlightDirty) {
                        surfaceHighlightDirty = false;
                        updateSurfaceHighlight();
                    }
                });
            }
        }

        function updateSurfaceHighlight() {
            // Remove old highlight mesh
            if (surfaceHighlightMesh) {
                annotationObjects.remove(surfaceHighlightMesh);
                surfaceHighlightMesh.geometry.dispose();
                surfaceHighlightMesh.material.dispose();
                surfaceHighlightMesh = null;
            }

            if (paintedFaces.size === 0) return;

            // Group faces by mesh index
            const facesByMesh = new Map();
            paintedFaces.forEach(faceId => {
                const [meshIdx, faceIdx] = faceId.split('_');
                if (!facesByMesh.has(meshIdx)) {
                    facesByMesh.set(meshIdx, []);
                }
                facesByMesh.set(meshIdx, [...facesByMesh.get(meshIdx), parseInt(faceIdx)]);
            });

            // Build combined geometry
            const vertices = [];
            
            facesByMesh.forEach((faceIndices, meshIdx) => {
                const mesh = modelMeshes[parseInt(meshIdx)];
                if (!mesh) return;

                const geometry = mesh.geometry;
                const position = geometry.attributes.position;

                faceIndices.forEach(faceIdx => {
                    let a, b, c;
                    if (geometry.index) {
                        a = geometry.index.getX(faceIdx * 3);
                        b = geometry.index.getX(faceIdx * 3 + 1);
                        c = geometry.index.getX(faceIdx * 3 + 2);
                    } else {
                        a = faceIdx * 3;
                        b = faceIdx * 3 + 1;
                        c = faceIdx * 3 + 2;
                    }

                    const vA = new THREE.Vector3().fromBufferAttribute(position, a);
                    const vB = new THREE.Vector3().fromBufferAttribute(position, b);
                    const vC = new THREE.Vector3().fromBufferAttribute(position, c);

                    // Apply mesh world transform
                    vA.applyMatrix4(mesh.matrixWorld);
                    vB.applyMatrix4(mesh.matrixWorld);
                    vC.applyMatrix4(mesh.matrixWorld);

                    vertices.push(vA.x, vA.y, vA.z);
                    vertices.push(vB.x, vB.y, vB.z);
                    vertices.push(vC.x, vC.y, vC.z);
                });
            });

            if (vertices.length === 0) return;

            // Create highlight geometry
            const highlightGeometry = new THREE.BufferGeometry();
            highlightGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            highlightGeometry.computeVertexNormals();

            // Get current group color or use default gold
            const color = groups.length > 0 ? groups[0].color : '#EDC040';

            const highlightMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide,
                depthTest: true,
                depthWrite: false,
                polygonOffset: true,
                polygonOffsetFactor: -4,
                polygonOffsetUnits: -4
            });

            surfaceHighlightMesh = new THREE.Mesh(highlightGeometry, highlightMaterial);
            surfaceHighlightMesh.renderOrder = 999;
            annotationObjects.add(surfaceHighlightMesh);
        }

        function finishSurfacePainting(event) {
            if (paintedFaces.size === 0) {
                showStatus('No surface painted');
                clearTempSurface();
                return;
            }

            // Calculate center point from all painted faces
            const center = new THREE.Vector3();
            let count = 0;

            paintedFaces.forEach(faceId => {
                const [meshIdx, faceIdx] = faceId.split('_');
                const mesh = modelMeshes[parseInt(meshIdx)];
                if (!mesh) return;

                const geometry = mesh.geometry;
                const position = geometry.attributes.position;
                const idx = parseInt(faceIdx);

                let a, b, c;
                if (geometry.index) {
                    a = geometry.index.getX(idx * 3);
                    b = geometry.index.getX(idx * 3 + 1);
                    c = geometry.index.getX(idx * 3 + 2);
                } else {
                    a = idx * 3;
                    b = idx * 3 + 1;
                    c = idx * 3 + 2;
                }

                const vA = new THREE.Vector3().fromBufferAttribute(position, a);
                const vB = new THREE.Vector3().fromBufferAttribute(position, b);
                const vC = new THREE.Vector3().fromBufferAttribute(position, c);

                vA.applyMatrix4(mesh.matrixWorld);
                vB.applyMatrix4(mesh.matrixWorld);
                vC.applyMatrix4(mesh.matrixWorld);

                const faceCenter = new THREE.Vector3()
                    .addVectors(vA, vB)
                    .add(vC)
                    .divideScalar(3);

                center.add(faceCenter);
                count++;
            });

            center.divideScalar(count);

            // Store face IDs as the "points" data for surface annotations
            const faceData = Array.from(paintedFaces);

            // Open popup with center point
            openAnnotationPopup(event, 'surface', [center], faceData);
            
            // Clear temp highlight (will be re-rendered as annotation)
            if (surfaceHighlightMesh) {
                annotationObjects.remove(surfaceHighlightMesh);
                surfaceHighlightMesh.geometry.dispose();
                surfaceHighlightMesh.material.dispose();
                surfaceHighlightMesh = null;
            }
            paintedFaces.clear();
            isPaintingSurface = false;
        }

        // ============ Raycasting ============
        function getIntersection(event) {
            if (!currentModel) return null;

            const rect = canvas.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(currentModel, true);

            return intersects.length > 0 ? intersects[0].point.clone() : null;
        }

        // ============ Surface Projection (BVH) ============
        /**
         * Projects a straight line between two points onto the mesh surface.
         * Uses BVH closestPointToPoint for robust, direction-independent projection.
         * @param {THREE.Vector3} pointA - Start point (world coordinates)
         * @param {THREE.Vector3} pointB - End point (world coordinates)
         * @param {number} segments - Number of intermediate sample points
         * @returns {Array<{x,y,z}>|null} - Array of surface-projected points, or null if no mesh
         */
        function projectEdgeToSurface(pointA, pointB, segments = 30) {
            if (modelMeshes.length === 0) return null;
            
            const projectedPoints = [];
            const tempPoint = new THREE.Vector3();
            const localPoint = new THREE.Vector3();
            const invMatrix = new THREE.Matrix4();
            
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                tempPoint.lerpVectors(pointA, pointB, t);
                
                let bestDistance = Infinity;
                let bestPoint = null;
                
                for (const mesh of modelMeshes) {
                    if (!mesh.geometry.boundsTree) continue;
                    
                    // Transform point to geometry's local space
                    invMatrix.copy(mesh.matrixWorld).invert();
                    localPoint.copy(tempPoint).applyMatrix4(invMatrix);
                    
                    const target = { point: new THREE.Vector3(), distance: 0, faceIndex: 0 };
                    const result = mesh.geometry.boundsTree.closestPointToPoint(localPoint, target);
                    
                    if (result && result.distance < bestDistance) {
                        bestDistance = result.distance;
                        bestPoint = result.point.clone().applyMatrix4(mesh.matrixWorld);
                    }
                }
                
                if (bestPoint) {
                    projectedPoints.push({ x: bestPoint.x, y: bestPoint.y, z: bestPoint.z });
                } else {
                    projectedPoints.push({ x: tempPoint.x, y: tempPoint.y, z: tempPoint.z });
                }
            }
            
            return projectedPoints;
        }

        /**
         * Measures the maximum perpendicular deviation of projected points from
         * the straight line between pointA and pointB.
         * @returns {number} Maximum deviation as fraction of edge length (0 = no deviation)
         */
        /**
         * Checks whether a projected edge stays close enough to the straight line.
         * Uses two limits (whichever is stricter wins):
         *  - Relative: max deviation as fraction of edge length (handles short edges)
         *  - Absolute: max deviation as fraction of model size (catches long edges over rubble)
         * @returns {boolean} true if projection is acceptable
         */
        function isProjectionAcceptable(projectedPoints, pointA, pointB) {
            const lineDir = new THREE.Vector3().subVectors(pointB, pointA);
            const lineLength = lineDir.length();
            if (lineLength < 1e-10) return true;
            lineDir.normalize();
            
            // Compute allowed deviation: minimum of relative and absolute limit
            const relativeLimit = projectionDeviationRelative * lineLength;
            const absoluteLimit = projectionDeviationAbsolute * modelBoundingSize;
            const maxAllowed = Math.min(relativeLimit, absoluteLimit);
            
            const toPoint = new THREE.Vector3();
            const closestOnLine = new THREE.Vector3();
            
            for (const p of projectedPoints) {
                toPoint.set(p.x, p.y, p.z).sub(pointA);
                const t = Math.max(0, Math.min(lineLength, toPoint.dot(lineDir)));
                closestOnLine.copy(pointA).addScaledVector(lineDir, t);
                const deviation = closestOnLine.distanceTo(new THREE.Vector3(p.x, p.y, p.z));
                if (deviation > maxAllowed) return false; // Early exit
            }
            
            return true;
        }

        /**
         * Computes projected edges for all consecutive point pairs.
         * @param {Array<{x,y,z}>} points - The user-clicked corner points
         * @param {boolean} closePolygon - Whether to add a closing edge (last→first)
         * @param {number} segments - Segments per edge
         * @returns {Array<Array<{x,y,z}>>} - Array of projected edge arrays
         */
        function computeProjectedEdges(points, closePolygon = false, segments = 30) {
            const edges = [];
            const vec3Points = points.map(p => new THREE.Vector3(p.x, p.y, p.z));
            
            for (let i = 0; i < vec3Points.length - 1; i++) {
                const projected = projectEdgeToSurface(vec3Points[i], vec3Points[i + 1], segments);
                if (projected && isProjectionAcceptable(projected, vec3Points[i], vec3Points[i + 1])) {
                    edges.push(projected);
                } else {
                    edges.push([points[i], points[i + 1]]); // Fallback: straight line
                }
            }
            
            if (closePolygon && vec3Points.length > 2) {
                const lastEdge = projectEdgeToSurface(
                    vec3Points[vec3Points.length - 1], vec3Points[0], segments
                );
                if (lastEdge && isProjectionAcceptable(lastEdge, vec3Points[vec3Points.length - 1], vec3Points[0])) {
                    edges.push(lastEdge);
                } else {
                    edges.push([points[points.length - 1], points[0]]);
                }
            }
            
            return edges;
        }

        /**
         * Recomputes only the edges adjacent to a moved point.
         * @param {Object} ann - The annotation object
         * @param {number} pointIndex - Index of the moved point
         */
        function recomputeAdjacentEdges(ann, pointIndex) {
            if (!ann.projectedEdges) return;
            const n = ann.points.length;
            const vec3Points = ann.points.map(p => new THREE.Vector3(p.x, p.y, p.z));
            
            // Edge from previous point to this point
            const prevIdx = (ann.type === 'polygon') 
                ? (pointIndex - 1 + n) % n 
                : pointIndex - 1;
            if (prevIdx >= 0 && prevIdx < n) {
                const edgeIdx = (ann.type === 'polygon') ? prevIdx : prevIdx;
                if (edgeIdx < ann.projectedEdges.length) {
                    const projected = projectEdgeToSurface(vec3Points[prevIdx], vec3Points[pointIndex], 15);
                    if (projected && isProjectionAcceptable(projected, vec3Points[prevIdx], vec3Points[pointIndex])) {
                        ann.projectedEdges[edgeIdx] = projected;
                    } else {
                        ann.projectedEdges[edgeIdx] = [ann.points[prevIdx], ann.points[pointIndex]];
                    }
                }
            }
            
            // Edge from this point to next point
            const nextIdx = pointIndex + 1;
            if (nextIdx < n) {
                const edgeIdx = pointIndex;
                if (edgeIdx < ann.projectedEdges.length) {
                    const projected = projectEdgeToSurface(vec3Points[pointIndex], vec3Points[nextIdx], 15);
                    if (projected && isProjectionAcceptable(projected, vec3Points[pointIndex], vec3Points[nextIdx])) {
                        ann.projectedEdges[edgeIdx] = projected;
                    } else {
                        ann.projectedEdges[edgeIdx] = [ann.points[pointIndex], ann.points[nextIdx]];
                    }
                }
            } else if (ann.type === 'polygon' && pointIndex === n - 1) {
                // Closing edge of polygon: last → first
                const closingIdx = ann.projectedEdges.length - 1;
                const projected = projectEdgeToSurface(vec3Points[pointIndex], vec3Points[0], 15);
                if (projected && isProjectionAcceptable(projected, vec3Points[pointIndex], vec3Points[0])) {
                    ann.projectedEdges[closingIdx] = projected;
                } else {
                    ann.projectedEdges[closingIdx] = [ann.points[pointIndex], ann.points[0]];
                }
            }
        }

        /**
         * Re-projects all line/polygon annotations onto the current model surface.
         * Call after importing annotations or loading a new model.
         */
        function reprojectAllAnnotations() {
            if (modelMeshes.length === 0 || !surfaceProjectionEnabled) return;
            
            let count = 0;
            annotations.forEach(ann => {
                if ((ann.type === 'line' || ann.type === 'polygon') && ann.points.length >= 2) {
                    ann.projectedEdges = computeProjectedEdges(ann.points, ann.type === 'polygon');
                    ann.surfaceProjection = true;
                    count++;
                }
            });
            
            if (count > 0) {
                renderAnnotations();
                showStatus(`Re-projected ${count} annotations onto surface`);
            }
        }

        // ============ Canvas Events ============
        function onCanvasClick(event) {
            // Prevent click event right after dragging
            if (wasDragging) {
                wasDragging = false;
                return;
            }
            
            if (!currentTool || !currentModel) return;

            const point = getIntersection(event);
            if (!point) return;

            if (currentTool === 'point') {
                // Use position captured on mousedown to prevent slipping
                const pointToUse = pendingPointPosition || point;
                pendingPointPosition = null;
                if (!pointToUse) return;
                openAnnotationPopup(event, 'point', [pointToUse]);
                setTool(null);
            } else if (currentTool === 'line') {
                tempPoints.push(point);
                updateTempLine();
            } else if (currentTool === 'polygon') {
                tempPoints.push(point);
                updateTempLine();
            } else if (currentTool === 'measure') {
                measurePoints.push(point);
                addMeasureMarker(point);
                
                if (measurePoints.length === 2) {
                    const dist = measurePoints[0].distanceTo(measurePoints[1]);
                    
                    // Create the line
                    updateMeasureLine();
                    
                    // Create label at midpoint
                    const midpoint = new THREE.Vector3().addVectors(measurePoints[0], measurePoints[1]).multiplyScalar(0.5);
                    const labelText = `${dist.toFixed(3)} units`;
                    const label = createScaledTextSprite(labelText, '#AA8101', midpoint, 0.5);
                    annotationObjects.add(label);
                    
                    // Store this measurement
                    const measurementId = measurements.length + 1;
                    measurements.push({
                        id: measurementId,
                        distance: dist,
                        markers: [...measureMarkers],
                        line: measureLine,
                        label: label
                    });
                    
                    // Update display
                    updateMeasurementsDisplay();
                    
                    // Reset for next measurement but keep existing ones
                    measurePoints = [];
                    measureMarkers = [];
                    measureLine = null;
                }
            } else if (currentTool === 'surface') {
                // Surface painting is handled by mousedown/mousemove
                // Single click just paints at that point
                isErasingMode = event.shiftKey;
                const hitInfo = getIntersectionWithFace(event);
                if (hitInfo) {
                    paintAtPoint(hitInfo.point, hitInfo.mesh, hitInfo.faceIndex);
                }
            }
        }

        function onCanvasDblClick(event) {
            if (!currentModel) return;

            const point = getIntersection(event);

            if (currentTool === 'line' && tempPoints.length >= 2) {
                openAnnotationPopup(event, 'line', [...tempPoints]);
                setTool(null);
            } else if (currentTool === 'polygon' && tempPoints.length >= 3) {
                openAnnotationPopup(event, 'polygon', [...tempPoints]);
                setTool(null);
            } else if (currentTool === 'surface' && paintedFaces.size > 0) {
                finishSurfacePainting(event);
                setTool(null);
            }
        }

        function onCanvasMouseDown(event) {
            // Handle point tool - capture position on mousedown to prevent slipping
            if (currentTool === 'point' && currentModel && event.button === 0) {
                pendingPointPosition = getIntersection(event);
                return;
            }
            
            // Handle surface painting - only on left click (button 0)
            // Right click (button 2) allows panning to rotate view while painting
            if (currentTool === 'surface' && currentModel && event.button === 0) {
                isPaintingSurface = true;
                isErasingMode = event.shiftKey;
                controls.enabled = false; // Disable orbit during painting
                
                const hitInfo = getIntersectionWithFace(event);
                if (hitInfo) {
                    paintAtPoint(hitInfo.point, hitInfo.mesh, hitInfo.faceIndex);
                }
                return;
            }
            
            if (!currentModel || currentTool) return; // Don't drag when a tool is active
            
            const rect = canvas.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            // Check for intersection with annotation markers
            const markerObjects = annotationObjects.children.filter(obj => 
                obj.userData.isAnnotationMarker && obj.isMesh
            );
            
            const intersects = raycaster.intersectObjects(markerObjects);
            
            if (intersects.length > 0) {
                const marker = intersects[0].object;
                const annId = marker.userData.annotationId;
                const pointIndex = marker.userData.pointIndex;
                
                draggedAnnotation = annotations.find(a => a.id === annId);
                if (draggedAnnotation) {
                    isDraggingPoint = true;
                    draggedPointIndex = pointIndex;
                    draggedMarker = marker;
                    controls.enabled = false; // Disable orbit controls during drag
                    canvas.style.cursor = 'grabbing';
                }
            }
        }

        function onCanvasMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );
            
            // Handle surface painting
            if (isPaintingSurface && currentTool === 'surface' && currentModel) {
                isErasingMode = event.shiftKey;
                const hitInfo = getIntersectionWithFace(event);
                if (hitInfo) {
                    paintAtPoint(hitInfo.point, hitInfo.mesh, hitInfo.faceIndex);
                }
                return;
            }
            
            // Handle active dragging
            if (isDraggingPoint && draggedMarker && currentModel) {
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);
                
                const intersects = raycaster.intersectObject(currentModel, true);
                
                if (intersects.length > 0) {
                    const newPos = intersects[0].point;
                    draggedMarker.position.copy(newPos);
                    
                    // Update the annotation data in real-time for visual feedback
                    if (draggedAnnotation && draggedPointIndex >= 0) {
                        draggedAnnotation.points[draggedPointIndex] = {
                            x: newPos.x,
                            y: newPos.y,
                            z: newPos.z
                        };
                        
                        // Recompute adjacent projected edges (uses fewer segments for responsiveness)
                        if (draggedAnnotation.projectedEdges && draggedAnnotation.surfaceProjection) {
                            recomputeAdjacentEdges(draggedAnnotation, draggedPointIndex);
                        }
                        
                        // Re-render to update lines/polygons
                        renderAnnotations();
                        
                        // Re-find the marker after re-render
                        const markers = annotationObjects.children.filter(obj => 
                            obj.userData.isAnnotationMarker && 
                            obj.userData.annotationId === draggedAnnotation.id &&
                            obj.userData.pointIndex === draggedPointIndex
                        );
                        if (markers.length > 0) {
                            draggedMarker = markers[0];
                        }
                    }
                }
                return;
            }
            
            // Handle hover cursor when not dragging and no tool active
            if (!currentTool && currentModel) {
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);
                
                const markerObjects = annotationObjects.children.filter(obj => 
                    obj.userData.isAnnotationMarker && obj.isMesh
                );
                
                const intersects = raycaster.intersectObjects(markerObjects);
                
                if (intersects.length > 0) {
                    canvas.style.cursor = 'grab';
                } else {
                    canvas.style.cursor = 'default';
                }
            }
        }

        function onCanvasMouseUp(event) {
            // Handle surface painting stop
            if (isPaintingSurface) {
                isPaintingSurface = false;
                controls.enabled = true; // Re-enable orbit controls
            }
            
            if (isDraggingPoint) {
                wasDragging = true; // Prevent click event
                
                // Full-quality recompute of all projected edges after drag
                if (draggedAnnotation && draggedAnnotation.surfaceProjection && 
                    (draggedAnnotation.type === 'line' || draggedAnnotation.type === 'polygon')) {
                    draggedAnnotation.projectedEdges = computeProjectedEdges(
                        draggedAnnotation.points, 
                        draggedAnnotation.type === 'polygon'
                    );
                }
                
                isDraggingPoint = false;
                draggedAnnotation = null;
                draggedPointIndex = -1;
                draggedMarker = null;
                controls.enabled = true; // Re-enable orbit controls
                canvas.style.cursor = 'default';
                
                // Final render and update UI
                renderAnnotations();
                updateGroupsList();
                showStatus('Point moved');
            }
        }

        function updateTempLine() {
            if (tempLine) {
                annotationObjects.remove(tempLine);
            }

            if (tempPoints.length < 2) return;

            const positions = [];
            
            if (surfaceProjectionEnabled && modelMeshes.length > 0) {
                // Surface-projected preview
                for (let i = 0; i < tempPoints.length - 1; i++) {
                    let edgePoints;
                    if (i < tempProjectedEdges.length && tempProjectedEdges[i]) {
                        // Use cached projection for completed edges
                        edgePoints = tempProjectedEdges[i];
                    } else {
                        // Compute projection for latest edge (fewer segments for responsiveness)
                        const projected = projectEdgeToSurface(tempPoints[i], tempPoints[i + 1], 20);
                        const straightFallback = [
                            { x: tempPoints[i].x, y: tempPoints[i].y, z: tempPoints[i].z },
                            { x: tempPoints[i + 1].x, y: tempPoints[i + 1].y, z: tempPoints[i + 1].z }
                        ];
                        // Check deviation threshold
                        if (projected && isProjectionAcceptable(projected, tempPoints[i], tempPoints[i + 1])) {
                            edgePoints = projected;
                        } else {
                            edgePoints = straightFallback;
                        }
                        // Cache completed edges (not the last one, which may change)
                        if (i < tempPoints.length - 2) {
                            tempProjectedEdges[i] = edgePoints;
                        }
                    }
                    // Add points, skip first point of subsequent edges to avoid duplicates
                    const startIdx = (i === 0) ? 0 : 1;
                    for (let j = startIdx; j < edgePoints.length; j++) {
                        positions.push(edgePoints[j].x, edgePoints[j].y, edgePoints[j].z);
                    }
                }
            } else {
                // Classic straight-line preview
                tempPoints.forEach(p => positions.push(p.x, p.y, p.z));
            }

            const geometry = new LineGeometry();
            geometry.setPositions(positions);

            const material = new LineMaterial({
                color: 0xEDC040,
                linewidth: 3,
                resolution: new THREE.Vector2(window.innerWidth - 320, window.innerHeight - 50),
                polygonOffset: true,
                polygonOffsetFactor: -4,
                polygonOffsetUnits: -4
            });

            tempLine = new Line2(geometry, material);
            annotationObjects.add(tempLine);
        }

        function addMeasureMarker(point) {
            const geometry = new THREE.SphereGeometry(0.01, 16, 16);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xFFFFFF,  // White for contrast
                depthTest: true,
                polygonOffset: true,
                polygonOffsetFactor: -5,
                polygonOffsetUnits: -5
            });
            const marker = new THREE.Mesh(geometry, material);
            marker.position.copy(point);
            marker.renderOrder = 1000;  // Render on top
            
            if (currentModel) {
                const box = new THREE.Box3().setFromObject(currentModel);
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                marker.scale.setScalar(Math.pow(maxDim, 0.8) * 0.05 * pointSizeMultiplier);  // Larger markers
            }

            annotationObjects.add(marker);
            measureMarkers.push(marker);
        }

        function updateMeasureLine() {
            if (measureLine) {
                annotationObjects.remove(measureLine);
            }

            if (measurePoints.length !== 2) return;

            const positions = [
                measurePoints[0].x, measurePoints[0].y, measurePoints[0].z,
                measurePoints[1].x, measurePoints[1].y, measurePoints[1].z
            ];

            const geometry = new LineGeometry();
            geometry.setPositions(positions);

            const material = new LineMaterial({
                color: 0xAA8101,
                linewidth: 3,
                resolution: new THREE.Vector2(window.innerWidth - 320, window.innerHeight - 50),
                polygonOffset: true,
                polygonOffsetFactor: -4,
                polygonOffsetUnits: -4
            });

            measureLine = new Line2(geometry, material);
            annotationObjects.add(measureLine);
        }

        function updateMeasurementsDisplay() {
            if (measurements.length === 0) {
                measurementsList.innerHTML = '<div style="color: #888;">No measurements yet</div>';
            } else {
                measurementsList.innerHTML = measurements.map(m => `
                    <div class="measurement-item">
                        <span class="label">Distance ${m.id}:</span>
                        <span class="value">${m.distance.toFixed(3)} units</span>
                    </div>
                `).join('');
            }
        }

        function clearAllMeasurements() {
            // Clear current in-progress measurement
            measurePoints = [];
            measureMarkers.forEach(m => annotationObjects.remove(m));
            measureMarkers = [];
            if (measureLine) {
                annotationObjects.remove(measureLine);
                measureLine = null;
            }
            
            // Clear all saved measurements
            measurements.forEach(m => {
                m.markers.forEach(marker => annotationObjects.remove(marker));
                if (m.line) annotationObjects.remove(m.line);
                if (m.label) annotationObjects.remove(m.label);
            });
            measurements = [];
            
            updateMeasurementsDisplay();
        }

        // ============ Groups ============
        function createDefaultGroup() {
            if (groups.length === 0) {
                groups.push({
                    id: Date.now(),
                    name: 'Default',
                    color: '#EDC040',
                    visible: true
                });
                updateGroupsList();
            }
        }

        function openGroupPopup(group = null) {
            editingGroup = group;
            
            if (group) {
                groupPopupTitle.textContent = 'Edit Group';
                groupName.value = group.name;
                groupColor.value = group.color;
                btnGroupDelete.style.display = groups.length > 1 ? 'block' : 'none';
            } else {
                groupPopupTitle.textContent = 'New Group';
                groupName.value = '';
                groupColor.value = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
                btnGroupDelete.style.display = 'none';
            }

            groupPopup.classList.add('visible');
            groupName.focus();
        }

        function saveGroup() {
            const name = groupName.value.trim() || 'Unnamed Group';
            const color = groupColor.value;

            if (editingGroup) {
                editingGroup.name = name;
                editingGroup.color = color;
            } else {
                groups.push({
                    id: Date.now(),
                    name,
                    color,
                    visible: true
                });
            }

            groupPopup.classList.remove('visible');
            editingGroup = null;
            updateGroupsList();
            updateGroupSelect();
            renderAnnotations();
        }

        function deleteGroup(group) {
            if (groups.length <= 1) {
                showStatus('Cannot delete the last group');
                return;
            }

            // Move annotations to first other group
            const targetGroup = groups.find(g => g.id !== group.id);
            annotations.forEach(ann => {
                if (ann.groupId === group.id) {
                    ann.groupId = targetGroup.id;
                }
            });

            groups = groups.filter(g => g.id !== group.id);
            groupPopup.classList.remove('visible');
            editingGroup = null;
            updateGroupsList();
            updateGroupSelect();
            renderAnnotations();
        }

        function toggleGroupVisibility(group) {
            group.visible = !group.visible;
            updateGroupsList();
            renderAnnotations();
        }

        function updateGroupsList() {
            if (groups.length === 0) {
                noGroups.style.display = 'block';
                groupsContainer.innerHTML = '';
                return;
            }

            noGroups.style.display = 'none';
            
            groupsContainer.innerHTML = groups.map(group => {
                const groupAnnotations = annotations.filter(a => a.groupId === group.id);
                return `
                    <div class="group-item" data-id="${group.id}">
                        <div class="group-header">
                            <div class="group-color" style="background: ${group.color}" data-action="edit"></div>
                            <span class="group-name" data-action="edit">${escapeHtml(group.name)} (${groupAnnotations.length})</span>
                            <button class="group-visibility ${group.visible ? '' : 'hidden'}" data-action="visibility">
                                ${group.visible ? '👁' : '👁‍🗨'}
                            </button>
                            <div class="group-actions">
                                <button data-action="edit">✏️</button>
                            </div>
                        </div>
                        ${group.visible ? `
                            <div class="annotation-list">
                                ${groupAnnotations.map(ann => renderAnnotationItem(ann)).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');

            // Event listeners
            groupsContainer.querySelectorAll('.group-header').forEach(header => {
                header.addEventListener('click', (e) => {
                    const groupId = parseInt(header.closest('.group-item').dataset.id);
                    const group = groups.find(g => g.id === groupId);
                    const action = e.target.dataset.action || e.target.closest('[data-action]')?.dataset.action;

                    if (action === 'visibility') {
                        toggleGroupVisibility(group);
                    } else if (action === 'edit') {
                        openGroupPopup(group);
                    }
                });
            });

            // Annotation click handlers
            groupsContainer.querySelectorAll('.annotation-item').forEach(item => {
                item.addEventListener('click', () => {
                    const id = parseInt(item.dataset.id);
                    selectAnnotation(id);
                });
                item.addEventListener('dblclick', () => {
                    const id = parseInt(item.dataset.id);
                    const ann = annotations.find(a => a.id === id);
                    if (ann) openAnnotationPopupForEdit(ann);
                });
            });
        }

        function renderAnnotationItem(ann) {
            const icons = { point: '📍', line: '📏', polygon: '⬡', surface: '🎨' };
            const entryCount = (ann.entries && ann.entries.length) || 0;
            const entryText = entryCount === 1 ? '1 entry' : `${entryCount} entries`;
            return `
                <div class="annotation-item ${selectedAnnotation === ann.id ? 'selected' : ''}" data-id="${ann.id}">
                    <div class="header">
                        <span class="type-icon">${icons[ann.type] || '📍'}</span>
                        <span class="name">${escapeHtml(ann.name)}</span>
                    </div>
                    <div class="description">${entryText}</div>
                </div>
            `;
        }

        function updateGroupSelect() {
            annGroup.innerHTML = groups.map(g => 
                `<option value="${g.id}">${escapeHtml(g.name)}</option>`
            ).join('');
        }

        // ============ Annotations ============
        function openAnnotationPopup(event, type, points, faceData = null) {
            editingAnnotation = null;
            editingModelInfo = false;
            isAddingEntry = false;
            editingEntryId = null;
            pendingLinks = [];
            
            popupTitle.textContent = `New ${type.charAt(0).toUpperCase() + type.slice(1)}`;
            annName.value = '';
            annDescription.value = '';
            annAuthor.value = getLastAuthor();
            updateGroupSelect();
            updateLinksDisplay();
            btnPopupDelete.style.display = 'none';
            
            // Show name/group fields, new entry form, hide entries container
            document.getElementById('popup-main-fields').style.display = 'block';
            entriesContainer.style.display = 'none';
            newEntryForm.style.display = 'block';

            // Store temp data
            annotationPopup.dataset.type = type;
            annotationPopup.dataset.points = JSON.stringify(points.map(p => ({ x: p.x, y: p.y, z: p.z })));
            
            // Store face data for surface annotations
            if (faceData) {
                annotationPopup.dataset.faceData = JSON.stringify(faceData);
            } else {
                delete annotationPopup.dataset.faceData;
            }

            // For surface annotations, center the popup since double-click position is arbitrary
            if (type === 'surface') {
                resetPopupPosition();
            } else {
                positionPopup(annotationPopup, event.clientX, event.clientY);
            }
            annotationPopup.classList.add('visible');
            annName.focus();
        }

        function openAnnotationPopupForEdit(ann) {
            editingAnnotation = ann;
            editingModelInfo = false;
            isAddingEntry = false;
            editingEntryId = null;
            pendingLinks = [];

            popupTitle.textContent = `Edit ${ann.type.charAt(0).toUpperCase() + ann.type.slice(1)}`;
            annName.value = ann.name;
            updateGroupSelect();
            annGroup.value = ann.groupId;
            btnPopupDelete.style.display = 'block';

            annotationPopup.dataset.type = ann.type;
            annotationPopup.dataset.points = JSON.stringify(ann.points);

            // Show name/group fields, entries container, hide new entry form initially
            document.getElementById('popup-main-fields').style.display = 'block';
            entriesContainer.style.display = 'block';
            newEntryForm.style.display = 'none';
            
            // Render existing entries
            renderEntriesList(ann);

            resetPopupPosition();
            annotationPopup.classList.add('visible');
            annName.focus();
        }
        
        // ============ Model Information ============
        function openModelInfoPopup() {
            editingAnnotation = null;
            editingModelInfo = true;
            isAddingEntry = false;
            editingEntryId = null;
            pendingLinks = [];

            popupTitle.textContent = 'Model Information';
            
            // Hide name/group fields for model info
            document.getElementById('popup-main-fields').style.display = 'none';
            btnPopupDelete.style.display = 'none';

            // Show entries container
            entriesContainer.style.display = 'block';
            
            // Show new entry form if no entries exist, otherwise hide it
            if (modelInfo.entries.length === 0) {
                newEntryForm.style.display = 'block';
                annDescription.value = '';
                annAuthor.value = getLastAuthor();
                updateLinksDisplay();
            } else {
                newEntryForm.style.display = 'none';
            }
            
            // Render existing entries
            renderModelInfoEntriesList();

            resetPopupPosition();
            annotationPopup.classList.add('visible');
        }
        
        function renderModelInfoEntriesList() {
            const entries = modelInfo.entries || [];
            
            if (entries.length === 0) {
                entriesList.innerHTML = '<div style="color: #888; padding: 10px; text-align: center;">No entries yet. Add general information about this model.</div>';
                return;
            }
            
            entriesList.innerHTML = entries.map((entry, index) => {
                const date = new Date(entry.timestamp);
                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                const linksHtml = (entry.links && entry.links.length > 0) ? `
                    <div class="entry-card-links">
                        ${entry.links.map(link => `<a href="${escapeHtml(link)}" target="_blank">🔗 ${escapeHtml(link.split('/').pop() || link)}</a>`).join('')}
                    </div>
                ` : '';
                
                return `
                    <div class="entry-card" data-entry-id="${entry.id}">
                        <div class="entry-card-header">
                            <div class="entry-card-meta">
                                <span class="author">${escapeHtml(entry.author || 'Unknown')}</span> • ${dateStr}
                            </div>
                            <div class="entry-card-actions">
                                <button data-action="edit" data-entry-id="${entry.id}">✏️ Edit</button>
                                <button data-action="delete" data-entry-id="${entry.id}">🗑️</button>
                            </div>
                        </div>
                        <div class="entry-card-description">${escapeHtml(entry.description || '')}</div>
                        ${linksHtml}
                        <div class="entry-edit-form">
                            <textarea data-field="description">${escapeHtml(entry.description || '')}</textarea>
                            <input type="text" data-field="author" value="${escapeHtml(entry.author || '')}" placeholder="Author">
                            <div class="links-section">
                                <label>Links</label>
                                <div class="entry-links-list" data-entry-id="${entry.id}">
                                    ${(entry.links || []).map((link, li) => `
                                        <div class="link-item">
                                            <a href="${escapeHtml(link)}" target="_blank">${escapeHtml(link)}</a>
                                            <button data-link-index="${li}">✕</button>
                                        </div>
                                    `).join('')}
                                </div>
                                <div class="add-link-row">
                                    <input type="text" data-field="new-link" placeholder="https://...">
                                    <button class="btn-save" data-action="add-link">+</button>
                                </div>
                            </div>
                            <div class="entry-edit-buttons">
                                <button class="btn-cancel" data-action="cancel-edit">Cancel</button>
                                <button class="btn-save" data-action="save-edit">Save Entry</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Add event listeners for model info entries
            entriesList.querySelectorAll('.entry-card-actions button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const entryId = parseInt(btn.dataset.entryId);
                    const action = btn.dataset.action;
                    
                    if (action === 'edit') {
                        showConfirm('Are you sure you want to edit this entry instead of adding a new one?', () => {
                            startEditingModelInfoEntry(entryId);
                        });
                    } else if (action === 'delete') {
                        showConfirm('Are you sure you want to delete this entry? This cannot be undone.', () => {
                            deleteModelInfoEntry(entryId);
                        });
                    }
                });
            });
            
            // Entry edit form buttons
            entriesList.querySelectorAll('.entry-edit-form button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const action = btn.dataset.action;
                    const card = btn.closest('.entry-card');
                    const entryId = parseInt(card.dataset.entryId);
                    
                    if (action === 'cancel-edit') {
                        cancelEditingEntry();
                        renderModelInfoEntriesList();
                    } else if (action === 'save-edit') {
                        saveModelInfoEntryEdit(entryId, card);
                    } else if (action === 'add-link') {
                        const input = card.querySelector('[data-field="new-link"]');
                        const link = input.value.trim();
                        if (link) {
                            const entry = modelInfo.entries.find(en => en.id === entryId);
                            if (!entry.links) entry.links = [];
                            entry.links.push(link);
                            input.value = '';
                            renderModelInfoEntriesList();
                            startEditingModelInfoEntry(entryId);
                        }
                    }
                });
            });
            
            // Link delete buttons in edit mode
            entriesList.querySelectorAll('.entry-links-list button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const card = btn.closest('.entry-card');
                    const entryId = parseInt(card.dataset.entryId);
                    const linkIndex = parseInt(btn.dataset.linkIndex);
                    const entry = modelInfo.entries.find(en => en.id === entryId);
                    if (entry && entry.links) {
                        entry.links.splice(linkIndex, 1);
                        renderModelInfoEntriesList();
                        startEditingModelInfoEntry(entryId);
                    }
                });
            });
        }
        
        function startEditingModelInfoEntry(entryId) {
            editingEntryId = entryId;
            entriesList.querySelectorAll('.entry-card').forEach(card => {
                if (parseInt(card.dataset.entryId) === entryId) {
                    card.classList.add('editing');
                } else {
                    card.classList.remove('editing');
                }
            });
        }
        
        function saveModelInfoEntryEdit(entryId, card) {
            const entry = modelInfo.entries.find(en => en.id === entryId);
            if (!entry) return;
            
            const description = card.querySelector('[data-field="description"]').value.trim();
            const author = card.querySelector('[data-field="author"]').value.trim();
            
            entry.description = description;
            entry.author = author;
            saveLastAuthor(author);
            
            editingEntryId = null;
            renderModelInfoEntriesList();
            updateModelInfoDisplay();
            showStatus('Entry updated');
        }
        
        function deleteModelInfoEntry(entryId) {
            modelInfo.entries = modelInfo.entries.filter(e => e.id !== entryId);
            renderModelInfoEntriesList();
            updateModelInfoDisplay();
            showStatus('Entry deleted');
        }
        
        function updateModelInfoDisplay() {
            const entryCount = modelInfo.entries.length;
            if (entryCount === 0) {
                modelInfoSubtitle.textContent = 'No entries yet';
            } else {
                modelInfoSubtitle.textContent = entryCount === 1 ? '1 entry' : `${entryCount} entries`;
            }
        }
        
        function renderEntriesList(ann) {
            const entries = ann.entries || [];
            
            if (entries.length === 0) {
                entriesList.innerHTML = '<div style="color: #888; padding: 10px; text-align: center;">No entries yet</div>';
                return;
            }
            
            entriesList.innerHTML = entries.map((entry, index) => {
                const date = new Date(entry.timestamp);
                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                const linksHtml = (entry.links && entry.links.length > 0) ? `
                    <div class="entry-card-links">
                        ${entry.links.map(link => `<a href="${escapeHtml(link)}" target="_blank">🔗 ${escapeHtml(link.split('/').pop() || link)}</a>`).join('')}
                    </div>
                ` : '';
                
                return `
                    <div class="entry-card" data-entry-id="${entry.id}">
                        <div class="entry-card-header">
                            <div class="entry-card-meta">
                                <span class="author">${escapeHtml(entry.author || 'Unknown')}</span> • ${dateStr}
                            </div>
                            <div class="entry-card-actions">
                                <button data-action="edit" data-entry-id="${entry.id}">✏️ Edit</button>
                                <button data-action="delete" data-entry-id="${entry.id}">🗑️</button>
                            </div>
                        </div>
                        <div class="entry-card-description">${escapeHtml(entry.description || '')}</div>
                        ${linksHtml}
                        <div class="entry-edit-form">
                            <textarea data-field="description">${escapeHtml(entry.description || '')}</textarea>
                            <input type="text" data-field="author" value="${escapeHtml(entry.author || '')}" placeholder="Author">
                            <div class="links-section">
                                <label>Links</label>
                                <div class="entry-links-list" data-entry-id="${entry.id}">
                                    ${(entry.links || []).map((link, li) => `
                                        <div class="link-item">
                                            <a href="${escapeHtml(link)}" target="_blank">${escapeHtml(link)}</a>
                                            <button data-link-index="${li}">✕</button>
                                        </div>
                                    `).join('')}
                                </div>
                                <div class="add-link-row">
                                    <input type="text" data-field="new-link" placeholder="https://...">
                                    <button class="btn-save" data-action="add-link">+</button>
                                </div>
                            </div>
                            <div class="entry-edit-buttons">
                                <button class="btn-cancel" data-action="cancel-edit">Cancel</button>
                                <button class="btn-save" data-action="save-edit">Save Entry</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Add event listeners
            entriesList.querySelectorAll('.entry-card-actions button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const entryId = parseInt(btn.dataset.entryId);
                    const action = btn.dataset.action;
                    
                    if (action === 'edit') {
                        showConfirm('Are you sure you want to edit this entry instead of adding a new one?', () => {
                            startEditingEntry(entryId);
                        });
                    } else if (action === 'delete') {
                        showConfirm('Are you sure you want to delete this entry? This cannot be undone.', () => {
                            deleteEntry(entryId);
                        });
                    }
                });
            });
            
            // Entry edit form buttons
            entriesList.querySelectorAll('.entry-edit-form button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const action = btn.dataset.action;
                    const card = btn.closest('.entry-card');
                    const entryId = parseInt(card.dataset.entryId);
                    
                    if (action === 'cancel-edit') {
                        cancelEditingEntry();
                        renderEntriesList(ann);
                    } else if (action === 'save-edit') {
                        saveEntryEdit(entryId, card);
                    } else if (action === 'add-link') {
                        const input = card.querySelector('[data-field="new-link"]');
                        const link = input.value.trim();
                        if (link) {
                            const entry = ann.entries.find(en => en.id === entryId);
                            if (!entry.links) entry.links = [];
                            entry.links.push(link);
                            input.value = '';
                            renderEntriesList(ann);
                            startEditingEntry(entryId); // Keep in edit mode
                        }
                    }
                });
            });
            
            // Link delete buttons in edit mode
            entriesList.querySelectorAll('.entry-links-list button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const card = btn.closest('.entry-card');
                    const entryId = parseInt(card.dataset.entryId);
                    const linkIndex = parseInt(btn.dataset.linkIndex);
                    const entry = ann.entries.find(en => en.id === entryId);
                    if (entry && entry.links) {
                        entry.links.splice(linkIndex, 1);
                        renderEntriesList(ann);
                        startEditingEntry(entryId);
                    }
                });
            });
        }
        
        function startEditingEntry(entryId) {
            editingEntryId = entryId;
            entriesList.querySelectorAll('.entry-card').forEach(card => {
                if (parseInt(card.dataset.entryId) === entryId) {
                    card.classList.add('editing');
                } else {
                    card.classList.remove('editing');
                }
            });
        }
        
        function cancelEditingEntry() {
            editingEntryId = null;
            entriesList.querySelectorAll('.entry-card').forEach(card => {
                card.classList.remove('editing');
            });
        }
        
        function saveEntryEdit(entryId, card) {
            const entry = editingAnnotation.entries.find(en => en.id === entryId);
            if (!entry) return;
            
            const description = card.querySelector('[data-field="description"]').value.trim();
            const author = card.querySelector('[data-field="author"]').value.trim();
            
            entry.description = description;
            entry.author = author;
            saveLastAuthor(author);
            
            editingEntryId = null;
            renderEntriesList(editingAnnotation);
            showStatus('Entry updated');
        }
        
        function deleteEntry(entryId) {
            if (!editingAnnotation || !editingAnnotation.entries) return;
            
            editingAnnotation.entries = editingAnnotation.entries.filter(e => e.id !== entryId);
            renderEntriesList(editingAnnotation);
            updateGroupsList();
            showStatus('Entry deleted');
        }
        
        function showAddEntryForm() {
            isAddingEntry = true;
            newEntryForm.style.display = 'block';
            annDescription.value = '';
            annAuthor.value = getLastAuthor();
            pendingLinks = [];
            updateLinksDisplay();
            annDescription.focus();
        }
        
        function hideAddEntryForm() {
            isAddingEntry = false;
            newEntryForm.style.display = 'none';
        }
        
        function showConfirm(message, callback) {
            confirmMessage.textContent = message;
            confirmCallback = callback;
            confirmOverlay.classList.add('visible');
        }
        
        function hideConfirm() {
            confirmOverlay.classList.remove('visible');
            confirmCallback = null;
        }

        // ============ Scalebar Functions ============
        function getNiceScaleValue(value) {
            // Find a "nice" round number for the scale
            const magnitude = Math.pow(10, Math.floor(Math.log10(value)));
            const normalized = value / magnitude;
            
            let nice;
            if (normalized < 1.5) nice = 1;
            else if (normalized < 3.5) nice = 2;
            else if (normalized < 7.5) nice = 5;
            else nice = 10;
            
            return nice * magnitude;
        }

        function calculateScalebarParams() {
            // Only works in orthographic mode
            if (!isOrthographic || !currentModel) return null;
            
            const viewportWidth = window.innerWidth - 320;
            
            // Account for the camera's zoom factor!
            // The effective frustum width is the base frustum divided by zoom
            const baseFrustumWidth = orthographicCamera.right - orthographicCamera.left;
            const effectiveFrustumWidth = baseFrustumWidth / orthographicCamera.zoom;
            
            // We want the scalebar to be roughly 1/4 of the viewport width
            const targetScalebarUnits = effectiveFrustumWidth * 0.25;
            const niceValue = getNiceScaleValue(targetScalebarUnits);
            
            // Calculate pixel width for this nice value
            const pixelsPerUnit = viewportWidth / effectiveFrustumWidth;
            const scalebarPixelWidth = niceValue * pixelsPerUnit;
            
            return {
                units: niceValue,
                pixelWidth: scalebarPixelWidth
            };
        }

        function drawScalebarOnCanvas(targetCanvas) {
            const params = calculateScalebarParams();
            if (!params) return;
            
            const ctx = targetCanvas.getContext('2d');
            const canvasWidth = targetCanvas.width;
            const canvasHeight = targetCanvas.height;
            
            // Scale for high DPI displays
            const dpr = window.devicePixelRatio || 1;
            const scalebarWidth = params.pixelWidth * dpr;
            const segmentCount = 4; // Number of black/white segments
            const segmentWidth = scalebarWidth / segmentCount;
            const barHeight = 12 * dpr;
            
            // Position: bottom-left with padding
            const padding = 20 * dpr;
            const x = padding;
            const y = canvasHeight - padding - barHeight - 25 * dpr; // Extra space for text
            
            // Draw background box for better visibility
            const bgPadding = 10 * dpr;
            ctx.fillStyle = 'rgba(4, 29, 49, 0.85)';
            ctx.fillRect(
                x - bgPadding, 
                y - bgPadding, 
                scalebarWidth + bgPadding * 2, 
                barHeight + 45 * dpr + bgPadding
            );
            
            // Draw alternating black and white rectangles
            for (let i = 0; i < segmentCount; i++) {
                ctx.fillStyle = i % 2 === 0 ? '#000000' : '#ffffff';
                ctx.fillRect(x + i * segmentWidth, y, segmentWidth, barHeight);
            }
            
            // Draw border around the entire bar
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1 * dpr;
            ctx.strokeRect(x, y, scalebarWidth, barHeight);
            
            // Draw numbers
            ctx.fillStyle = '#ffffff';
            ctx.font = `${12 * dpr}px Arial`;
            ctx.textAlign = 'center';
            
            // Number at start (0)
            ctx.fillText('0', x, y + barHeight + 15 * dpr);
            
            // Number at end
            const endLabel = params.units >= 1 ? params.units.toString() : params.units.toFixed(2);
            ctx.fillText(endLabel, x + scalebarWidth, y + barHeight + 15 * dpr);
            
            // Units label
            ctx.font = `${10 * dpr}px Arial`;
            ctx.fillStyle = '#aaaaaa';
            ctx.textAlign = 'left';
            ctx.fillText('units (scale depends on model source)', x, y + barHeight + 30 * dpr);
        }

        function showScalebarConfirm(switchCallback, noSwitchCallback) {
            scalebarConfirmCallback = switchCallback;
            scalebarNoSwitchCallback = noSwitchCallback;
            scalebarConfirmOverlay.classList.add('visible');
        }

        function hideScalebarConfirm() {
            scalebarConfirmOverlay.classList.remove('visible');
            scalebarConfirmCallback = null;
            scalebarNoSwitchCallback = null;
        }

        function positionPopup(popup, x, y) {
            popup.style.transform = 'none';
            popup.style.left = `${x + 10}px`;
            popup.style.top = `${y + 10}px`;

            requestAnimationFrame(() => {
                const rect = popup.getBoundingClientRect();
                // Check right edge (account for sidebar)
                if (rect.right > window.innerWidth - 320) {
                    popup.style.left = `${x - rect.width - 10}px`;
                }
                // Check bottom edge
                if (rect.bottom > window.innerHeight) {
                    popup.style.top = `${y - rect.height - 10}px`;
                }
                // Check top edge (account for header)
                const newRect = popup.getBoundingClientRect();
                if (newRect.top < 50) {
                    popup.style.top = '60px';
                }
                // Check left edge
                if (newRect.left < 10) {
                    popup.style.left = '10px';
                }
            });
        }

        function saveAnnotation() {
            // Handle Model Information save
            if (editingModelInfo) {
                if (isAddingEntry || modelInfo.entries.length === 0) {
                    const description = annDescription.value.trim();
                    const author = annAuthor.value.trim();
                    
                    if (description || author) {
                        saveLastAuthor(author);
                        modelInfo.entries.push({
                            id: Date.now(),
                            description,
                            author,
                            timestamp: new Date().toISOString(),
                            links: [...pendingLinks]
                        });
                    }
                }
                
                annotationPopup.classList.remove('visible');
                isAddingEntry = false;
                editingModelInfo = false;
                updateModelInfoDisplay();
                showStatus('Model information saved');
                return;
            }
            
            const type = annotationPopup.dataset.type;
            const points = JSON.parse(annotationPopup.dataset.points);
            const name = annName.value.trim() || 'Unnamed';
            const groupId = parseInt(annGroup.value) || groups[0].id;

            if (editingAnnotation) {
                // Update name and group
                editingAnnotation.name = name;
                editingAnnotation.groupId = groupId;
                
                // If adding a new entry
                if (isAddingEntry) {
                    const description = annDescription.value.trim();
                    const author = annAuthor.value.trim();
                    saveLastAuthor(author);
                    
                    if (!editingAnnotation.entries) editingAnnotation.entries = [];
                    editingAnnotation.entries.push({
                        id: Date.now(),
                        description,
                        author,
                        timestamp: new Date().toISOString(),
                        links: [...pendingLinks]
                    });
                }
            } else {
                // Create new annotation with first entry
                const description = annDescription.value.trim();
                const author = annAuthor.value.trim();
                saveLastAuthor(author);
                
                const newAnnotation = {
                    id: Date.now(),
                    uuid: generateUUID(),
                    type,
                    name,
                    groupId,
                    points,
                    entries: [{
                        id: Date.now() + 1,
                        description,
                        author,
                        timestamp: new Date().toISOString(),
                        links: [...pendingLinks]
                    }]
                };
                
                // Add face data for surface annotations
                if (type === 'surface' && annotationPopup.dataset.faceData) {
                    newAnnotation.faceData = JSON.parse(annotationPopup.dataset.faceData);
                }
                
                // Compute surface-projected edges for lines and polygons
                if (surfaceProjectionEnabled && (type === 'line' || type === 'polygon') && points.length >= 2) {
                    newAnnotation.projectedEdges = computeProjectedEdges(points, type === 'polygon');
                    newAnnotation.surfaceProjection = true;
                }
                
                annotations.push(newAnnotation);
            }

            annotationPopup.classList.remove('visible');
            isAddingEntry = false;
            clearTempDrawing();
            updateGroupsList();
            renderAnnotations();
            showStatus(`Saved: ${name}`);
        }

        function deleteAnnotation() {
            if (!editingAnnotation) return;
            
            showConfirm('Are you sure you want to delete this annotation and all its entries? This cannot be undone.', () => {
                annotations = annotations.filter(a => a.id !== editingAnnotation.id);
                annotationPopup.classList.remove('visible');
                editingAnnotation = null;
                selectedAnnotation = null;
                updateGroupsList();
                renderAnnotations();
                showStatus('Annotation deleted');
            });
        }

        function selectAnnotation(id) {
            selectedAnnotation = id;
            const ann = annotations.find(a => a.id === id);
            
            if (ann && ann.points.length > 0) {
                const center = new THREE.Vector3();
                ann.points.forEach(p => center.add(new THREE.Vector3(p.x, p.y, p.z)));
                center.divideScalar(ann.points.length);
                controls.target.copy(center);
                controls.update();
            }

            updateGroupsList();
        }

        function updateLinksDisplay() {
            annLinks.innerHTML = pendingLinks.map((link, i) => `
                <div class="link-item">
                    <a href="${escapeHtml(link)}" target="_blank">${escapeHtml(link)}</a>
                    <button data-index="${i}">✕</button>
                </div>
            `).join('');

            annLinks.querySelectorAll('button').forEach(btn => {
                btn.addEventListener('click', () => {
                    pendingLinks.splice(parseInt(btn.dataset.index), 1);
                    updateLinksDisplay();
                });
            });
        }

        function addLink() {
            const url = annNewLink.value.trim();
            if (url) {
                pendingLinks.push(url);
                annNewLink.value = '';
                updateLinksDisplay();
            }
        }

        // ============ Render Annotations ============
        function renderAnnotations() {
            // Clear existing
            while (annotationObjects.children.length > 0) {
                annotationObjects.remove(annotationObjects.children[0]);
            }

            const modelSize = currentModel ? 
                new THREE.Box3().setFromObject(currentModel).getSize(new THREE.Vector3()) :
                new THREE.Vector3(1, 1, 1);
            const maxDim = Math.max(modelSize.x, modelSize.y, modelSize.z);
            const labelOffset = Math.pow(maxDim, 0.8) * 0.012; // Offset to clear larger markers

            annotations.forEach(ann => {
                const group = groups.find(g => g.id === ann.groupId);
                if (!group || !group.visible) return;

                const color = new THREE.Color(group.color);
                let labelPosition;

                if (ann.type === 'point') {
                    const geometry = new THREE.SphereGeometry(0.02, 16, 16);
                    const material = new THREE.MeshBasicMaterial({ color });
                    const marker = new THREE.Mesh(geometry, material);
                    marker.position.set(ann.points[0].x, ann.points[0].y, ann.points[0].z);
                    marker.scale.setScalar(Math.pow(maxDim, 0.8) * 0.025 * pointSizeMultiplier);
                    marker.userData.annotationId = ann.id;
                    marker.userData.pointIndex = 0;
                    marker.userData.isAnnotationMarker = true;
                    annotationObjects.add(marker);
                    
                    // Label position slightly above the point
                    labelPosition = new THREE.Vector3(
                        ann.points[0].x,
                        ann.points[0].y + labelOffset,
                        ann.points[0].z
                    );
                } else if (ann.type === 'line' || ann.type === 'polygon') {
                    // Build positions array for Line2
                    const positions = [];
                    
                    if (ann.projectedEdges && ann.surfaceProjection && ann.projectedEdges.length > 0) {
                        // Surface-projected rendering: use pre-computed edge polylines
                        ann.projectedEdges.forEach((edge, edgeIdx) => {
                            const startIdx = (edgeIdx === 0) ? 0 : 1; // Skip duplicate junction points
                            for (let j = startIdx; j < edge.length; j++) {
                                positions.push(edge[j].x, edge[j].y, edge[j].z);
                            }
                        });
                    } else {
                        // Classic straight-line rendering (fallback)
                        const points = ann.points.map(p => new THREE.Vector3(p.x, p.y, p.z));
                        if (ann.type === 'polygon' && points.length > 0) {
                            points.push(points[0].clone());
                        }
                        points.forEach(p => positions.push(p.x, p.y, p.z));
                    }

                    // Create thick line
                    const lineGeometry = new LineGeometry();
                    lineGeometry.setPositions(positions);

                    const lineMaterial = new LineMaterial({
                        color: color,
                        linewidth: 3,
                        resolution: new THREE.Vector2(window.innerWidth - 320, window.innerHeight - 50),
                        polygonOffset: true,
                        polygonOffsetFactor: -4,
                        polygonOffsetUnits: -4
                    });

                    const line = new Line2(lineGeometry, lineMaterial);
                    line.userData.annotationId = ann.id;
                    annotationObjects.add(line);

                    // Points along the line/polygon
                    ann.points.forEach((p, index) => {
                        const geometry = new THREE.SphereGeometry(0.02, 12, 12);
                        const material = new THREE.MeshBasicMaterial({ color });
                        const marker = new THREE.Mesh(geometry, material);
                        marker.position.set(p.x, p.y, p.z);
                        marker.scale.setScalar(Math.pow(maxDim, 0.8) * 0.018 * pointSizeMultiplier);
                        marker.userData.annotationId = ann.id;
                        marker.userData.pointIndex = index;
                        marker.userData.isAnnotationMarker = true;
                        annotationObjects.add(marker);
                    });
                    
                    // Label position: centroid for polygons, first point for lines
                    if (ann.type === 'polygon' && ann.points.length > 0) {
                        const centroid = ann.points.reduce(
                            (acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y, z: acc.z + p.z }),
                            { x: 0, y: 0, z: 0 }
                        );
                        labelPosition = new THREE.Vector3(
                            centroid.x / ann.points.length,
                            centroid.y / ann.points.length + labelOffset,
                            centroid.z / ann.points.length
                        );
                    } else if (ann.points.length > 0) {
                        // For lines, place at first point
                        labelPosition = new THREE.Vector3(
                            ann.points[0].x,
                            ann.points[0].y + labelOffset,
                            ann.points[0].z
                        );
                    }
                } else if (ann.type === 'surface' && ann.faceData) {
                    // Render surface annotation
                    const surfaceMesh = renderSurfaceAnnotation(ann, color);
                    if (surfaceMesh) {
                        surfaceMesh.userData.annotationId = ann.id;
                        annotationObjects.add(surfaceMesh);
                    }
                    
                    // Label position from center point
                    if (ann.points && ann.points.length > 0) {
                        labelPosition = new THREE.Vector3(
                            ann.points[0].x,
                            ann.points[0].y + labelOffset,
                            ann.points[0].z
                        );
                    }
                }
                
                // Add name label if annotation has a name
                if (ann.name && labelPosition) {
                    const label = createScaledTextSprite(ann.name, group.color, labelPosition, 0.8);
                    label.userData.annotationId = ann.id;
                    annotationObjects.add(label);
                }
            });

            updateAnnotationsPanel();
        }

        function renderSurfaceAnnotation(ann, color) {
            if (!ann.faceData || ann.faceData.length === 0) return null;

            // Group faces by mesh index
            const facesByMesh = new Map();
            ann.faceData.forEach(faceId => {
                const [meshIdx, faceIdx] = faceId.split('_');
                if (!facesByMesh.has(meshIdx)) {
                    facesByMesh.set(meshIdx, []);
                }
                facesByMesh.get(meshIdx).push(parseInt(faceIdx));
            });

            // Build combined geometry
            const vertices = [];
            
            facesByMesh.forEach((faceIndices, meshIdx) => {
                const mesh = modelMeshes[parseInt(meshIdx)];
                if (!mesh) return;

                const geometry = mesh.geometry;
                const position = geometry.attributes.position;

                faceIndices.forEach(faceIdx => {
                    let a, b, c;
                    if (geometry.index) {
                        a = geometry.index.getX(faceIdx * 3);
                        b = geometry.index.getX(faceIdx * 3 + 1);
                        c = geometry.index.getX(faceIdx * 3 + 2);
                    } else {
                        a = faceIdx * 3;
                        b = faceIdx * 3 + 1;
                        c = faceIdx * 3 + 2;
                    }

                    const vA = new THREE.Vector3().fromBufferAttribute(position, a);
                    const vB = new THREE.Vector3().fromBufferAttribute(position, b);
                    const vC = new THREE.Vector3().fromBufferAttribute(position, c);

                    // Apply mesh world transform
                    vA.applyMatrix4(mesh.matrixWorld);
                    vB.applyMatrix4(mesh.matrixWorld);
                    vC.applyMatrix4(mesh.matrixWorld);

                    vertices.push(vA.x, vA.y, vA.z);
                    vertices.push(vB.x, vB.y, vB.z);
                    vertices.push(vC.x, vC.y, vC.z);
                });
            });

            if (vertices.length === 0) return null;

            // Create highlight geometry
            const highlightGeometry = new THREE.BufferGeometry();
            highlightGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            highlightGeometry.computeVertexNormals();

            const highlightMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide,
                depthTest: true,
                depthWrite: false,
                polygonOffset: true,
                polygonOffsetFactor: -4,
                polygonOffsetUnits: -4
            });

            const mesh = new THREE.Mesh(highlightGeometry, highlightMaterial);
            mesh.renderOrder = 999; // Render after everything else
            return mesh;
        }

        function updateAnnotationsPanel() {
            // Panel content is now integrated into groups list
            // This function kept for compatibility with calls from other functions
        }

        // ============ Screenshot ============
        function takeScreenshot() {
            if (!isOrthographic) {
                // Show confirmation dialog for perspective mode
                showScalebarConfirm(
                    () => {
                        // User chose to switch to orthographic
                        toggleCamera();
                        setTimeout(() => {
                            captureScreenshot(true);
                        }, 100);
                    },
                    () => {
                        // User chose to continue without scalebar
                        captureScreenshot(false);
                    }
                );
            } else {
                captureScreenshot(true);
            }
        }
        
        function captureScreenshot(includeScalebar) {
            renderer.render(scene, camera);
            
            // Create a copy of the canvas to draw scalebar on
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const ctx = tempCanvas.getContext('2d');
            ctx.drawImage(canvas, 0, 0);
            
            // Draw scalebar if in orthographic mode
            if (includeScalebar && isOrthographic) {
                drawScalebarOnCanvas(tempCanvas);
            }
            
            const dataURL = tempCanvas.toDataURL('image/png');
            
            const link = document.createElement('a');
            link.download = `meshnotes-screenshot-${Date.now()}.png`;
            link.href = dataURL;
            link.click();
            
            showStatus('Screenshot saved');
        }

        // ============ Export/Import ============
        // ============ W3C Web Annotation Export/Import ============
        
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        
        function formatPointsAsSelector(ann) {
            // Create W3C-compliant selector for 3D geometry
            if (ann.type === 'point') {
                return {
                    type: 'PointSelector',
                    refinedBy: {
                        type: 'FragmentSelector',
                        conformsTo: 'https://github.com/IIIF/3d',
                        value: `point=${ann.points[0].x},${ann.points[0].y},${ann.points[0].z}`
                    }
                };
            } else if (ann.type === 'line') {
                const coords = ann.points.map(p => `${p.x},${p.y},${p.z}`).join(';');
                return {
                    type: 'SvgSelector',
                    refinedBy: {
                        type: 'FragmentSelector',
                        conformsTo: 'https://github.com/IIIF/3d',
                        value: `polyline=${coords}`
                    }
                };
            } else if (ann.type === 'polygon') {
                const coords = ann.points.map(p => `${p.x},${p.y},${p.z}`).join(';');
                return {
                    type: 'SvgSelector',
                    refinedBy: {
                        type: 'FragmentSelector',
                        conformsTo: 'https://github.com/IIIF/3d',
                        value: `polygon=${coords}`
                    }
                };
            } else if (ann.type === 'surface' && ann.faceData) {
                return {
                    type: 'FragmentSelector',
                    conformsTo: 'https://github.com/IIIF/3d',
                    value: `faces=${ann.faceData.join(',')}`,
                    refinedBy: ann.points.length > 0 ? {
                        type: 'PointSelector',
                        value: `centroid=${ann.points[0].x},${ann.points[0].y},${ann.points[0].z}`
                    } : undefined
                };
            }
            return null;
        }
        
        function parseSelector(selector, ann) {
            // Parse W3C selector back to internal format
            if (!selector) return;
            
            // Get main selector value - check direct value first, then refinedBy
            // (Surface annotations have value at top level, others have it in refinedBy)
            let fragmentValue = null;
            if (selector.value) {
                fragmentValue = selector.value;
            } else if (selector.refinedBy && selector.refinedBy.value) {
                fragmentValue = selector.refinedBy.value;
            }
            
            if (!fragmentValue) return;
            
            // Parse point=x,y,z
            if (fragmentValue.startsWith('point=')) {
                const coords = fragmentValue.replace('point=', '').split(',').map(Number);
                if (coords.length === 3) {
                    ann.points = [{ x: coords[0], y: coords[1], z: coords[2] }];
                    ann.type = 'point';
                }
            }
            // Parse polyline=x1,y1,z1;x2,y2,z2;...
            else if (fragmentValue.startsWith('polyline=')) {
                const pointsStr = fragmentValue.replace('polyline=', '').split(';');
                ann.points = pointsStr.map(p => {
                    const coords = p.split(',').map(Number);
                    return { x: coords[0], y: coords[1], z: coords[2] };
                });
                ann.type = 'line';
            }
            // Parse polygon=x1,y1,z1;x2,y2,z2;...
            else if (fragmentValue.startsWith('polygon=')) {
                const pointsStr = fragmentValue.replace('polygon=', '').split(';');
                ann.points = pointsStr.map(p => {
                    const coords = p.split(',').map(Number);
                    return { x: coords[0], y: coords[1], z: coords[2] };
                });
                ann.type = 'polygon';
            }
            // Parse faces=0_1,0_2,...
            else if (fragmentValue.startsWith('faces=')) {
                ann.faceData = fragmentValue.replace('faces=', '').split(',');
                ann.type = 'surface';
                ann.points = [];
                // Check for centroid in refinedBy
                if (selector.refinedBy && selector.refinedBy.value && selector.refinedBy.value.startsWith('centroid=')) {
                    const coords = selector.refinedBy.value.replace('centroid=', '').split(',').map(Number);
                    if (coords.length === 3) {
                        ann.points = [{ x: coords[0], y: coords[1], z: coords[2] }];
                    }
                }
            }
            // Parse centroid for surface types
            else if (fragmentValue.startsWith('centroid=')) {
                const coords = fragmentValue.replace('centroid=', '').split(',').map(Number);
                if (coords.length === 3) {
                    ann.points = [{ x: coords[0], y: coords[1], z: coords[2] }];
                }
            }
        }
        
        function convertToW3CAnnotation(ann, group) {
            // Convert internal annotation to W3C Web Annotation format
            const w3cAnn = {
                '@context': 'http://www.w3.org/ns/anno.jsonld',
                type: 'Annotation',
                id: `urn:meshnotes:annotation:${ann.uuid || generateUUID()}`,
                motivation: ann.type === 'surface' ? 'tagging' : 'describing',
                created: ann.entries && ann.entries.length > 0 ? ann.entries[0].timestamp : new Date().toISOString(),
                modified: ann.entries && ann.entries.length > 1 ? ann.entries[ann.entries.length - 1].timestamp : undefined,
                'schema:name': ann.name || 'Unnamed',
                target: {
                    type: 'SpecificResource',
                    source: {
                        id: `urn:meshnotes:model:${modelFileName || 'unknown'}`,
                        type: 'Dataset',
                        format: getModelMimeType()
                    },
                    selector: formatPointsAsSelector(ann)
                }
            };
            
            // Add styleClass for group color
            if (group) {
                w3cAnn.target.styleClass = `group-${group.id}`;
            }
            
            // Convert entries to body array
            if (ann.entries && ann.entries.length > 0) {
                w3cAnn.body = ann.entries.map(entry => {
                    const body = {
                        type: 'TextualBody',
                        value: entry.description || '',
                        format: 'text/plain',
                        language: 'en'
                    };
                    
                    if (entry.author) {
                        body.creator = {
                            type: 'Person',
                            name: entry.author
                        };
                    }
                    
                    if (entry.timestamp) {
                        body.created = entry.timestamp;
                    }
                    
                    // Store links as custom property
                    if (entry.links && entry.links.length > 0) {
                        body['schema:url'] = entry.links;
                    }
                    
                    return body;
                });
            }
            
            // Store internal ID mapping for round-trip
            w3cAnn['meshnotes:internalId'] = ann.id;
            w3cAnn['meshnotes:groupId'] = ann.groupId;
            w3cAnn['meshnotes:annotationType'] = ann.type;
            
            return w3cAnn;
        }
        
        function convertFromW3CAnnotation(w3cAnn, groupIdMap) {
            // Convert W3C Web Annotation back to internal format
            // Extract persistent UUID from W3C id (urn:meshnotes:annotation:{uuid})
            let importedUuid = null;
            if (w3cAnn.id && w3cAnn.id.startsWith('urn:meshnotes:annotation:')) {
                importedUuid = w3cAnn.id.replace('urn:meshnotes:annotation:', '');
            }
            const ann = {
                id: Date.now() + Math.floor(Math.random() * 10000),
                uuid: importedUuid || generateUUID(),
                type: w3cAnn['meshnotes:annotationType'] || 'point',
                name: w3cAnn['schema:name'] || 'Unnamed',
                groupId: null,
                points: [],
                entries: []
            };
            
            // Map group ID
            const origGroupId = w3cAnn['meshnotes:groupId'];
            if (origGroupId && groupIdMap[origGroupId]) {
                ann.groupId = groupIdMap[origGroupId];
            }
            
            // Parse selector to get points/faceData
            if (w3cAnn.target && w3cAnn.target.selector) {
                parseSelector(w3cAnn.target.selector, ann);
            }
            
            // Convert body to entries
            if (w3cAnn.body) {
                const bodies = Array.isArray(w3cAnn.body) ? w3cAnn.body : [w3cAnn.body];
                ann.entries = bodies.map((body, idx) => {
                    const entry = {
                        id: Date.now() + idx + Math.floor(Math.random() * 1000),
                        description: body.value || '',
                        author: body.creator ? body.creator.name : '',
                        timestamp: body.created || w3cAnn.created || new Date().toISOString(),
                        links: body['schema:url'] || []
                    };
                    return entry;
                });
            }
            
            return ann;
        }
        
        function exportAnnotations() {
            // Create W3C Web Annotation Collection
            const collectionId = `urn:meshnotes:collection:${generateUUID()}`;
            
            // Convert groups to stylesheet
            const stylesheet = {
                type: 'CssStylesheet',
                value: groups.map(g => `.group-${g.id} { color: ${g.color}; }`).join('\n')
            };
            
            // Convert all annotations to W3C format
            const w3cAnnotations = annotations.map(ann => {
                const group = groups.find(g => g.id === ann.groupId);
                return convertToW3CAnnotation(ann, group);
            });
            
            // Build the W3C AnnotationCollection
            const collection = {
                '@context': [
                    'http://www.w3.org/ns/anno.jsonld',
                    {
                        'meshnotes': 'https://github.com/NilsSchnorr/MeshNotes#',
                        'schema': 'http://schema.org/'
                    }
                ],
                type: 'AnnotationCollection',
                id: collectionId,
                label: `MeshNotes: ${modelFileName || 'Annotations'}`,
                generator: {
                    type: 'Software',
                    name: 'MeshNotes',
                    'schema:version': '2.0',
                    homepage: 'https://github.com/NilsSchnorr/MeshNotes'
                },
                generated: new Date().toISOString(),
                
                // Target model
                'meshnotes:modelSource': {
                    id: `urn:meshnotes:model:${modelFileName || 'unknown'}`,
                    type: 'Dataset',
                    'schema:name': modelFileName,
                    format: getModelMimeType()
                },
                
                // Stylesheet for group colors
                stylesheet: stylesheet,
                
                // Groups metadata (custom extension)
                'meshnotes:groups': groups.map(g => ({
                    id: g.id,
                    'schema:name': g.name,
                    'schema:color': g.color,
                    'meshnotes:visible': g.visible
                })),
                
                // Model information entries
                'meshnotes:modelInfo': modelInfo.entries.length > 0 ? {
                    type: 'Annotation',
                    motivation: 'describing',
                    'schema:name': 'Model Information',
                    body: modelInfo.entries.map(entry => ({
                        type: 'TextualBody',
                        value: entry.description || '',
                        format: 'text/plain',
                        creator: entry.author ? { type: 'Person', name: entry.author } : undefined,
                        created: entry.timestamp,
                        'schema:url': entry.links && entry.links.length > 0 ? entry.links : undefined
                    }))
                } : undefined,
                
                // Annotations
                total: w3cAnnotations.length,
                first: {
                    type: 'AnnotationPage',
                    items: w3cAnnotations
                }
            };
            
            // Clean up undefined values
            const cleanJSON = JSON.stringify(collection, (key, value) => {
                if (value === undefined) return undefined;
                return value;
            }, 2);
            
            const blob = new Blob([cleanJSON], { type: 'application/ld+json' });
            const url = URL.createObjectURL(blob);

            const link = document.createElement('a');
            link.download = `meshnotes-${modelFileName || 'export'}-${Date.now()}.jsonld`;
            link.href = url;
            link.click();

            URL.revokeObjectURL(url);
            showStatus('W3C annotations exported');
        }

        // ============ PDF Export ============
        async function exportPdfReport() {
            if (!currentModel) {
                showStatus('No model loaded');
                return;
            }
            
            if (!isOrthographic) {
                // Show confirmation dialog for perspective mode
                showScalebarConfirm(
                    () => {
                        // User chose to switch to orthographic
                        toggleCamera();
                        setTimeout(() => {
                            doExportPdfReport(true);
                        }, 100);
                    },
                    () => {
                        // User chose to continue without scalebar
                        doExportPdfReport(false);
                    }
                );
            } else {
                doExportPdfReport(true);
            }
        }
        
        async function doExportPdfReport(includeScalebar) {
            // Store original light settings and temporarily enable camera-linked lighting
            // This ensures consistent lighting across all annotation screenshots
            const originalLightMode = lightFollowsCamera;
            lightFollowsCamera = true;

            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF('p', 'mm', 'a4');
            const pageWidth = 210;
            const pageHeight = 297;
            const margin = 15;
            const contentWidth = pageWidth - (margin * 2);

            // Store original camera state
            const originalCamPos = camera.position.clone();
            const originalTarget = controls.target.clone();
            const originalUp = camera.up.clone();
            const originalZoom = camera.zoom;
            const originalFrustum = isOrthographic ? {
                left: camera.left, right: camera.right,
                top: camera.top, bottom: camera.bottom
            } : null;

            showStatus('Generating PDF report...');
            
            // Ensure all annotations (including surfaces) are rendered
            renderAnnotations();
            await delay(100);

            // Get visible groups and their annotations
            const visibleGroups = groups.filter(g => g.visible);
            const visibleAnnotations = annotations.filter(ann => {
                const group = groups.find(g => g.id === ann.groupId);
                return group && group.visible;
            });

            // Build table of contents data
            const tocData = [];
            let pageNum = 4; // Start after title page, axis views, and TOC

            visibleGroups.forEach(group => {
                const groupAnns = visibleAnnotations.filter(a => a.groupId === group.id);
                if (groupAnns.length > 0) {
                    tocData.push({ type: 'group', name: group.name, page: pageNum });
                    // First annotation shares page with group header
                    groupAnns.forEach((ann, idx) => {
                        if (idx === 0) {
                            tocData.push({ type: 'annotation', name: ann.name, page: pageNum });
                        } else {
                            tocData.push({ type: 'annotation', name: ann.name, page: pageNum });
                        }
                        pageNum++;
                    });
                }
            });

            // ===== TITLE PAGE =====
            // Add title
            pdf.setFontSize(24);
            pdf.setTextColor(170, 129, 1); // Gold
            pdf.text('MeshNotes Report', pageWidth / 2, 25, { align: 'center' });

            // Model filename
            pdf.setFontSize(14);
            pdf.setTextColor(60, 60, 60);
            pdf.text(modelFileName || 'Untitled Model', pageWidth / 2, 35, { align: 'center' });

            // Date
            pdf.setFontSize(10);
            pdf.setTextColor(120, 120, 120);
            const dateStr = new Date().toLocaleDateString() + ' ' + new Date().toLocaleTimeString();
            pdf.text(`Generated: ${dateStr}`, pageWidth / 2, 42, { align: 'center' });

            // Overview screenshot
            await delay(100);
            renderer.render(scene, camera);
            
            // Create canvas with scalebar if applicable
            let overviewImg;
            if (includeScalebar && isOrthographic) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const ctx = tempCanvas.getContext('2d');
                ctx.drawImage(canvas, 0, 0);
                drawScalebarOnCanvas(tempCanvas);
                overviewImg = tempCanvas.toDataURL('image/jpeg', 0.9);
            } else {
                overviewImg = renderer.domElement.toDataURL('image/jpeg', 0.9);
            }
            // Calculate height based on canvas aspect ratio
            const canvasAspect = canvas.width / canvas.height;
            const imgHeight = contentWidth / canvasAspect;
            pdf.addImage(overviewImg, 'JPEG', margin, 50, contentWidth, imgHeight);

            // Model Information
            let yPos = 50 + imgHeight + 10;
            pdf.setFontSize(14);
            pdf.setTextColor(170, 129, 1);
            pdf.text('Model Information', margin, yPos);
            yPos += 8;

            if (modelInfo.entries.length === 0) {
                pdf.setFontSize(10);
                pdf.setTextColor(120, 120, 120);
                pdf.text('No model information entries.', margin, yPos);
            } else {
                modelInfo.entries.forEach(entry => {
                    if (yPos > pageHeight - 40) {
                        pdf.addPage();
                        yPos = margin;
                    }

                    // Author and date
                    pdf.setFontSize(9);
                    pdf.setTextColor(170, 129, 1);
                    const entryDate = new Date(entry.timestamp);
                    const entryDateStr = entryDate.toLocaleDateString() + ' ' + entryDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                    pdf.text(`${entry.author || 'Unknown'} • ${entryDateStr}`, margin, yPos);
                    yPos += 5;

                    // Description
                    pdf.setFontSize(10);
                    pdf.setTextColor(60, 60, 60);
                    const descLines = pdf.splitTextToSize(entry.description || '', contentWidth);
                    pdf.text(descLines, margin, yPos);
                    yPos += descLines.length * 5 + 3;

                    // Links
                    if (entry.links && entry.links.length > 0) {
                        pdf.setFontSize(8);
                        pdf.setTextColor(100, 100, 200);
                        entry.links.forEach(link => {
                            pdf.textWithLink(link, margin, yPos, { url: link });
                            yPos += 4;
                        });
                    }
                    yPos += 5;
                });
            }

            // Summary stats
            yPos += 5;
            if (yPos > pageHeight - 30) {
                pdf.addPage();
                yPos = margin;
            }
            pdf.setFontSize(10);
            pdf.setTextColor(100, 100, 100);
            pdf.text(`Total: ${visibleGroups.length} groups, ${visibleAnnotations.length} annotations`, margin, yPos);

            // ===== AXIS VIEWS PAGE (unfolded cube) =====
            pdf.addPage();
            pdf.setFontSize(18);
            pdf.setTextColor(170, 129, 1);
            pdf.text('Axis Views', margin, 20);
            pdf.setFontSize(10);
            pdf.setTextColor(120, 120, 120);
            pdf.text('Unfolded cube \u2014 six orthogonal views of the model', margin, 28);

            // Calculate model bounds for axis views
            const axisBox = new THREE.Box3().setFromObject(currentModel);
            const axisSize = axisBox.getSize(new THREE.Vector3());
            const axisMaxDim = Math.max(axisSize.x, axisSize.y, axisSize.z);
            const axisDist = axisMaxDim * 1.8;
            const axisTarget = new THREE.Vector3(0, 0, 0);

            // 6 views in unfolded cube cross layout:
            //            [Top]
            // [Left] [Front] [Right] [Back]
            //           [Bottom]
            const cellSize = 42;
            const cellGap = 3;
            const gridStartY = 35;

            const axisViews = [
                { name: 'Top',    col: 1, row: 0, dir: new THREE.Vector3(0, 1, 0),  up: new THREE.Vector3(0, 0, -1) },
                { name: 'Left',   col: 0, row: 1, dir: new THREE.Vector3(-1, 0, 0), up: new THREE.Vector3(0, 1, 0) },
                { name: 'Front',  col: 1, row: 1, dir: new THREE.Vector3(0, 0, 1),  up: new THREE.Vector3(0, 1, 0) },
                { name: 'Right',  col: 2, row: 1, dir: new THREE.Vector3(1, 0, 0),  up: new THREE.Vector3(0, 1, 0) },
                { name: 'Back',   col: 3, row: 1, dir: new THREE.Vector3(0, 0, -1), up: new THREE.Vector3(0, 1, 0) },
                { name: 'Bottom', col: 1, row: 2, dir: new THREE.Vector3(0, -1, 0), up: new THREE.Vector3(0, 0, 1) },
            ];

            for (const axView of axisViews) {
                // Position camera along axis (manual setup, bypass OrbitControls)
                camera.position.copy(axisTarget).addScaledVector(axView.dir, axisDist);
                camera.up.copy(axView.up);
                camera.lookAt(axisTarget);

                // For orthographic camera, adjust frustum to fit model
                if (isOrthographic) {
                    const aspect = canvas.width / canvas.height;
                    const frustumHalf = axisMaxDim * 0.75;
                    camera.left = -frustumHalf * aspect;
                    camera.right = frustumHalf * aspect;
                    camera.top = frustumHalf;
                    camera.bottom = -frustumHalf;
                    camera.updateProjectionMatrix();
                }

                renderer.clear();
                renderer.render(scene, camera);
                await delay(50);
                renderer.render(scene, camera);

                // Crop center square from canvas for cube face
                const cropCanvas = document.createElement('canvas');
                const cropSize = Math.min(canvas.width, canvas.height);
                cropCanvas.width = cropSize;
                cropCanvas.height = cropSize;
                const cropCtx = cropCanvas.getContext('2d');
                const offsetX = (canvas.width - cropSize) / 2;
                const offsetY = (canvas.height - cropSize) / 2;
                cropCtx.drawImage(canvas, offsetX, offsetY, cropSize, cropSize, 0, 0, cropSize, cropSize);

                // Add scalebar if applicable
                if (includeScalebar && isOrthographic) {
                    drawScalebarOnCanvas(cropCanvas);
                }

                const axImg = cropCanvas.toDataURL('image/jpeg', 0.9);

                const cellX = margin + axView.col * (cellSize + cellGap);
                const cellY = gridStartY + axView.row * (cellSize + cellGap);

                // Light border around each view
                pdf.setDrawColor(180, 180, 180);
                pdf.setLineWidth(0.3);
                pdf.rect(cellX, cellY, cellSize, cellSize);

                pdf.addImage(axImg, 'JPEG', cellX, cellY, cellSize, cellSize);

                // Label below image
                pdf.setFontSize(8);
                pdf.setTextColor(120, 120, 120);
                pdf.text(axView.name, cellX + cellSize / 2, cellY + cellSize + 4, { align: 'center' });
            }

            // Restore camera fully
            camera.up.copy(originalUp);
            camera.position.copy(originalCamPos);
            controls.target.copy(originalTarget);
            if (isOrthographic && originalFrustum) {
                camera.left = originalFrustum.left;
                camera.right = originalFrustum.right;
                camera.top = originalFrustum.top;
                camera.bottom = originalFrustum.bottom;
                camera.zoom = originalZoom;
                camera.updateProjectionMatrix();
            }
            controls.update();

            // ===== TABLE OF CONTENTS =====
            pdf.addPage();
            pdf.setFontSize(18);
            pdf.setTextColor(170, 129, 1);
            pdf.text('Table of Contents', margin, 20);

            yPos = 35;
            pdf.setFontSize(10);

            tocData.forEach(item => {
                if (yPos > pageHeight - 20) {
                    pdf.addPage();
                    yPos = 20;
                }

                if (item.type === 'group') {
                    pdf.setTextColor(170, 129, 1);
                    pdf.setFont(undefined, 'bold');
                    pdf.text(item.name, margin, yPos);
                    pdf.setTextColor(100, 100, 100);
                    pdf.text(String(item.page), pageWidth - margin, yPos, { align: 'right' });
                    yPos += 7;
                } else {
                    pdf.setTextColor(60, 60, 60);
                    pdf.setFont(undefined, 'normal');
                    pdf.text('   ' + item.name, margin, yPos);
                    pdf.setTextColor(100, 100, 100);
                    pdf.text(String(item.page), pageWidth - margin, yPos, { align: 'right' });
                    yPos += 6;
                }
            });

            // ===== ANNOTATION PAGES =====
            for (const group of visibleGroups) {
                const groupAnns = visibleAnnotations.filter(a => a.groupId === group.id);
                if (groupAnns.length === 0) continue;

                // Annotations in this group
                for (let annIdx = 0; annIdx < groupAnns.length; annIdx++) {
                    const ann = groupAnns[annIdx];
                    pdf.addPage();

                    // For first annotation, add group header
                    let contentStartY = 32;
                    if (annIdx === 0) {
                        // Group header bar
                        pdf.setFillColor(10, 53, 89); // Dark blue
                        pdf.rect(0, 0, pageWidth, 25, 'F');

                        // Color indicator
                        const rgb = hexToRgb(group.color);
                        pdf.setFillColor(rgb.r, rgb.g, rgb.b);
                        pdf.rect(margin, 8, 8, 8, 'F');

                        pdf.setFontSize(14);
                        pdf.setTextColor(255, 255, 255);
                        pdf.text(group.name, margin + 12, 14);

                        pdf.setFontSize(10);
                        pdf.setTextColor(200, 200, 200);
                        pdf.text(`${groupAnns.length} annotation${groupAnns.length !== 1 ? 's' : ''}`, margin + 12, 21);
                        
                        contentStartY = 32;
                    } else {
                        // Regular annotation header bar (colored by group)
                        const headerRgb = hexToRgb(group.color);
                        pdf.setFillColor(headerRgb.r, headerRgb.g, headerRgb.b);
                        pdf.rect(0, 0, pageWidth, 12, 'F');

                        pdf.setFontSize(10);
                        pdf.setTextColor(255, 255, 255);
                        pdf.text(group.name, margin, 8);
                        
                        contentStartY = 22;
                    }

                    // Calculate annotation center and bounding box
                    const center = new THREE.Vector3();
                    const annPoints = ann.points.map(p => new THREE.Vector3(p.x, p.y, p.z));
                    annPoints.forEach(p => center.add(p));
                    center.divideScalar(annPoints.length);

                    // Calculate annotation extent (bounding box)
                    let annExtent = 0;
                    if (annPoints.length > 1) {
                        const annBox = new THREE.Box3().setFromPoints(annPoints);
                        const annSize = annBox.getSize(new THREE.Vector3());
                        annExtent = Math.max(annSize.x, annSize.y, annSize.z);
                    }

                    // Get model size for reference
                    const box = new THREE.Box3().setFromObject(currentModel);
                    const modelSize = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(modelSize.x, modelSize.y, modelSize.z);

                    // Calculate zoom distance - close enough to see annotation clearly
                    // Use annotation extent if available, otherwise use a fraction of model size
                    const baseDistance = annExtent > 0 ? annExtent * 2 : maxDim * 0.15;
                    const distance = Math.max(baseDistance, maxDim * 0.08); // Minimum distance

                    // Position camera from top-down angle (about 60 degrees from horizontal)
                    // This gives a good view of the annotation on the surface
                    const angle = Math.PI / 3; // 60 degrees
                    const horizontalOffset = distance * Math.cos(angle);
                    const verticalOffset = distance * Math.sin(angle);

                    // Use a consistent horizontal direction (towards positive X and Z)
                    const horizontalDir = new THREE.Vector3(1, 0, 1).normalize();
                    
                    camera.position.set(
                        center.x + horizontalDir.x * horizontalOffset,
                        center.y + verticalOffset,
                        center.z + horizontalDir.z * horizontalOffset
                    );
                    controls.target.copy(center);
                    camera.lookAt(center);

                    // For orthographic camera, adjust frustum to fit annotation view
                    if (isOrthographic) {
                        const aspect = canvas.width / canvas.height;
                        const frustumHalf = distance * 0.8;
                        camera.left = -frustumHalf * aspect;
                        camera.right = frustumHalf * aspect;
                        camera.top = frustumHalf;
                        camera.bottom = -frustumHalf;
                        camera.zoom = 1;
                        camera.updateProjectionMatrix();
                    }

                    controls.update();

                    // Temporarily enlarge markers for this annotation
                    const originalScales = [];
                    annotationObjects.children.forEach(obj => {
                        if (obj.userData.annotationId === ann.id && obj.isMesh) {
                            originalScales.push({ obj, scale: obj.scale.clone() });
                            // Only scale point/vertex markers, not surface meshes
                            if (obj.geometry.type === 'SphereGeometry') {
                                obj.scale.multiplyScalar(2.5); // Make markers 2.5x larger
                            }
                        }
                    });

                    // For surface annotations, temporarily increase opacity for visibility
                    let originalOpacity = null;
                    if (ann.type === 'surface') {
                        annotationObjects.children.forEach(obj => {
                            if (obj.userData.annotationId === ann.id && obj.isMesh && obj.material) {
                                originalOpacity = obj.material.opacity;
                                obj.material.opacity = 0.75; // More visible for screenshot
                                obj.material.needsUpdate = true;
                            }
                        });
                    }

                    // Force clear and multiple render passes to ensure surface is captured
                    renderer.clear();
                    renderer.render(scene, camera);
                    await delay(50);
                    renderer.render(scene, camera);

                    // Capture screenshot with scalebar if applicable
                    let screenshot;
                    if (includeScalebar && isOrthographic) {
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = canvas.width;
                        tempCanvas.height = canvas.height;
                        const ctx = tempCanvas.getContext('2d');
                        ctx.drawImage(canvas, 0, 0);
                        drawScalebarOnCanvas(tempCanvas);
                        screenshot = tempCanvas.toDataURL('image/jpeg', 0.9);
                    } else {
                        screenshot = renderer.domElement.toDataURL('image/jpeg', 0.9);
                    }

                    // Restore original marker scales
                    originalScales.forEach(({ obj, scale }) => {
                        obj.scale.copy(scale);
                    });
                    
                    // Restore original surface opacity
                    if (ann.type === 'surface' && originalOpacity !== null) {
                        annotationObjects.children.forEach(obj => {
                            if (obj.userData.annotationId === ann.id && obj.isMesh && obj.material) {
                                obj.material.opacity = originalOpacity;
                                obj.material.needsUpdate = true;
                            }
                        });
                    }

                    // Annotation name
                    pdf.setFontSize(16);
                    pdf.setTextColor(60, 60, 60);
                    pdf.text(ann.name || 'Unnamed', margin, contentStartY);

                    // Type badge
                    pdf.setFontSize(9);
                    pdf.setTextColor(150, 150, 150);
                    const typeLabels = { point: 'Point', line: 'Line', polygon: 'Polygon', surface: 'Surface' };
                    pdf.text(typeLabels[ann.type] || ann.type, margin, contentStartY + 6);

                    // Screenshot - calculate height based on canvas aspect ratio
                    const canvasAspect = canvas.width / canvas.height;
                    const screenshotHeight = contentWidth / canvasAspect;
                    const screenshotY = contentStartY + 10;
                    pdf.addImage(screenshot, 'JPEG', margin, screenshotY, contentWidth, screenshotHeight);

                    // Coordinates (subtle, right under screenshot)
                    pdf.setFontSize(7);
                    pdf.setTextColor(150, 150, 150);
                    const coordStrings = ann.points.map((p, i) => 
                        `P${i + 1}: (${p.x.toFixed(2)}, ${p.y.toFixed(2)}, ${p.z.toFixed(2)})`
                    );
                    const coordLine = coordStrings.join('  •  ');
                    // Split into multiple lines if too long
                    const coordLines = pdf.splitTextToSize(coordLine, contentWidth);
                    pdf.text(coordLines, margin, screenshotY + screenshotHeight + 4);
                    const coordHeight = coordLines.length * 3;

                    // Entries
                    yPos = screenshotY + screenshotHeight + 6 + coordHeight;
                    const entries = ann.entries || [];

                    if (entries.length === 0) {
                        pdf.setFontSize(10);
                        pdf.setTextColor(150, 150, 150);
                        pdf.text('No entries.', margin, yPos);
                    } else {
                        entries.forEach((entry, idx) => {
                            if (yPos > pageHeight - 35) {
                                pdf.addPage();
                                yPos = margin;
                            }

                            // Entry header
                            pdf.setFontSize(9);
                            pdf.setTextColor(170, 129, 1);
                            const entryDate = new Date(entry.timestamp);
                            const entryDateStr = entryDate.toLocaleDateString() + ' ' + entryDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                            pdf.text(`${entry.author || 'Unknown'} • ${entryDateStr}`, margin, yPos);
                            yPos += 5;

                            // Description
                            pdf.setFontSize(10);
                            pdf.setTextColor(60, 60, 60);
                            if (entry.description) {
                                const descLines = pdf.splitTextToSize(entry.description, contentWidth);
                                pdf.text(descLines, margin, yPos);
                                yPos += descLines.length * 5;
                            }

                            // Links
                            if (entry.links && entry.links.length > 0) {
                                yPos += 2;
                                pdf.setFontSize(8);
                                pdf.setTextColor(100, 100, 200);
                                entry.links.forEach(link => {
                                    if (yPos > pageHeight - 15) {
                                        pdf.addPage();
                                        yPos = margin;
                                    }
                                    const displayLink = link.length > 60 ? link.substring(0, 57) + '...' : link;
                                    pdf.textWithLink('🔗 ' + displayLink, margin, yPos, { url: link });
                                    yPos += 4;
                                });
                            }

                            yPos += 6;
                        });
                    }
                }
            }

            // Restore camera position and projection
            camera.up.set(0, 1, 0);
            camera.position.copy(originalCamPos);
            controls.target.copy(originalTarget);
            if (isOrthographic && originalFrustum) {
                camera.left = originalFrustum.left;
                camera.right = originalFrustum.right;
                camera.top = originalFrustum.top;
                camera.bottom = originalFrustum.bottom;
                camera.zoom = originalZoom;
                camera.updateProjectionMatrix();
            }
            controls.update();
            
            // Restore original light mode
            lightFollowsCamera = originalLightMode;
            if (!lightFollowsCamera) {
                updateFixedLightDirection();
            }
            
            // Re-render annotations to ensure normal marker sizes
            renderAnnotations();
            renderer.render(scene, camera);

            // Save PDF
            pdf.save(`meshnotes-report-${modelFileName || 'export'}-${Date.now()}.pdf`);
            showStatus('PDF report exported');
        }

        function getModelMimeType() {
            if (!modelFileName) return 'model/gltf-binary';
            const ext = modelFileName.toLowerCase().split('.').pop();
            if (ext === 'obj') return 'model/obj';
            if (ext === 'ply') return 'model/ply';
            return 'model/gltf-binary';
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 200, g: 200, b: 200 };
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // ============ Download Manual as PDF ============
        function downloadManualAsPdf() {
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF('p', 'mm', 'a4');
            const pageWidth = 210;
            const pageHeight = 297;
            const margin = 20;
            const contentWidth = pageWidth - (margin * 2);
            const lineHeight = 6;
            const headerLineHeight = 8;
            
            let yPos = margin;
            
            // ===== TITLE PAGE =====
            pdf.setFontSize(28);
            pdf.setTextColor(170, 129, 1); // Gold color
            pdf.text('MeshNotes', pageWidth / 2, 50, { align: 'center' });
            
            pdf.setFontSize(20);
            pdf.setTextColor(60, 60, 60);
            pdf.text('User Manual', pageWidth / 2, 65, { align: 'center' });
            
            // Date
            pdf.setFontSize(11);
            pdf.setTextColor(120, 120, 120);
            const dateStr = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
            pdf.text(`Generated: ${dateStr}`, pageWidth / 2, 80, { align: 'center' });
            
            // Subtitle/description
            pdf.setFontSize(11);
            pdf.setTextColor(80, 80, 80);
            const subtitle = 'A browser-based tool for annotating 3D models with points, lines, polygons, and surfaces, designed for cultural heritage documentation.';
            const subtitleLines = pdf.splitTextToSize(subtitle, contentWidth - 20);
            pdf.text(subtitleLines, pageWidth / 2, 100, { align: 'center' });
            
            // Website
            pdf.setFontSize(10);
            pdf.setTextColor(170, 129, 1);
            pdf.textWithLink('github.com/NilsSchnorr/MeshNotes', pageWidth / 2, 130, { 
                align: 'center', 
                url: 'https://github.com/NilsSchnorr/MeshNotes' 
            });
            
            // ===== EXTRACT MANUAL CONTENT =====
            const manualItems = document.querySelectorAll('#about-modal-content .manual-item');
            const manualContent = [];
            
            manualItems.forEach(item => {
                const headerEl = item.querySelector('.manual-item-header');
                const contentEl = item.querySelector('.manual-item-content');
                
                if (headerEl && contentEl) {
                    // Get title text (without the toggle icon)
                    let title = headerEl.textContent.trim();
                    // Remove the toggle icon character at the end
                    title = title.replace(/[\u25B6\u25BC]$/, '').trim();
                    
                    // Get content HTML and extract text
                    // Clone the content to process it
                    const contentClone = contentEl.cloneNode(true);
                    
                    // Extract paragraphs and lists
                    const paragraphs = [];
                    const children = contentClone.querySelectorAll('p, .limitation-note');
                    
                    if (children.length > 0) {
                        children.forEach(child => {
                            // Check if it's a limitation note
                            if (child.classList && child.classList.contains('limitation-note')) {
                                paragraphs.push({ type: 'note', text: child.textContent.trim() });
                            } else {
                                paragraphs.push({ type: 'paragraph', text: child.textContent.trim() });
                            }
                        });
                    } else {
                        // Fallback: just get all text
                        paragraphs.push({ type: 'paragraph', text: contentEl.textContent.trim() });
                    }
                    
                    manualContent.push({ title, paragraphs });
                }
            });
            
            // ===== ADD CONTENT PAGES =====
            pdf.addPage();
            yPos = margin;
            
            // Table of Contents
            pdf.setFontSize(18);
            pdf.setTextColor(170, 129, 1);
            pdf.text('Table of Contents', margin, yPos);
            yPos += 12;
            
            // List all sections in TOC
            pdf.setFontSize(11);
            pdf.setTextColor(60, 60, 60);
            manualContent.forEach((section, index) => {
                if (yPos > pageHeight - margin) {
                    pdf.addPage();
                    yPos = margin;
                }
                pdf.text(`${index + 1}. ${section.title}`, margin + 5, yPos);
                yPos += 7;
            });
            
            // ===== MANUAL SECTIONS =====
            manualContent.forEach((section, index) => {
                // Always start each section on a new position with some space
                // Check if we need a new page
                if (yPos > pageHeight - 60) {
                    pdf.addPage();
                    yPos = margin;
                } else {
                    yPos += 10; // Add spacing between sections
                }
                
                // Section header
                pdf.setFontSize(14);
                pdf.setTextColor(170, 129, 1);
                pdf.setFont(undefined, 'bold');
                pdf.text(`${index + 1}. ${section.title}`, margin, yPos);
                yPos += headerLineHeight + 2;
                
                // Underline
                pdf.setDrawColor(170, 129, 1);
                pdf.setLineWidth(0.3);
                pdf.line(margin, yPos - 4, margin + contentWidth, yPos - 4);
                yPos += 2;
                
                // Section content
                pdf.setFont(undefined, 'normal');
                pdf.setFontSize(10);
                
                section.paragraphs.forEach(para => {
                    if (yPos > pageHeight - margin - 10) {
                        pdf.addPage();
                        yPos = margin;
                    }
                    
                    if (para.type === 'note') {
                        // Draw note box
                        pdf.setFillColor(255, 248, 230); // Light yellow background
                        pdf.setDrawColor(232, 163, 60); // Orange border
                        
                        const noteLines = pdf.splitTextToSize(para.text, contentWidth - 10);
                        const noteHeight = noteLines.length * 5 + 8;
                        
                        // Check if note fits on page
                        if (yPos + noteHeight > pageHeight - margin) {
                            pdf.addPage();
                            yPos = margin;
                        }
                        
                        pdf.roundedRect(margin, yPos - 2, contentWidth, noteHeight, 2, 2, 'FD');
                        
                        pdf.setTextColor(100, 80, 40);
                        pdf.text(noteLines, margin + 5, yPos + 4);
                        yPos += noteHeight + 4;
                    } else {
                        pdf.setTextColor(60, 60, 60);
                        const textLines = pdf.splitTextToSize(para.text, contentWidth);
                        
                        textLines.forEach(line => {
                            if (yPos > pageHeight - margin) {
                                pdf.addPage();
                                yPos = margin;
                            }
                            pdf.text(line, margin, yPos);
                            yPos += 5;
                        });
                        yPos += 3; // Extra space between paragraphs
                    }
                });
            });
            
            // ===== FOOTER ON EACH PAGE =====
            const pageCount = pdf.internal.getNumberOfPages();
            pdf.setFontSize(8);
            pdf.setTextColor(150, 150, 150);
            
            for (let i = 1; i <= pageCount; i++) {
                pdf.setPage(i);
                pdf.text(
                    `MeshNotes Manual - Page ${i} of ${pageCount}`,
                    pageWidth / 2,
                    pageHeight - 10,
                    { align: 'center' }
                );
            }
            
            // Save PDF
            pdf.save(`MeshNotes-Manual-${new Date().toISOString().split('T')[0]}.pdf`);
        }

        function importAnnotations(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Check if this is W3C format (has @context and type: AnnotationCollection)
                    if (data['@context'] && data.type === 'AnnotationCollection') {
                        importW3CAnnotations(data);
                    }
                    // Legacy format support (old MeshNotes format)
                    else if (data.groups && data.annotations) {
                        importLegacyAnnotations(data);
                    }
                    else {
                        showStatus('Invalid annotation file format');
                    }
                } catch (error) {
                    console.error('Import error:', error);
                    showStatus('Error importing file');
                }
            };
            reader.readAsText(file);
        }
        
        function importW3CAnnotations(data) {
            // Import W3C Web Annotation Collection format
            const groupIdMap = {};
            
            // Import model info if present
            if (data['meshnotes:modelInfo'] && data['meshnotes:modelInfo'].body) {
                const bodies = Array.isArray(data['meshnotes:modelInfo'].body) 
                    ? data['meshnotes:modelInfo'].body 
                    : [data['meshnotes:modelInfo'].body];
                    
                bodies.forEach((body, idx) => {
                    modelInfo.entries.push({
                        id: Date.now() + idx + Math.floor(Math.random() * 1000),
                        description: body.value || '',
                        author: body.creator ? body.creator.name : '',
                        timestamp: body.created || new Date().toISOString(),
                        links: body['schema:url'] || []
                    });
                });
                updateModelInfoDisplay();
            }
            
            // Import groups
            if (data['meshnotes:groups']) {
                data['meshnotes:groups'].forEach(importedGroup => {
                    const groupName = importedGroup['schema:name'] || importedGroup.name || 'Imported Group';
                    const existing = groups.find(g => g.name === groupName);
                    
                    if (!existing) {
                        const newGroupId = Date.now() + Math.floor(Math.random() * 10000);
                        const newGroup = {
                            id: newGroupId,
                            name: groupName,
                            color: importedGroup['schema:color'] || importedGroup.color || '#4CAF50',
                            visible: importedGroup['meshnotes:visible'] !== false
                        };
                        groupIdMap[importedGroup.id] = newGroupId;
                        groups.push(newGroup);
                    } else {
                        groupIdMap[importedGroup.id] = existing.id;
                    }
                });
            }
            
            // Import annotations from first page
            let importedCount = 0;
            if (data.first && data.first.items) {
                data.first.items.forEach(w3cAnn => {
                    const ann = convertFromW3CAnnotation(w3cAnn, groupIdMap);
                    
                    // If no group assigned, use default
                    if (!ann.groupId) {
                        if (groups.length === 0) {
                            groups.push({ id: Date.now(), name: 'Default', color: '#4CAF50', visible: true });
                        }
                        ann.groupId = groups[0].id;
                    }
                    
                    annotations.push(ann);
                    importedCount++;
                });
            }
            
            // Re-project imported annotations onto current model surface
            reprojectAllAnnotations();
            
            updateGroupsList();
            renderAnnotations();
            showStatus(`Imported ${importedCount} W3C annotations`);
        }
        
        function importLegacyAnnotations(data) {
            // Import legacy MeshNotes format (for backward compatibility)
            console.warn('Importing legacy format - consider re-exporting to W3C format');
            
            // Import model info if present
            if (data.modelInfo && data.modelInfo.entries) {
                data.modelInfo.entries.forEach(entry => {
                    modelInfo.entries.push({
                        ...entry,
                        id: Date.now() + Math.floor(Math.random() * 10000)
                    });
                });
                updateModelInfoDisplay();
            }
            
            // Merge groups (avoid duplicates by name)
            data.groups.forEach(importedGroup => {
                const existing = groups.find(g => g.name === importedGroup.name);
                if (!existing) {
                    const newGroupId = Date.now() + Math.floor(Math.random() * 10000);
                    const newGroup = {
                        ...importedGroup,
                        id: newGroupId
                    };
                    
                    data.annotations.forEach(ann => {
                        if (ann.groupId === importedGroup.id) {
                            ann.groupId = newGroupId;
                        }
                    });
                    
                    groups.push(newGroup);
                } else {
                    data.annotations.forEach(ann => {
                        if (ann.groupId === importedGroup.id) {
                            ann.groupId = existing.id;
                        }
                    });
                }
            });

            // Add annotations with new IDs
            let idOffset = 0;
            data.annotations.forEach(ann => {
                idOffset++;
                annotations.push({
                    ...ann,
                    id: Date.now() + idOffset,
                    uuid: ann.uuid || generateUUID()
                });
            });

            // Re-project imported annotations onto current model surface
            reprojectAllAnnotations();
            
            updateGroupsList();
            renderAnnotations();
            showStatus(`Imported ${data.annotations.length} annotations (legacy format)`);
        }

        // ============ Utilities ============
        function showStatus(message) {
            status.textContent = message;
            status.classList.add('visible');
            setTimeout(() => {
                status.classList.remove('visible');
            }, 3000);
        }
        
        function updateFaceCountDisplay(count) {
            const formatted = count.toLocaleString();
            
            if (count > 1000000) {
                faceCountDisplay.innerHTML = `<span class="warning">⚠️ ${formatted} faces</span> (Surface tool may be slow)`;
            } else if (count > 500000) {
                faceCountDisplay.innerHTML = `<span class="warning">${formatted} faces</span> (Surface tool may lag)`;
            } else {
                faceCountDisplay.textContent = `${formatted} faces`;
            }
            
            modelStats.classList.add('visible');
        }

        function filterAnnotations(searchTerm) {
            const term = searchTerm.toLowerCase().trim();
            
            // Get all group items and annotation items
            const groupItems = groupsContainer.querySelectorAll('.group-item');
            
            groupItems.forEach(groupItem => {
                const annotationItems = groupItem.querySelectorAll('.annotation-item');
                let hasVisibleAnnotation = false;
                
                annotationItems.forEach(annItem => {
                    const name = annItem.querySelector('.name')?.textContent.toLowerCase() || '';
                    
                    if (term === '' || name.includes(term)) {
                        annItem.classList.remove('search-hidden');
                        hasVisibleAnnotation = true;
                    } else {
                        annItem.classList.add('search-hidden');
                    }
                });
                
                // Hide group if no annotations match (unless search is empty)
                if (term === '') {
                    groupItem.classList.remove('search-hidden');
                } else if (hasVisibleAnnotation) {
                    groupItem.classList.remove('search-hidden');
                } else {
                    groupItem.classList.add('search-hidden');
                }
            });
        }

        function toggleManualItem(header) {
            header.classList.toggle('expanded');
            const content = header.nextElementSibling;
            content.classList.toggle('expanded');
        }
        // Make accessible for inline onclick handlers
        window.toggleManualItem = toggleManualItem;

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ============ Event Listeners ============
        btnLoad.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) loadModel(e.target.files[0]);
            fileInput.value = ''; // Reset so same file can be loaded again
        });
        
        // OBJ dialog event listeners
        objLoadPlain.addEventListener('click', () => {
            objDialogOverlay.classList.remove('visible');
            if (pendingObjFile) {
                loadOBJModel(pendingObjFile, null);
                pendingObjFile = null;
            }
        });
        
        objAddMaterials.addEventListener('click', () => {
            objDialogOverlay.classList.remove('visible');
            objMaterialInput.click();
            
            // Handle case where user cancels the file picker
            const handleCancel = () => {
                window.removeEventListener('focus', handleCancel);
                setTimeout(() => {
                    if (pendingObjFile && objMaterialInput.files.length === 0) {
                        loadOBJModel(pendingObjFile, null);
                        pendingObjFile = null;
                    }
                }, 300);
            };
            window.addEventListener('focus', handleCancel);
        });
        
        objMaterialInput.addEventListener('change', (e) => {
            if (pendingObjFile) {
                const materialFiles = Array.from(e.target.files);
                loadOBJModel(pendingObjFile, materialFiles);
                pendingObjFile = null;
            }
            objMaterialInput.value = ''; // Reset
        });

        // PLY dialog event listeners
        plyLoadPlain.addEventListener('click', () => {
            plyDialogOverlay.classList.remove('visible');
            if (pendingPlyFile) {
                loadPLYModel(pendingPlyFile, null);
                pendingPlyFile = null;
            }
        });

        plyAddTexture.addEventListener('click', () => {
            plyDialogOverlay.classList.remove('visible');
            plyTextureInput.click();

            // Handle case where user cancels the file picker
            const handleCancel = () => {
                window.removeEventListener('focus', handleCancel);
                setTimeout(() => {
                    if (pendingPlyFile && plyTextureInput.files.length === 0) {
                        loadPLYModel(pendingPlyFile, null);
                        pendingPlyFile = null;
                    }
                }, 300);
            };
            window.addEventListener('focus', handleCancel);
        });

        plyTextureInput.addEventListener('change', (e) => {
            if (pendingPlyFile) {
                const textureFile = e.target.files[0] || null;
                loadPLYModel(pendingPlyFile, textureFile);
                pendingPlyFile = null;
            }
            plyTextureInput.value = ''; // Reset
        });

        btnTexture.addEventListener('click', toggleTexture);
        btnPoint.addEventListener('click', () => setTool('point'));
        btnLine.addEventListener('click', () => setTool('line'));
        btnPolygon.addEventListener('click', () => setTool('polygon'));
        btnSurface.addEventListener('click', () => setTool('surface'));
        btnMeasure.addEventListener('click', () => setTool('measure'));
        btnScreenshot.addEventListener('click', takeScreenshot);
        btnExport.addEventListener('click', exportAnnotations);
        btnExportPdf.addEventListener('click', exportPdfReport);
        btnImport.addEventListener('click', () => importInput.click());
        importInput.addEventListener('change', (e) => {
            if (e.target.files[0]) importAnnotations(e.target.files[0]);
        });
        
        // Brush size slider
        brushSlider.addEventListener('input', (e) => {
            surfaceBrushSize = parseFloat(e.target.value);
            brushValue.textContent = surfaceBrushSize + '%';
        });
        
        // Search filter
        searchInput.addEventListener('input', (e) => {
            filterAnnotations(e.target.value);
        });

        btnAddGroup.addEventListener('click', () => openGroupPopup());
        btnGroupSave.addEventListener('click', saveGroup);
        btnGroupCancel.addEventListener('click', () => {
            groupPopup.classList.remove('visible');
            editingGroup = null;
        });
        btnGroupDelete.addEventListener('click', () => {
            if (editingGroup) deleteGroup(editingGroup);
        });

        btnPopupSave.addEventListener('click', saveAnnotation);
        btnPopupCancel.addEventListener('click', () => {
            annotationPopup.classList.remove('visible');
            clearTempDrawing();
            editingAnnotation = null;
            editingModelInfo = false;
            isAddingEntry = false;
            editingEntryId = null;
        });
        btnPopupDelete.addEventListener('click', deleteAnnotation);
        btnAddLink.addEventListener('click', addLink);
        annNewLink.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') addLink();
        });
        
        // Add Entry button
        btnAddEntry.addEventListener('click', showAddEntryForm);
        
        // Model Info double-click
        modelInfoItem.addEventListener('dblclick', openModelInfoPopup);
        
        // Confirmation dialog
        confirmOk.addEventListener('click', () => {
            if (confirmCallback) confirmCallback();
            hideConfirm();
        });
        confirmCancel.addEventListener('click', hideConfirm);
        confirmOverlay.addEventListener('click', (e) => {
            if (e.target === confirmOverlay) hideConfirm();
        });
        
        // Scalebar confirmation dialog
        scalebarSwitch.addEventListener('click', () => {
            if (scalebarConfirmCallback) scalebarConfirmCallback();
            hideScalebarConfirm();
        });
        scalebarNoSwitch.addEventListener('click', () => {
            const callback = scalebarNoSwitchCallback;
            hideScalebarConfirm();
            if (callback) callback();
        });
        scalebarConfirmOverlay.addEventListener('click', (e) => {
            if (e.target === scalebarConfirmOverlay) hideScalebarConfirm();
        });

        canvas.addEventListener('click', onCanvasClick);
        canvas.addEventListener('dblclick', onCanvasDblClick);
        canvas.addEventListener('mousedown', onCanvasMouseDown);
        canvas.addEventListener('mousemove', onCanvasMouseMove);
        canvas.addEventListener('mouseup', onCanvasMouseUp);

        brightnessSlider.addEventListener('input', (e) => setBrightness(parseInt(e.target.value)));
        opacitySlider.addEventListener('input', (e) => setModelOpacity(parseInt(e.target.value)));
        
        // Light controls
        lightToggle.addEventListener('click', toggleLightMode);
        lightAzimuthSlider.addEventListener('input', (e) => setLightAzimuth(parseInt(e.target.value)));
        lightElevationSlider.addEventListener('input', (e) => setLightElevation(parseInt(e.target.value)));
        pointSizeSlider.addEventListener('input', (e) => setPointSize(parseInt(e.target.value)));
        textSizeSlider.addEventListener('input', (e) => setTextSize(parseInt(e.target.value)));

        // Sliders panel toggle
        slidersPanelToggle.addEventListener('click', () => {
            slidersPanel.classList.toggle('collapsed');
            slidersPanelToggle.textContent = slidersPanel.classList.contains('collapsed') ? '▲' : '▼';
        });

        // Popup dragging
        popupTitle.addEventListener('mousedown', (e) => {
            isDraggingPopup = true;
            const rect = annotationPopup.getBoundingClientRect();
            popupDragOffsetX = e.clientX - rect.left;
            popupDragOffsetY = e.clientY - rect.top;
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDraggingPopup) return;
            
            const viewportWidth = window.innerWidth - 320; // Account for sidebar
            const viewportHeight = window.innerHeight - 50; // Account for header
            const popupRect = annotationPopup.getBoundingClientRect();
            
            let newX = e.clientX - popupDragOffsetX;
            let newY = e.clientY - popupDragOffsetY - 50; // Offset for header
            
            // Keep popup within viewport bounds
            newX = Math.max(0, Math.min(newX, viewportWidth - popupRect.width));
            newY = Math.max(0, Math.min(newY, viewportHeight - popupRect.height));
            
            annotationPopup.style.left = newX + 'px';
            annotationPopup.style.top = newY + 'px';
            annotationPopup.style.right = 'auto';
            annotationPopup.style.bottom = 'auto';
        });
        
        document.addEventListener('mouseup', () => {
            isDraggingPopup = false;
        });

        // About modal
        btnAbout.addEventListener('click', () => {
            aboutOverlay.classList.add('visible');
        });

        aboutModalClose.addEventListener('click', () => {
            aboutOverlay.classList.remove('visible');
        });

        aboutOverlay.addEventListener('click', (e) => {
            if (e.target === aboutOverlay) {
                aboutOverlay.classList.remove('visible');
            }
        });

        // Download Manual as PDF
        btnDownloadManual.addEventListener('click', downloadManualAsPdf);

        // Legal modal
        btnLegal.addEventListener('click', () => {
            legalOverlay.classList.add('visible');
        });

        legalModalClose.addEventListener('click', () => {
            legalOverlay.classList.remove('visible');
        });

        legalOverlay.addEventListener('click', (e) => {
            if (e.target === legalOverlay) {
                legalOverlay.classList.remove('visible');
            }
        });

        cameraToggle.addEventListener('click', toggleCamera);

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                // Close confirmation dialog if open
                if (confirmOverlay.classList.contains('visible')) {
                    hideConfirm();
                    return;
                }
                
                // Close about modal if open
                if (aboutOverlay.classList.contains('visible')) {
                    aboutOverlay.classList.remove('visible');
                    return;
                }
                
                // Close legal modal if open
                if (legalOverlay.classList.contains('visible')) {
                    legalOverlay.classList.remove('visible');
                    return;
                }
                
                // Close scalebar confirm dialog if open
                if (scalebarConfirmOverlay.classList.contains('visible')) {
                    hideScalebarConfirm();
                    return;
                }
                
                annotationPopup.classList.remove('visible');
                groupPopup.classList.remove('visible');
                isAddingEntry = false;
                editingEntryId = null;
                editingModelInfo = false;
                
                // Clear measurements if in measure mode
                if (currentTool === 'measure') {
                    clearAllMeasurements();
                    showStatus('Measurements cleared');
                }
                
                setTool(null);
                clearTempDrawing();
            }
        });

        // ============ Start ============
        init();
        
        // Expose key variables for console debugging
        window.meshnotesDebug = {
            getScene: () => scene,
            getModel: () => currentModel,
            checkColors: () => {
                if (!currentModel) {
                    console.log('No model loaded');
                    return;
                }
                let report = { vertexColorsAttribute: [], vertexColorsWithData: [], materialColors: [], textures: [] };
                currentModel.traverse((child) => {
                    if (child.isMesh) {
                        const name = child.name || 'unnamed mesh';
                        if (child.geometry.attributes.color) {
                            report.vertexColorsAttribute.push(name);
                            // Check if vertex colors have actual data (not just white)
                            const colorAttr = child.geometry.attributes.color;
                            const count = colorAttr.count;
                            let hasRealColors = false;
                            const samplesToCheck = Math.min(50, count);
                            for (let i = 0; i < samplesToCheck; i++) {
                                const idx = Math.floor(i * count / samplesToCheck);
                                const r = colorAttr.getX(idx);
                                const g = colorAttr.getY(idx);
                                const b = colorAttr.getZ(idx);
                                if (r < 0.99 || g < 0.99 || b < 0.99) {
                                    hasRealColors = true;
                                    break;
                                }
                            }
                            if (hasRealColors) {
                                report.vertexColorsWithData.push(name);
                            }
                        }
                        const materials = Array.isArray(child.material) ? child.material : [child.material];
                        materials.forEach((mat, i) => {
                            if (mat.color && (mat.color.r !== 1 || mat.color.g !== 1 || mat.color.b !== 1)) {
                                report.materialColors.push(`${name}: rgb(${mat.color.r.toFixed(2)}, ${mat.color.g.toFixed(2)}, ${mat.color.b.toFixed(2)})`);
                            }
                            if (mat.map) {
                                report.textures.push(`${name}: has texture map`);
                            }
                        });
                    }
                });
                console.log('=== Model Color Report ===');
                console.log('Vertex color attribute exists:', report.vertexColorsAttribute.length > 0 ? report.vertexColorsAttribute : 'NONE');
                console.log('Vertex colors with actual data:', report.vertexColorsWithData.length > 0 ? report.vertexColorsWithData : 'NONE (all white)');
                console.log('Material Colors found:', report.materialColors.length > 0 ? report.materialColors : 'NONE');
                console.log('Textures found:', report.textures.length > 0 ? report.textures : 'NONE');
                console.log('hasVertexColors flag (enables Colors mode):', hasVertexColors);
                return report;
            }
        };
        
        // Load saved slider settings
        const savedPointSize = localStorage.getItem('meshnotes_pointSize');
        if (savedPointSize) {
            pointSizeSlider.value = savedPointSize;
            pointSizeMultiplier = parseInt(savedPointSize) / 100;
            pointSizeValue.textContent = `${savedPointSize}%`;
        }
        
        const savedTextSize = localStorage.getItem('meshnotes_textSize');
        if (savedTextSize) {
            textSizeSlider.value = savedTextSize;
            textSizeMultiplier = parseInt(savedTextSize) / 100;
            textSizeValue.textContent = `${savedTextSize}%`;
        }
    </script>
</body>
</html>
