<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MeshNotes</title>
    <style>
        :root {
            /* Primary Accent - Gold */
            --color-gold: #EDC040;
            --color-gold-dark: #AA8101;
            --color-gold-light: #FFD54F;
            --color-gold-hover: #f0cc60;
            --color-orange: #e8a33c;
            
            /* Blues - Background & UI */
            --color-blue: #1A5A8A;
            --color-blue-hover: #2A6A9A;
            --color-blue-dark: #0A3559;
            --color-blue-darkest: #041D31;
            
            /* Text Colors */
            --color-text-light: #eee;
            --color-text-medium: #aaa;
            --color-text-muted: #888;
            --color-text-dim: #666;
            
            /* Surfaces & Overlays */
            --color-surface: rgba(10, 53, 89, 0.95);
            --color-surface-90: rgba(10, 53, 89, 0.9);
            --color-surface-80: rgba(10, 53, 89, 0.8);
            --color-overlay: rgba(0, 0, 0, 0.7);
            --color-overlay-light: rgba(0, 0, 0, 0.5);
            --color-white-hover: rgba(255, 255, 255, 0.1);
            
            /* Functional */
            --color-danger: #dc3545;
            --color-border: #ccc;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: var(--color-blue-darkest);
        }

        /* Header */
        #header {
            height: 50px;
            background: var(--color-blue-dark);
            border-bottom: 1px solid var(--color-blue);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 500;
        }

        #header h1 {
            font-size: 18px;
            font-weight: 600;
            color: var(--color-text-light);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #header h1 span.icon {
            font-size: 22px;
        }

        #header h1 .subtitle {
            font-size: 14px;
            font-weight: 400;
            color: var(--color-text-medium);
        }

        #btn-about, #btn-legal {
            padding: 8px 16px;
            background: var(--color-blue);
            border: none;
            border-radius: 6px;
            color: var(--color-text-light);
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        #btn-about:hover, #btn-legal:hover {
            background: var(--color-blue-hover);
        }

        .header-buttons {
            display: flex;
            gap: 10px;
        }

        #container {
            display: flex;
            height: calc(100vh - 88px);
            margin-top: 88px;
        }

        #viewport {
            flex: 1;
            position: relative;
        }

        #canvas {
            display: block;
        }

        /* Toolbar */
        #toolbar {
            position: fixed;
            top: 50px;
            left: 0;
            right: 0;
            height: 38px;
            background: var(--color-blue-dark);
            border-bottom: 1px solid var(--color-blue);
            display: flex;
            align-items: center;
            padding: 0 12px;
            gap: 6px;
            z-index: 500;
        }

        .tool-btn {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            background: var(--color-blue-dark);
            color: var(--color-text-light);
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
            white-space: nowrap;
        }

        .tool-btn:hover {
            background: var(--color-blue);
        }

        .tool-btn.active {
            background: var(--color-gold-dark);
        }

        .tool-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .tool-separator {
            width: 1px;
            align-self: stretch;
            background: var(--color-blue);
            margin: 4px 4px;
        }

        #file-input, #import-input, #obj-material-input, #ply-texture-input {
            display: none;
        }

        /* OBJ Material Dialog */
        #obj-dialog-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--color-overlay);
            z-index: 300;
            align-items: center;
            justify-content: center;
        }

        #obj-dialog-overlay.visible {
            display: flex;
        }

        #ply-dialog-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--color-overlay);
            z-index: 300;
            align-items: center;
            justify-content: center;
        }

        #ply-dialog-overlay.visible {
            display: flex;
        }

        .obj-dialog {
            background: var(--color-blue-dark);
            border: 1px solid var(--color-blue);
            border-radius: 8px;
            padding: 24px;
            max-width: 420px;
            text-align: center;
        }

        .obj-dialog h3 {
            color: var(--color-text-light);
            margin-bottom: 8px;
            font-size: 16px;
        }

        .obj-dialog p {
            color: var(--color-text-medium);
            margin-bottom: 20px;
            line-height: 1.5;
            font-size: 13px;
        }

        .obj-dialog .btn-row {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .obj-dialog button {
            padding: 10px 18px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }

        .obj-dialog .btn-primary {
            background: var(--color-gold);
            color: var(--color-blue-darkest);
            font-weight: 600;
        }

        .obj-dialog .btn-primary:hover {
            background: var(--color-gold-hover);
        }

        .obj-dialog .btn-secondary {
            background: var(--color-blue);
            color: var(--color-text-light);
        }

        .obj-dialog .btn-secondary:hover {
            background: var(--color-blue-hover);
        }

        .obj-dialog .axis-selector {
            margin: 0 0 18px 0;
            text-align: left;
        }

        .obj-dialog .axis-selector label.axis-heading {
            display: block;
            color: var(--color-text-medium);
            font-size: 12px;
            margin-bottom: 8px;
        }

        .obj-dialog .axis-options {
            display: flex;
            gap: 16px;
            justify-content: center;
        }

        .obj-dialog .axis-options label {
            display: flex;
            align-items: center;
            gap: 6px;
            color: var(--color-text-light);
            font-size: 13px;
            cursor: pointer;
        }

        .obj-dialog .axis-options input[type="radio"] {
            accent-color: var(--color-gold);
            cursor: pointer;
        }

        /* Sidebar */
        #sidebar {
            width: 320px;
            background: var(--color-blue-dark);
            color: var(--color-text-light);
            display: flex;
            flex-direction: column;
            border-left: 1px solid var(--color-blue);
        }

        .sidebar-section {
            padding: 16px;
            border-bottom: 1px solid var(--color-blue);
        }

        .sidebar-section h2 {
            font-size: 14px;
            margin-bottom: 12px;
            color: var(--color-gold);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .sidebar-section h2 button {
            padding: 4px 8px;
            font-size: 11px;
        }

        /* Prominent Add Group button */
        #btn-add-group {
            padding: 6px 12px;
            font-size: 13px;
            background: var(--color-blue);
            border: 1px solid var(--color-gold);
            color: var(--color-gold);
            font-weight: 500;
            transition: all 0.2s;
        }

        #btn-add-group:hover {
            background: var(--color-gold);
            color: var(--color-blue-darkest);
            border-color: var(--color-gold);
        }

        /* Search Box */
        #search-box {
            padding: 0 16px 12px 16px;
        }

        #search-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--color-blue);
            border-radius: 4px;
            background: var(--color-blue-darkest);
            color: var(--color-text-light);
            font-size: 13px;
            box-sizing: border-box;
        }

        #search-input:focus {
            outline: none;
            border-color: var(--color-gold);
        }

        #search-input::placeholder {
            color: var(--color-text-dim);
        }

        .annotation-item.search-hidden {
            display: none !important;
        }

        .group-item.search-hidden {
            display: none !important;
        }

        #annotations-section {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        /* Group List */
        .group-item {
            background: var(--color-blue-darkest);
            border-radius: 6px;
            margin-bottom: 8px;
            overflow: hidden;
        }

        .group-header {
            padding: 10px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .group-header:hover {
            background: var(--color-blue);
        }

        .group-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.3);
            cursor: pointer;
        }

        .group-name {
            flex: 1;
            font-weight: 500;
            font-size: 13px;
        }

        .group-visibility {
            padding: 2px 6px;
            background: none;
            border: none;
            color: var(--color-text-light);
            cursor: pointer;
            font-size: 14px;
            opacity: 0.7;
        }

        .group-visibility:hover {
            opacity: 1;
        }

        .group-visibility.hidden {
            opacity: 0.3;
        }

        .group-actions {
            display: flex;
            gap: 4px;
        }

        .group-actions button {
            padding: 2px 6px;
            background: none;
            border: none;
            color: var(--color-text-medium);
            cursor: pointer;
            font-size: 12px;
        }

        .group-actions button:hover {
            color: var(--color-gold);
        }

        /* Model Information Section */
        #model-info-section {
            padding: 0 8px 12px 8px;
            border-bottom: 1px solid var(--color-blue);
            margin-bottom: 12px;
        }

        .model-info-item {
            padding: 12px;
            background: var(--color-blue-dark);
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
            border: 1px solid var(--color-blue);
        }

        .model-info-item:hover {
            background: var(--color-blue);
            border-color: var(--color-gold);
        }

        .model-info-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }

        .model-info-icon {
            font-size: 16px;
        }

        .model-info-title {
            font-weight: 600;
            font-size: 13px;
            color: var(--color-gold);
        }

        .model-info-subtitle {
            font-size: 11px;
            color: var(--color-text-muted);
            padding-left: 24px;
        }

        /* Annotation List */
        .annotation-list {
            padding: 0 8px 8px 8px;
        }

        .annotation-item {
            padding: 10px;
            background: var(--color-blue-dark);
            border-radius: 4px;
            margin-bottom: 6px;
            cursor: pointer;
            transition: background 0.2s;
            border-left: 3px solid transparent;
        }

        .annotation-item:hover {
            background: var(--color-blue);
        }

        .annotation-item.selected {
            background: var(--color-blue);
            border-left-color: var(--color-gold);
        }

        .annotation-item .header {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 4px;
        }

        .annotation-item .type-icon {
            font-size: 12px;
        }

        .annotation-item .name {
            font-weight: 500;
            font-size: 13px;
            flex: 1;
        }

        .annotation-item .description {
            font-size: 11px;
            color: var(--color-text-muted);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Popups */
        .popup {
            display: none;
            position: absolute;
            background: var(--color-blue-dark);
            border: 1px solid var(--color-blue);
            border-radius: 8px;
            padding: 16px;
            z-index: 200;
            box-shadow: 0 4px 20px var(--color-overlay-light);
        }

        .popup.visible {
            display: block;
        }

        .popup h3 {
            color: var(--color-gold);
            margin-bottom: 12px;
            font-size: 14px;
            cursor: move;
            user-select: none;
            padding: 4px 8px;
            margin: -4px -8px 12px -8px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .popup h3:hover {
            background: var(--color-white-hover);
        }

        .popup h3:active {
            background: rgba(255, 255, 255, 0.15);
        }

        .popup label {
            display: block;
            color: var(--color-text-medium);
            font-size: 12px;
            margin-bottom: 4px;
        }

        .projection-checkbox-label {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            margin: 4px 0 8px 0;
            font-size: 12px;
            color: var(--color-text-medium);
        }
        .projection-checkbox-label input[type="checkbox"] {
            width: auto;
            margin: 0;
            cursor: pointer;
            accent-color: var(--color-gold);
        }

        .popup input,
        .popup textarea,
        .popup select {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--color-blue);
            border-radius: 4px;
            background: var(--color-blue-darkest);
            color: var(--color-text-light);
            font-size: 13px;
            margin-bottom: 10px;
        }

        .popup textarea {
            height: 70px;
            resize: vertical;
            font-family: inherit;
        }

        .popup .btn-row {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-top: 4px;
        }

        .popup button {
            padding: 8px 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        .popup .btn-save {
            background: var(--color-gold-dark);
            color: white;
        }

        .popup .btn-cancel {
            background: var(--color-blue);
            color: var(--color-text-light);
        }

        .popup .btn-delete {
            background: var(--color-danger);
            color: white;
            margin-right: auto;
        }

        #annotation-popup {
            width: 400px;
            max-height: 80vh;
            overflow-y: auto;
        }

        /* Entries in annotation popup */
        #entries-container {
            margin: 12px 0;
            border-top: 1px solid var(--color-blue);
            padding-top: 12px;
        }

        #entries-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 12px;
        }

        .entry-card {
            background: var(--color-blue-darkest);
            border: 1px solid var(--color-blue);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .entry-card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .entry-card-meta {
            color: var(--color-text-muted);
        }

        .entry-card-meta .author {
            color: var(--color-gold);
            font-weight: 500;
        }

        .entry-card-actions {
            display: flex;
            gap: 4px;
        }

        .entry-card-actions button {
            padding: 4px 8px;
            background: none;
            border: none;
            color: var(--color-text-muted);
            cursor: pointer;
            font-size: 11px;
            border-radius: 3px;
        }

        .entry-card-actions button:hover {
            background: var(--color-blue);
            color: var(--color-gold);
        }

        .entry-card-description {
            color: var(--color-border);
            font-size: 13px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .entry-card-links {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid var(--color-blue);
        }

        .entry-card-links a {
            display: inline-block;
            color: var(--color-gold);
            text-decoration: none;
            font-size: 12px;
            margin-right: 12px;
            margin-bottom: 4px;
        }

        .entry-card-links a:hover {
            text-decoration: underline;
        }

        /* Entry edit mode */
        .entry-card.editing {
            border-color: var(--color-gold);
        }

        .entry-edit-form {
            display: none;
        }

        .entry-card.editing .entry-card-description,
        .entry-card.editing .entry-card-links,
        .entry-card.editing .entry-card-actions {
            display: none;
        }

        .entry-card.editing .entry-edit-form {
            display: block;
        }

        .entry-edit-form textarea {
            width: 100%;
            height: 60px;
            margin-bottom: 8px;
        }

        .entry-edit-form input {
            width: 100%;
            margin-bottom: 8px;
        }

        .entry-edit-buttons {
            display: flex;
            gap: 6px;
            justify-content: flex-end;
        }

        .entry-edit-buttons button {
            padding: 6px 12px;
            font-size: 12px;
        }

        .btn-add-entry {
            width: 100%;
            padding: 10px;
            background: var(--color-blue);
            border: 1px dashed var(--color-gold);
            border-radius: 6px;
            color: var(--color-gold);
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }

        .btn-add-entry:hover {
            background: var(--color-blue-hover);
        }

        #new-entry-form {
            border-top: 1px solid var(--color-blue);
            padding-top: 12px;
            margin-top: 12px;
        }

        /* Confirmation dialog */
        .confirm-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--color-overlay);
            z-index: 300;
            align-items: center;
            justify-content: center;
        }

        .confirm-overlay.visible {
            display: flex;
        }

        .confirm-dialog {
            background: var(--color-blue-dark);
            border: 1px solid var(--color-blue);
            border-radius: 8px;
            padding: 20px;
            max-width: 350px;
            text-align: center;
        }

        .confirm-dialog p {
            color: var(--color-border);
            margin-bottom: 16px;
            line-height: 1.5;
        }

        .confirm-dialog .btn-row {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .confirm-dialog button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        #group-popup {
            width: 260px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Links section in popup */
        .links-section {
            margin-bottom: 10px;
        }

        .links-list {
            max-height: 80px;
            overflow-y: auto;
            margin-bottom: 6px;
        }

        .link-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 6px;
            background: var(--color-blue-darkest);
            border-radius: 3px;
            margin-bottom: 4px;
            font-size: 12px;
        }

        .link-item a {
            color: var(--color-gold);
            text-decoration: none;
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .link-item button {
            padding: 2px 6px;
            background: none;
            border: none;
            color: var(--color-gold-dark);
            cursor: pointer;
            font-size: 10px;
        }

        .add-link-row {
            display: flex;
            gap: 6px;
        }

        .add-link-row input {
            flex: 1;
            margin-bottom: 0;
            font-size: 12px;
            padding: 6px;
        }

        .add-link-row button {
            padding: 6px 10px;
            font-size: 12px;
        }

        /* Measurement display */
        #measurement-display {
            display: none;
            position: absolute;
            top: 70px;
            left: 10px;
            background: var(--color-surface);
            color: var(--color-gold);
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 14px;
            z-index: 100;
            min-width: 200px;
            max-height: 300px;
            overflow-y: auto;
        }

        #measurement-display.visible {
            display: block;
        }

        #measurements-list {
            margin-bottom: 8px;
        }

        .measurement-item {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid rgba(237, 192, 64, 0.2);
        }

        .measurement-item:last-child {
            border-bottom: none;
        }

        .measurement-item .label {
            color: var(--color-text-medium);
        }

        .measurement-item .value {
            font-weight: 600;
            color: var(--color-gold);
        }

        #measurement-display .hint {
            font-size: 11px;
            color: var(--color-text-muted);
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid var(--color-white-hover);
        }

        /* Brush Display for Surface Tool */
        #brush-display {
            display: none;
            position: absolute;
            top: 70px;
            left: 10px;
            background: var(--color-surface);
            color: var(--color-gold);
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 14px;
            z-index: 100;
            min-width: 200px;
        }

        #brush-display.visible {
            display: block;
        }

        .brush-controls label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            color: var(--color-text-medium);
            font-size: 12px;
        }

        .brush-controls label span:last-child {
            color: var(--color-gold);
            font-weight: 600;
        }

        #brush-slider {
            width: 100%;
            cursor: pointer;
        }

        #brush-display .hint {
            font-size: 11px;
            color: var(--color-text-muted);
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid var(--color-white-hover);
        }

        /* Camera toggle button */
        #camera-toggle {
            margin-left: auto;
            width: 128px;
            text-align: center;
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            background: var(--color-blue);
            color: var(--color-text-light);
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }

        #camera-toggle:hover {
            background: var(--color-blue);
        }

        #camera-toggle.active {
            background: var(--color-gold-dark);
        }

        /* Instructions */
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: var(--color-surface-90);
            color: var(--color-text-medium);
            padding: 10px 14px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 100;
        }

        #instructions strong {
            color: var(--color-gold);
        }

        /* Model Stats */
        #model-stats {
            display: none;
            position: absolute;
            bottom: 10px;
            right: 230px;
            background: var(--color-surface-80);
            color: var(--color-text-muted);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 11px;
            z-index: 100;
        }

        #model-stats.visible {
            display: block;
        }

        #model-stats .warning {
            color: var(--color-orange);
        }

        /* ViewHelper (orientation gizmo) */
        #viewhelper-container {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 128px;
            height: 128px;
            z-index: 100;
            cursor: pointer;
        }

        #viewhelper-canvas {
            display: block;
            width: 128px;
            height: 128px;
        }

        /* Status message */
        #status {
            position: absolute;
            bottom: 50px;
            left: 10px;
            color: var(--color-gold);
            font-size: 13px;
            z-index: 100;
            background: var(--color-surface-90);
            padding: 8px 12px;
            border-radius: 4px;
            display: none;
        }

        #status.visible {
            display: block;
        }

        /* Loading overlay */
        #loading {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--color-text-light);
            font-size: 18px;
            z-index: 300;
            background: rgba(4, 29, 49, 0.9);
            padding: 20px 30px;
            border-radius: 8px;
        }

        #loading.visible {
            display: block;
        }

        /* Color picker */
        input[type="color"] {
            width: 40px;
            height: 30px;
            padding: 0;
            border: none;
            cursor: pointer;
        }

        /* Empty state */
        .empty-state {
            color: var(--color-text-dim);
            font-size: 13px;
            text-align: center;
            padding: 20px;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--color-blue-darkest);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--color-blue);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--color-blue-hover);
        }

        /* Sliders panel */
        #sliders-panel {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: var(--color-surface);
            border-radius: 6px;
            z-index: 100;
            min-width: 210px;
        }

        #sliders-panel.collapsed {
            min-width: auto;
            background: transparent;
        }

        #sliders-panel-toggle {
            position: absolute;
            top: 6px;
            right: 6px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--color-text-medium);
            font-size: 12px;
            background: var(--color-surface-80);
            border-radius: 4px;
            user-select: none;
            z-index: 1;
        }

        #sliders-panel-toggle:hover {
            background: rgba(26, 90, 138, 0.9);
            color: var(--color-text-light);
        }

        #sliders-panel.collapsed #sliders-panel-toggle {
            position: relative;
            top: auto;
            right: auto;
            background: var(--color-surface);
        }

        #sliders-panel-content {
            padding: 12px 16px;
            padding-top: 32px;
        }

        #sliders-panel.collapsed #sliders-panel-content {
            display: none;
        }

        /* Light mode toggle */
        .light-mode-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--color-white-hover);
        }

        .light-mode-row label {
            color: var(--color-text-medium);
            font-size: 12px;
        }

        .light-toggle-btn {
            padding: 4px 10px;
            background: var(--color-blue-darkest);
            border: 1px solid var(--color-blue);
            border-radius: 4px;
            color: var(--color-text-light);
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        .light-toggle-btn:hover {
            border-color: var(--color-gold);
        }

        .light-toggle-btn.active {
            background: var(--color-gold-dark);
            border-color: var(--color-gold-dark);
        }

        #light-direction-row {
            display: none;
        }

        #light-direction-row.visible {
            display: block;
        }

        /* Light direction sliders */
        .light-sliders-group {
            border-top: 1px solid var(--color-white-hover);
            padding-top: 10px;
            margin-top: 10px;
        }

        .light-sliders-group .slider-row {
            margin-bottom: 8px;
        }

        .light-sliders-group .slider-row:last-child {
            margin-bottom: 0;
        }

        /* About Modal */
        #about-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--color-overlay);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        #about-overlay.visible {
            display: flex;
        }

        /* Legal Modal */
        #legal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--color-overlay);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        #legal-overlay.visible {
            display: flex;
        }

        #legal-modal {
            background: var(--color-blue-dark);
            border-radius: 12px;
            width: 90%;
            max-width: 700px;
            max-height: 85vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 40px var(--color-overlay-light);
        }

        #legal-modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--color-blue);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        #legal-modal-header h2 {
            font-size: 18px;
            color: var(--color-text-light);
        }

        #legal-modal-close {
            background: none;
            border: none;
            color: var(--color-text-muted);
            font-size: 24px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        #legal-modal-close:hover {
            background: var(--color-blue);
            color: var(--color-text-light);
        }

        #legal-modal-content {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
        }

        #legal-modal-content section {
            margin-bottom: 24px;
        }

        #legal-modal-content section:last-child {
            margin-bottom: 0;
        }

        #legal-modal-content h3 {
            font-size: 16px;
            color: var(--color-gold);
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--color-blue);
        }

        #legal-modal-content p {
            color: var(--color-border);
            line-height: 1.6;
            margin-bottom: 12px;
        }

        #legal-modal-content a {
            color: var(--color-gold);
            text-decoration: none;
        }

        #legal-modal-content a:hover {
            text-decoration: underline;
        }

        #legal-modal-content h4 {
            font-size: 14px;
            color: var(--color-gold);
            margin: 20px 0 8px 0;
            font-weight: 600;
        }

        #legal-modal-content strong {
            color: var(--color-text-light);
        }

        #about-modal {
            background: var(--color-blue-dark);
            border-radius: 12px;
            width: 90%;
            max-width: 700px;
            max-height: 85vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 40px var(--color-overlay-light);
        }

        #about-modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--color-blue);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        #about-modal-header h2 {
            font-size: 20px;
            color: var(--color-text-light);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #about-modal-close {
            background: none;
            border: none;
            color: var(--color-text-muted);
            font-size: 24px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        #about-modal-close:hover {
            background: var(--color-blue);
            color: var(--color-text-light);
        }

        #about-modal-content {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
        }

        #about-modal-content section {
            margin-bottom: 24px;
        }

        #about-modal-content section:last-child {
            margin-bottom: 0;
        }

        #about-modal-content h3 {
            font-size: 16px;
            color: var(--color-gold);
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--color-blue);
        }

        #about-modal-content p {
            color: var(--color-border);
            line-height: 1.6;
            margin-bottom: 12px;
        }

        #about-modal-content a {
            color: var(--color-gold);
            text-decoration: none;
        }

        #about-modal-content a:hover {
            text-decoration: underline;
        }

        /* Manual section */
        #about-modal-content h4 {
            font-size: 14px;
            color: var(--color-gold);
            margin: 20px 0 8px 0;
            font-weight: 600;
        }

        #about-modal-content h4:first-of-type {
            margin-top: 0;
        }

        /* Collapsible manual items */
        .manual-item {
            background: var(--color-blue-darkest);
            border-radius: 6px;
            margin-bottom: 8px;
            overflow: hidden;
        }

        .manual-item-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 14px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            color: var(--color-gold);
            transition: background 0.2s;
        }

        .manual-item-header:hover {
            background: var(--color-blue-dark);
        }

        .manual-item-header .toggle-icon {
            font-size: 10px;
            color: var(--color-text-muted);
            transition: transform 0.2s;
        }

        .manual-item-header.expanded .toggle-icon {
            transform: rotate(90deg);
        }

        .manual-item-content {
            display: none;
            padding: 0 14px 14px 14px;
            color: var(--color-border);
            font-size: 13px;
            line-height: 1.6;
        }

        .manual-item-content.expanded {
            display: block;
        }

        .manual-item-content p {
            margin: 0;
        }

        .limitation-note {
            background: rgba(232, 163, 60, 0.15);
            border-left: 3px solid var(--color-orange);
            padding: 10px 12px;
            margin-top: 10px;
            border-radius: 0 4px 4px 0;
            font-size: 12px;
            color: var(--color-border);
        }

        .limitation-note strong {
            color: var(--color-orange);
        }

        .btn-download-manual {
            width: 100%;
            padding: 12px 16px;
            margin-top: 16px;
            background: var(--color-blue);
            border: 1px solid var(--color-gold);
            border-radius: 6px;
            color: var(--color-gold);
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .btn-download-manual:hover {
            background: var(--color-blue-hover);
            border-color: var(--color-gold-light);
            color: var(--color-gold-light);
        }

        #about-modal-content code {
            background: var(--color-blue);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 13px;
            color: var(--color-gold);
        }

        .contact-info {
            background: var(--color-blue-darkest);
            padding: 16px;
            border-radius: 6px;
        }

        .contact-info p {
            margin-bottom: 8px;
        }

        .contact-info p:last-child {
            margin-bottom: 0;
        }

        .slider-row {
            margin-bottom: 10px;
        }

        .slider-row:last-child {
            margin-bottom: 0;
        }

        .slider-row.slider-divider {
            padding-bottom: 10px;
            border-bottom: 1px solid var(--color-white-hover);
        }

        .slider-row label {
            display: flex;
            justify-content: space-between;
            color: var(--color-text-medium);
            font-size: 12px;
            margin-bottom: 4px;
        }

        .slider-row input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--color-blue-darkest);
            border-radius: 3px;
            outline: none;
        }

        .slider-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: var(--color-gold);
            border-radius: 50%;
            cursor: pointer;
        }

        .slider-row input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: var(--color-gold);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header id="header">
        <h1>MeshNotes <span class="subtitle">– 3D Annotation Tool for Research & Heritage</span></h1>
        <div class="header-buttons">
            <button id="btn-about">About / Help</button>
            <button id="btn-legal">Legal / Data</button>
        </div>
    </header>

    <!-- About Modal -->
    <div id="about-overlay">
        <div id="about-modal">
            <div id="about-modal-header">
                <h2>MeshNotes</h2>
                <button id="about-modal-close">✕</button>
            </div>
            <div id="about-modal-content">
                <section>
                    <h3>About</h3>
                    <p>
                        <strong>MeshNotes</strong> is a free, browser-based tool for annotating 3D models with points, lines, polygons, and surfaces, 
                        designed for cultural heritage documentation. It allows teams to collaboratively mark and describe features 
                        on 3D models of archaeological sites, architecture, and artifacts (e.g. from photogrammetry, laser scanning, or structured light scanning).
                    </p>
                    <p>
                        Key features include multi-entry annotations (multiple users can add observations to the same feature with individual timestamps), 
                        measurement tools, customizable groups with color coding, draggable points for editing, and <strong>W3C Web Annotation</strong> compliant export/import for interoperability and team collaboration.
                    </p>
                    <p>
                        The tool runs entirely in your browser — no installation or server required. Simply open the HTML file and start annotating. 
                        Your data stays on your computer unless you share the exported file. The export format follows the 
                        <a href="https://www.w3.org/TR/annotation-model/" target="_blank">W3C Web Annotation Data Model</a>, 
                        ensuring compatibility with IIIF-based systems and other annotation tools.
                    </p>
                </section>

                <section>
                    <h3>Contact</h3>
                    <div class="contact-info">
                        <p><strong>Developer:</strong> Nils Schnorr</p>
                        <p><strong>Email:</strong> <a href="mailto:nils.schnorr@uni-saarland.de">nils.schnorr@uni-saarland.de</a></p>
                        <p><strong>Institution:</strong> Department of Classical Archaeology, Saarland University, Saarbrücken, Germany</p>
                    </div>
                </section>

                <section>
                    <h3>Quick Start</h3>
                    <div style="background: #041D31; padding: 16px; border-radius: 6px;">
                        <p style="margin-bottom: 12px;"><strong>1. Load a model</strong> — Click <strong>Load Model</strong> and select a 3D model file (.glb, .gltf, .obj, or .ply format). For OBJ files, you will be prompted to optionally add material (.mtl) and texture files.</p>
                        <p style="margin-bottom: 12px;"><strong>2. Add annotations</strong> — Select a tool (Point, Line, Polygon, or Surface) and click on the model. Double-click to finish lines/polygons/surfaces.</p>
                        <p style="margin-bottom: 12px;"><strong>3. Navigate annotations</strong> — Single-click an annotation in the sidebar to focus the camera on it. Double-click to open it for editing.</p>
                        <p style="margin-bottom: 12px;"><strong>4. Adjust annotations</strong> — When no tool is active, drag any annotation point to reposition it. Use groups to organize and color-code your work.</p>
                        <p style="margin-bottom: 12px;"><strong>5. Take measurements</strong> — Use the Measure tool to click two points and get the distance. Press Escape to clear.</p>
                        <p style="margin-bottom: 0;"><strong>6. Export your work</strong> — Click <strong>JSON</strong> to save annotations for backup or team sharing. Click <strong>PDF</strong> to generate a documentation report with screenshots.</p>
                    </div>
                </section>

                <section>
                    <h3>Manual</h3>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Loading a Model</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Click <strong>Load Model</strong> to open a 3D model file. The tool supports <code>.glb</code>, <code>.gltf</code>, <code>.obj</code>, and <code>.ply</code> formats. After loading, the face count is displayed in the bottom-right corner.</p>
                            
                            <p style="margin-top: 10px;"><strong>PLY Files:</strong> When loading a PLY file, you will be asked whether to add a texture image. If your PLY contains UV coordinates, the texture will be mapped onto the model. PLY files with vertex colors are loaded automatically without requiring a separate texture.</p>
                            
                            <p style="margin-top: 10px;"><strong>OBJ Files:</strong> When loading an OBJ file, you will be asked whether to add material and texture files. You can select a <code>.mtl</code> file together with texture images (<code>.jpg</code>, <code>.png</code>), or only texture images, or load the geometry without any materials. If only a texture is provided without an MTL file, it will be applied as a diffuse map.</p>
                            
                            <p style="margin-top: 10px;"><strong>Model Orientation:</strong> Ensure your model is oriented correctly (typically Y-up or Z-up) before exporting. The viewer's navigation is based on the model's original orientation and cannot be changed after loading. If your model appears upside down or sideways, re-export it with the correct orientation in your 3D software.</p>
                            <p style="margin-top: 10px;"><strong>Tip:</strong> GLB is recommended for best compatibility as it embeds textures and orientation in a single file. If your model is in another format, you can convert it using <a href="https://www.blender.org/" target="_blank">Blender</a>.</p>
                            <div class="limitation-note" style="margin-top: 12px;">
                                <strong>Exporting Vertex Colors from Blender:</strong> To include vertex colors in your GLB export, go to <code>File → Export → glTF 2.0</code>. In the export panel, expand <strong>Mesh</strong>, then <strong>Vertex Colors</strong>, and set <strong>Use Vertex Color</strong> to <strong>Active</strong>. This ensures that vertex color data is included in the GLB file and will be available in the Colors display mode.
                            </div>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Model Preparation &amp; Format Guide</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>MeshNotes works with 3D models in <code>.glb</code>, <code>.gltf</code>, <code>.obj</code>, and <code>.ply</code> formats. Choosing the right format and preparing your model well will give you the best experience.</p>

                            <p style="margin-top: 10px;"><strong>Recommended format:</strong> <code>GLB</code> (Binary glTF) is the best all-around choice. It packages geometry, textures, and materials into a single file, loads quickly, and does not allow for misleading axial orientation</p>

                            <p style="margin-top: 10px;"><strong>Format comparison:</strong></p>
                            <ul style="margin: 8px 0 0 20px; padding: 0;">
                                <li><strong>GLB/GLTF</strong> — Best overall. Single file (GLB) or folder with linked textures (GLTF). Supports textures, materials, and vertex colors.</li>
                                <li><strong>OBJ</strong> — Widely supported format. Requires separate <code>.mtl</code> and texture files. Often used for models from photogrammetry or SLS software.</li>
                                <li><strong>PLY</strong> — Common for point clouds and laser scans, standart format for e.g. GigaMesh. Supports vertex colors natively.</li>
                            </ul>

                            <p style="margin-top: 10px;"><strong>Face count &amp; performance:</strong> The number of faces (triangles) in your model directly affects performance. After loading, the face count is displayed in the bottom-right corner with a color indicator:</p>
                            
                            <p style="margin-top: 10px;"><strong>Orientation:</strong> When loading OBJ or PLY files, MeshNotes will ask you which axis is "up" in your source software. Most photogrammetry and cultural heritage tools (Metashape, CloudCompare, MeshLab, Blender) use <strong>Z-up</strong>, while some game engines and web viewers use Y-up. Selecting the correct option ensures your model displays upright. GLB/GLTF files handle orientation automatically per the glTF specification. See the <em>Coordinate System</em> section below for more details.</p>

                            <p style="margin-top: 10px;"><strong>Units:</strong> MeshNotes displays distances and scalebar values in whatever unit your model was created with. If your photogrammetry software exports in meters, distances will be in meters. If it exports in millimeters, they will be in millimeters. There is no unit conversion — consistency depends on your source data. Check your 3D software's export settings if distances seem off by a factor of 1000.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Coordinate System</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>MeshNotes displays all models and exports all annotation coordinates with <strong>Z pointing up</strong>. This matches the convention used by most software in cultural heritage, photogrammetry, and geospatial work, including Metashape, CloudCompare, MeshLab, QGIS, and Blender.</p>

                            <p style="margin-top: 10px;"><strong>Why this matters:</strong> When you annotate a model in MeshNotes and export the annotations as JSON, the coordinates in that file use Z-up. If a colleague opens the same model in a different software and overlays your annotations, the points will be in the correct positions — no manual coordinate conversion needed.</p>

                            <p style="margin-top: 10px;"><strong>How it works internally:</strong> The 3D engine that MeshNotes is built on (Three.js) uses Y-up internally, which is common for web-based 3D viewers. MeshNotes handles the translation between these two conventions automatically, so you never need to worry about it. The View Helper in the top-right corner always shows Z (blue) pointing up, Y (green) pointing forward, and X (red) pointing right, reflecting the Z-up convention most users will be used to.</p>

                            <p style="margin-top: 10px;"><strong>On import:</strong> When loading OBJ or PLY files, MeshNotes asks which axis is up in your source software and rotates the model accordingly. GLB/GLTF files always use Y-up by specification, so MeshNotes handles them automatically. When importing annotation files, MeshNotes checks the <code>upAxis</code> field in the JSON. Files marked as Z-up are loaded directly; older files without this field are treated as legacy Y-up data and converted automatically.</p>

                            <p style="margin-top: 10px;"><strong>On export:</strong> All annotation JSON files include an <code>"upAxis": "Z"</code> field near the top of the file. This tells any software reading the file which coordinate convention to expect. The field is deliberately not prefixed with a MeshNotes-specific namespace, so it is easy for other tools to read and interpret.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Texture &amp; Display Controls</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p><strong>Display Mode:</strong> Click the display button to cycle through three modes: <strong>Texture</strong> (shows the model's texture maps), <strong>Colors</strong> (shows vertex colors only, if present), and <strong>Gray</strong> (plain geometry without any color). The Colors mode is only available if the model contains vertex color data.</p>
                            <p style="margin-top: 10px;"><strong>Brightness slider:</strong> Adjust scene lighting from 0% to 300%. <strong>Opacity slider:</strong> Make the model transparent (10-100%) to see annotations that pass through it.</p>
                            <p style="margin-top: 10px;"><strong>Annotation Display:</strong> Use the <strong>Point Size</strong> slider (25-500%) to adjust the size of annotation markers, and the <strong>Text Size</strong> slider (25-300%) to adjust annotation label sizes. These settings are saved automatically.</p>
                            <p style="margin-top: 10px;"><strong>Light Source:</strong> By default, the main light follows your camera view, ensuring consistent illumination from any angle. Click the toggle to switch to <strong>Fixed Direction</strong> mode, which reveals two sliders: <strong>Horizontal</strong> (0°-360°) rotates the light around the model, and <strong>Vertical</strong> (-90° to +90°) adjusts the light height from below (-90°) through the horizon (0°) to directly above (+90°). This is ideal for raking light analysis of surface details like tool marks, inscriptions, or weathering patterns. The light is automatically boosted in fixed mode for better shadow visibility.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Point Annotations</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Click <strong>Point</strong>, then click on the model surface to place a point marker. A popup will appear where you can enter a name, description, author, and external links.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Line Annotations</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Click <strong>Line</strong> to start drawing a polyline. Single-click to add points along the line, double-click to finish and open the annotation popup. Lines are useful for marking edges, boundaries, cracks, or linear features.</p>
                            <p style="margin-top: 10px;"><strong>Surface projection:</strong> By default, line edges are automatically projected onto the model surface — they follow the geometry's contour rather than cutting through it as straight lines. This works best on smaller objects with gently curved surfaces. If the projection deviates too far from the intended path (e.g., on complex geometry with deep recesses), MeshNotes falls back to a straight connection for that segment automatically. You can toggle surface projection on or off per annotation using the <strong>"Project line(s) to surface"</strong> checkbox in the annotation popup.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Polygon Annotations</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Click <strong>Polygon</strong> to start drawing a closed shape. Single-click to add vertices, double-click to close the polygon and open the annotation popup. Polygons are useful for marking areas, surfaces, or regions of interest.</p>
                            <p style="margin-top: 10px;">Like line annotations, polygon edges are projected onto the model surface by default, following the geometry's contour. This can be toggled per annotation in the popup.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Surface Annotations</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Click <strong>Surface</strong> to paint directly on the 3D model's mesh faces. Adjust the brush size using the slider (0.1-20% of model size), then click and drag to highlight faces. <strong>Right-click and drag</strong> to rotate the view while painting — this lets you paint a continuous surface annotation from multiple angles (e.g., wrapping around a statue's arm). Hold <strong>Shift</strong> while painting to erase. Double-click to finish and open the annotation popup.</p>
                            <p style="margin-top: 10px;">Surface annotations are ideal for marking 3D regions like weathered areas, specific architectural features, or body parts on sculptures that can't be easily captured with flat polygons.</p>
                            <div class="limitation-note">
                                <strong>Performance Note:</strong> The Surface tool uses BVH (Bounding Volume Hierarchy) acceleration for fast spatial queries, significantly improving painting performance. It works best on smaller models (statues, ceramics, artifacts). Performance depends on face count:
                                <ul style="margin: 8px 0 0 20px; padding: 0;">
                                    <li><strong>&lt; 500k faces:</strong> Smooth painting</li>
                                    <li><strong>500k - 3M faces:</strong> May experience slight lag</li>
                                    <li><strong>&gt; 3M faces:</strong> Painting may be slow — use a small brush size (0.1–0.2) for stable performance, or consider decimating the model</li>
                                </ul>
                                The face count is shown in the bottom-right corner after loading a model.
                            </div>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Measurement Tool</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Click <strong>Measure</strong> to activate the measurement tool. Click two points on the model to measure the distance between them. Multiple measurements can be taken and all stay visible with their distance labels. Take a screenshot to document your measurements, then press <code>Esc</code> to clear all. Distances are displayed in "units" — the actual unit (meters, millimeters, etc.) depends on how your 3D model was created or exported.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Groups</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Groups help organize annotations by category, phase, or team member. Click <strong>+ Group</strong> in the sidebar to create a new group with a custom name and color. All annotations within a group share that color. Use the eye icon to show/hide all annotations in a group, and the edit icon to modify the group name/color or delete the entire group. A default group is created automatically when you first annotate.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Searching Annotations</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Use the <strong>search box</strong> at the top of the sidebar to filter annotations by name. As you type, annotations and groups that don't match your search term are hidden from the list. Clear the search field to show all annotations again. This is helpful when working with many annotations and you need to quickly find a specific feature.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Model Information</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>At the top of the sidebar is a <strong>Model Information</strong> section for general notes about the entire model. Double-click it to add an introduction, context, or overview that applies to the whole model rather than a specific location. Like annotations, it supports multiple entries from different team members with timestamps — useful for documenting the model's origin, processing history, or general observations.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Multi-Entry Annotations</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Each annotation can have multiple entries from different users. When editing an annotation, you'll see all existing entries with their author and timestamp. Click <strong>+ Add Entry</strong> to add your own observation without overwriting previous ones. Each entry has its own description, author name, and links. This is ideal for collaborative documentation where multiple team members contribute observations to the same feature.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Editing Annotations</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Single-click an annotation in the sidebar to focus the camera on it. Double-click to open it for editing. In the edit popup you can: change the annotation name and group, view all entries, edit existing entries (with confirmation to encourage adding new entries), delete individual entries, or delete the entire annotation. Your author name is remembered for convenience.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Moving Annotation Points</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>When no tool is active, you can click and drag any annotation point to reposition it. The cursor changes to a hand when hovering over draggable points. While dragging, the point snaps to the model surface so your annotations stay attached to the geometry.</p>
                            <p style="margin-top: 10px;"><strong>Lines and polygons:</strong> When you drag a point that belongs to a line or polygon, the connected edges update in real-time. If surface projection is enabled for that annotation, the adjacent edges are re-projected onto the model surface as you move the point — so the lines continue to follow the surface contour at the new position. This allows you to refine annotation boundaries precisely without recreating them.</p>
                            <p style="margin-top: 10px;"><strong>Note:</strong> Surface annotations (painted faces) cannot be repositioned after creation. To adjust a surface annotation, delete it and paint a new one.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Export &amp; Import</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p><strong>JSON Export:</strong> Click to download all annotations in <strong>W3C Web Annotation</strong> format (.jsonld). This standard format ensures interoperability with other annotation tools and IIIF-compatible viewers. The export includes all entries, timestamps, metadata, groups, and model information.</p>
                            <p style="margin-top: 10px;"><strong>Import:</strong> Click to load annotations from a .json or .jsonld file. MeshNotes supports both the new W3C format and legacy MeshNotes files for backward compatibility. Imported annotations merge with existing ones — groups with the same name are combined.</p>
                            <p style="margin-top: 10px; font-size: 12px; color: #888;">The W3C Web Annotation Data Model is a standard for interoperable annotations. Learn more at <a href="https://www.w3.org/TR/annotation-model/" target="_blank">w3.org/TR/annotation-model</a></p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Collaborative Workflow &amp; Merging</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>MeshNotes is designed for teams working on the same 3D model. Multiple people can annotate independently and then merge their work through JSON import/export — no server or shared account required.</p>

                            <p style="margin-top: 10px;"><strong>How it works:</strong> Every annotation and every entry within an annotation is assigned a unique ID (UUID) when created. When you import a JSON file, MeshNotes compares these IDs to determine what is new and what already exists:</p>
                            <ul style="margin: 8px 0 0 20px; padding: 0;">
                                <li><strong>New annotations</strong> (unknown UUID) are added alongside your existing ones.</li>
                                <li><strong>Existing annotations</strong> (matching UUID) are updated — any new entries from collaborators are merged in, and entries that were edited are updated if the imported version has a newer timestamp.</li>
                                <li><strong>Groups</strong> with the same name are combined. New groups from the imported file are created automatically.</li>
                                <li><strong>Model Information</strong> entries are merged in the same way as annotation entries.</li>
                            </ul>

                            <p style="margin-top: 12px;"><strong>Example team workflow:</strong></p>
                            <ul style="margin: 8px 0 0 20px; padding: 0;">
                                <li><strong>1.</strong> Alice loads the model, creates annotations, and exports a JSON file.</li>
                                <li><strong>2.</strong> Bob loads the same model, imports Alice's JSON, and adds his own annotations and entries.</li>
                                <li><strong>3.</strong> Bob exports his JSON and sends it back to Alice.</li>
                                <li><strong>4.</strong> Alice imports Bob's file — she gets Bob's new annotations and entries merged into her existing work. Her own annotations remain untouched, and Bob's additions appear alongside them.</li>
                            </ul>
                            <p style="margin-top: 8px;">This process can be repeated as many times as needed. Each round of import merges only what is new or updated, so you never lose work and annotations are never duplicated.</p>

                            <div class="limitation-note" style="margin-top: 12px;">
                                <strong>Good to know:</strong> The merge uses timestamps to resolve conflicts — if two people edit the same entry, the most recent edit wins. To avoid overwriting each other's observations, it's best practice to <strong>add new entries</strong> rather than editing existing ones from other team members.
                            </div>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>About the W3C Web Annotation Format</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>MeshNotes exports annotations following the <a href="https://www.w3.org/TR/annotation-model/" target="_blank">W3C Web Annotation Data Model</a>, an internationally recognized standard for representing annotations on digital resources. This was a deliberate choice to ensure long-term interoperability and academic credibility.</p>
                            <p style="margin-top: 10px;"><strong>What gets stored:</strong> Each annotation is a self-contained JSON-LD object containing its geometry (as a Fragment Selector with 3D coordinates), all entries with author, description, links, and timestamps, as well as the group assignment and annotation type. The exported file is a standard <code>AnnotationCollection</code> that also includes group definitions and model information.</p>
                            <p style="margin-top: 10px;"><strong>Why it matters:</strong> Using a W3C standard means your annotation data is not locked into MeshNotes. The JSON-LD files are human-readable, can be parsed by any programming language, and are compatible with the broader ecosystem of IIIF-based annotation tools and digital humanities infrastructure. This makes MeshNotes annotations suitable for academic publication, archival, and integration into larger research data management workflows.</p>
                            <p style="margin-top: 10px; font-size: 12px; color: #888;">The exported <code>.jsonld</code> files can be opened in any text editor to inspect their contents. Each annotation's geometry is stored as coordinate strings in the <code>FragmentSelector</code> value field.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>PDF Report</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Click <strong>PDF</strong> to generate a comprehensive documentation report of your annotated model. The report is formatted for A4 paper and designed for academic documentation, publication appendices, and archival.</p>

                            <p style="margin-top: 10px;"><strong>Report structure:</strong></p>
                            <ul style="margin: 8px 0 0 20px; padding: 0;">
                                <li><strong>Title page</strong> — An overview screenshot of the model with all visible annotations, the model filename, a summary of annotation and group counts, and all Model Information entries.</li>
                                <li><strong>Axis views</strong> — Six orthogonal views (Top, Bottom, Front, Back, Left, Right) arranged in an unfolded cube layout, giving a complete overview of the model from all standard directions. If you are in orthographic mode, each view includes a scalebar.</li>
                                <li><strong>Table of contents</strong> — A numbered list of all included annotations for quick reference.</li>
                                <li><strong>Annotation pages</strong> — One page per annotation with an auto-captured screenshot (the camera automatically focuses on each annotation), the annotation name, type, and group, plus all entry details including author, date, description, and links.</li>
                            </ul>

                            <p style="margin-top: 10px;"><strong>Controlling report content:</strong> Only <strong>visible</strong> annotations are included in the PDF. Use group visibility (the eye icon) to hide annotations you don't want in the report. For example, you could hide preliminary annotations and only include finalized ones, or generate separate reports per group by toggling visibility before each export.</p>

                            <div class="limitation-note" style="margin-top: 12px;">
                                <strong>Note:</strong> During PDF generation, the camera and lighting are temporarily adjusted for consistent results. All screenshots in the report use camera-linked lighting regardless of your current light source setting, ensuring uniform illumination across all views. Your original camera position and lighting settings are restored after the report is generated.
                            </div>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Screenshots &amp; Scalebar</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Click <strong>Screenshot</strong> to save the current view as a PNG image. The screenshot includes all visible annotations, name labels, and measurement lines exactly as shown on screen — useful for documentation, reports, and publications.</p>
                            <p style="margin-top: 10px;"><strong>Scalebar:</strong> In <strong>Orthographic</strong> camera mode, screenshots automatically include a scalebar in the bottom-right corner. The scalebar shows the real-world distance based on the model's coordinate system, with values rounded to clean numbers (e.g., 1, 2, 5, 10, 20, 50...) for readability. The unit depends on how your 3D model was originally created or exported (e.g., millimeters, centimeters, or meters).</p>
                            <p style="margin-top: 10px;">If you take a screenshot while in <strong>Perspective</strong> mode, MeshNotes will ask whether you want to switch to Orthographic view first. A scalebar can only be accurate in orthographic mode, where scale is uniform across the entire image — in perspective view, objects further from the camera appear smaller, making a single scalebar misleading.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Navigation Controls</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p><strong>Left-click + drag:</strong> Rotate the view around the model. <strong>Right-click + drag:</strong> Pan the view. <strong>Scroll wheel:</strong> Zoom in/out. <strong>Escape:</strong> Cancel current drawing action, deselect tool, or clear all measurements.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Camera View</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Click the <strong>Perspective/Orthographic</strong> button in the top-right corner of the viewport to toggle between camera modes. <strong>Perspective</strong> view shows depth with natural foreshortening. <strong>Orthographic</strong> view removes perspective distortion, making parallel lines appear parallel — useful for accurate measurements, technical drawings, and architectural documentation.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>View Helper</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>In the top-right corner of the viewport you'll find the <strong>View Helper</strong>, an interactive widget provided by the <a href="https://threejs.org/docs/#examples/en/helpers/ViewHelper" target="_blank">Three.js library</a>. It displays three colored axis lines — <strong style="color: #ff4444;">X (red)</strong>, <strong style="color: #44bb44;">Y (green)</strong>, and <strong style="color: #4488ff;">Z (blue)</strong> — radiating from a central point, with labeled circles at each positive axis end and smaller circles at each negative end. As you rotate the model, the View Helper rotates along with it, always showing your current camera orientation at a glance.</p>
                            <p style="margin-top: 10px;"><strong>Click any axis circle</strong> to smoothly animate the camera to that standard view direction (e.g., click the Z circle for a top-down view, click the Y circle for a front view). This is particularly useful for consistent documentation — for example, always capturing the same angle of an artifact for comparison, or quickly switching between front and side views while annotating.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Tips</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Use the opacity slider to see annotations on the back side of the model. Group annotations by excavation phase, feature type, or team member for better organization. Export frequently to back up your work. The tool runs entirely in your browser — your data stays on your computer unless you share the exported JSON file.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Data Privacy &amp; Offline Use</span>
                            <span class="toggle-icon">▶</span>
                        </div>
                        <div class="manual-item-content">
                            <p>MeshNotes runs entirely in your web browser. No data is uploaded to any server — your 3D models, annotations, and all other data remain on your computer at all times. The tool does not use cookies, analytics, tracking, or any external services.</p>
                            <p style="margin-top: 10px;">When hosted on GitHub Pages, the HTML file itself is downloaded once, after which all processing happens locally. You can also save the HTML file to your computer and open it directly in a browser for fully offline use — no internet connection required.</p>
                            <p style="margin-top: 10px;">Exported JSON and PDF files are generated locally in your browser and saved directly to your downloads folder. Sharing annotation data with collaborators is always an explicit action on your part — you decide when and with whom to share your exported files. This makes MeshNotes suitable for documenting sensitive or unpublished archaeological sites where data confidentiality is important.</p>
                        </div>
                    </div>

                    <button class="btn-download-manual" id="btn-download-manual">📄 Download Manual as PDF</button>

                </section>

                <section>
                    <h3>Credits & License</h3>
                    <p>MeshNotes uses the following open-source libraries:</p>
                    <ul style="margin: 12px 0 12px 20px; color: #ccc;">
                        <li><a href="https://threejs.org/" target="_blank">Three.js</a> (MIT License) — 3D rendering</li>
                        <li><a href="https://github.com/gkjohnson/three-mesh-bvh" target="_blank">three-mesh-bvh</a> (MIT License) — Accelerated raycasting &amp; surface projection</li>
                        <li><a href="https://github.com/parallax/jsPDF" target="_blank">jsPDF</a> (MIT License) — PDF generation</li>
                    </ul>
                    <p>MeshNotes itself is licensed under the <strong>MIT License</strong> — free to use, modify, and distribute. See the <a href="https://github.com/NilsSchnorr/MeshNotes/blob/main/LICENSE" target="_blank">LICENSE file</a> for details.</p>
                </section>
            </div>
        </div>
    </div>

    <!-- Legal Modal -->
    <div id="legal-overlay">
        <div id="legal-modal">
            <div id="legal-modal-header">
                <h2>Legal Information and Data Policy / Impressum und Datenschutz</h2>
                <button id="legal-modal-close">✕</button>
            </div>
            <div id="legal-modal-content">
                <section>
                    <div style="background: #041D31; padding: 16px; border-radius: 6px; margin-bottom: 24px;">
                        <p style="margin-bottom: 8px;"><strong>🔗 Open Source Repository</strong></p>
                        <p style="margin-bottom: 0;">Want to use the tool without accessing this website? Feel free to download or clone the repository at <a href="https://github.com/NilsSchnorr/MeshNotes" target="_blank">github.com/NilsSchnorr/MeshNotes</a></p>
                    </div>
                </section>

                <!-- ENGLISH VERSION -->
                <section>
                    <h3>Legal Notice (English)</h3>
                    <p>
                        <strong>Nils Schnorr</strong><br>
                        <a href="mailto:nils.schnorr@uni-saarland.de">nils.schnorr@uni-saarland.de</a><br>
                        Universität des Saarlandes<br>
                        Fakultät P - Altertumswissenschaften<br>
                        Klassische Archäologie<br>
                        Campus Gebäude B3.1 Raum 1.22<br>
                        66123 Saarbrücken, Germany
                    </p>
                    
                    <h4>Disclaimer</h4>
                    
                    <p><strong>Liability for Content</strong><br>
                    As a service provider, we are responsible for our own content on these pages in accordance with general legislation pursuant to Section 7 (1) of the German Telemedia Act (TMG). However, according to Sections 8 to 10 TMG, we are not obligated to monitor transmitted or stored third-party information or to investigate circumstances that indicate illegal activity. Obligations to remove or block the use of information under general law remain unaffected. However, liability in this regard is only possible from the time of knowledge of a specific infringement. Upon becoming aware of such violations, we will remove this content immediately.</p>
                    
                    <p><strong>Liability for Links</strong><br>
                    Our website contains links to external third-party websites over whose content we have no control. Therefore, we cannot accept any liability for this third-party content. The respective provider or operator of the linked pages is always responsible for the content of those pages. The linked pages were checked for possible legal violations at the time of linking. Illegal content was not recognizable at the time of linking. Permanent content control of the linked pages is not reasonable without concrete evidence of a violation of the law. Upon becoming aware of legal violations, we will remove such links immediately.</p>
                    
                    <p><strong>Copyright</strong><br>
                    The content and works created by the site operators on these pages are subject to German copyright law. Duplication, processing, distribution, and any kind of exploitation outside the limits of copyright law require the written consent of the respective author or creator. Insofar as the content on this site was not created by the operator, the copyrights of third parties are respected. In particular, third-party content is marked as such. Should you nevertheless become aware of a copyright infringement, please inform us accordingly. Upon becoming aware of legal violations, we will remove such content immediately.</p>
                </section>

                <section>
                    <h3>Data Policy (English)</h3>
                    
                    <p>The GDPR requires transparency about how and why your personal data is processed.</p>
                    
                    <h4>Hosting</h4>
                    <p>The host operates a web server to deliver static pages.</p>
                    
                    <p><strong>Hosting via GitHub Pages</strong><br>
                    This tool is open source and hosted on "GitHub Pages". GitHub declares its handling of data in their <a href="https://docs.github.com/en/site-policy/privacy-policies/github-general-privacy-statement" target="_blank">Privacy Policy</a>.</p>
                    
                    <p style="font-style: italic; padding-left: 16px; border-left: 3px solid #1A5A8A;">"... we only collect the minimum amount of personal information that is necessary to fulfill the purpose of your interaction with us ..."</p>
                    
                    <p>As a US company, GitHub complies with the Privacy Shield requirements for users from the EU.</p>
                    
                    <p><strong>Hosting as a Static Website</strong><br>
                    This is a static website, meaning this "tool" is pre-built on the host's web server and delivered unchanged when you open the tool in your browser. During such an HTTP request, your browser transmits your IP address and the path of the requested page. This is necessary for the server to load and deliver the requested page to your browser.</p>
                    
                    <p><strong>Server Logs</strong><br>
                    During the HTTP request, in addition to your IP address and the requested page, the referrer (the page where you clicked the link), information about your browser, and your operating system are transmitted to the web server. The host stores this information in server logs to monitor operations so that disruptions and misuse can be quickly detected and resolved.</p>
                    
                    <h4>Business-Related Processing</h4>
                    <p>This tool is open-source and non-commercial. No data from you is processed in this regard by the author of "MeshNotes".</p>
                    
                    <h4>Open Source Contributions</h4>
                    <p>"MeshNotes" is an open-source project hosted at <a href="https://github.com/NilsSchnorr/MeshNotes" target="_blank">github.com/NilsSchnorr/MeshNotes</a>. You can contribute if you wish, for example by submitting a pull request on GitHub. Please note: This project is published under an MIT license, which will also apply to your contributions if the pull requests are accepted.</p>
                </section>

                <hr style="border: none; border-top: 2px solid #1A5A8A; margin: 32px 0;">

                <!-- GERMAN VERSION -->
                <section>
                    <h3>Legal / Impressum (Deutsch)</h3>
                    <p>
                        <strong>Nils Schnorr</strong><br>
                        <a href="mailto:nils.schnorr@uni-saarland.de">nils.schnorr@uni-saarland.de</a><br>
                        Universität des Saarlandes<br>
                        Fakultät P - Altertumswissenschaften<br>
                        Klassische Archäologie<br>
                        Campus Gebäude B3.1 Raum 1.22<br>
                        66123 Saarbrücken, Germany
                    </p>
                    
                    <h4>Haftungsausschluss (Disclaimer)</h4>
                    
                    <p><strong>Haftung für Inhalte</strong><br>
                    Als Diensteanbieter sind wir gemäß § 7 Abs.1 TMG für eigene Inhalte auf diesen Seiten nach den allgemeinen Gesetzen verantwortlich. Nach §§ 8 bis 10 TMG sind wir als Diensteanbieter jedoch nicht verpflichtet, übermittelte oder gespeicherte fremde Informationen zu überwachen oder nach Umständen zu forschen, die auf eine rechtswidrige Tätigkeit hinweisen. Verpflichtungen zur Entfernung oder Sperrung der Nutzung von Informationen nach den allgemeinen Gesetzen bleiben hiervon unberührt. Eine diesbezügliche Haftung ist jedoch erst ab dem Zeitpunkt der Kenntnis einer konkreten Rechtsverletzung möglich. Bei Bekanntwerden von entsprechenden Rechtsverletzungen werden wir diese Inhalte umgehend entfernen.</p>
                    
                    <p><strong>Haftung für Links</strong><br>
                    Unser Angebot enthält Links zu externen Webseiten Dritter, auf deren Inhalte wir keinen Einfluss haben. Deshalb können wir für diese fremden Inhalte auch keine Gewähr übernehmen. Für die Inhalte der verlinkten Seiten ist stets der jeweilige Anbieter oder Betreiber der Seiten verantwortlich. Die verlinkten Seiten wurden zum Zeitpunkt der Verlinkung auf mögliche Rechtsverstöße überprüft. Rechtswidrige Inhalte waren zum Zeitpunkt der Verlinkung nicht erkennbar. Eine permanente inhaltliche Kontrolle der verlinkten Seiten ist jedoch ohne konkrete Anhaltspunkte einer Rechtsverletzung nicht zumutbar. Bei Bekanntwerden von Rechtsverletzungen werden wir derartige Links umgehend entfernen.</p>
                    
                    <p><strong>Urheberrecht</strong><br>
                    Die durch die Seitenbetreiber erstellten Inhalte und Werke auf diesen Seiten unterliegen dem deutschen Urheberrecht. Die Vervielfältigung, Bearbeitung, Verbreitung und jede Art der Verwertung außerhalb der Grenzen des Urheberrechtes bedürfen der schriftlichen Zustimmung des jeweiligen Autors bzw. Erstellers. Soweit die Inhalte auf dieser Seite nicht vom Betreiber erstellt wurden, werden die Urheberrechte Dritter beachtet. Insbesondere werden Inhalte Dritter als solche gekennzeichnet. Sollten Sie trotzdem auf eine Urheberrechtsverletzung aufmerksam werden, bitten wir um einen entsprechenden Hinweis. Bei Bekanntwerden von Rechtsverletzungen werden wir derartige Inhalte umgehend entfernen.</p>
                    
                    <p style="color: #888; font-size: 12px;">Quelle: eRecht24</p>
                </section>

                <section>
                    <h3>Datenschutz (Deutsch)</h3>
                    
                    <p>Die DSGVO sieht vor, dass Sie Transparenz darüber erhalten, wie und wozu Ihre personenbezogenen Daten verarbeitet werden.</p>
                    
                    <h4>Hosting</h4>
                    <p>Der Hoster betreibt einen Web-Server zur Auslieferung der statischer Seiten.</p>
                    
                    <p><strong>Hosting durch GitHub Pages</strong><br>
                    Dieses Tool ist Open Source und wird bei "GitHub Pages" gehosted. GitHub deklariert seinen Umgang mit Daten in dieser <a href="https://docs.github.com/en/site-policy/privacy-policies/github-general-privacy-statement" target="_blank">Privacy Policy</a>.</p>
                    
                    <p style="font-style: italic; padding-left: 16px; border-left: 3px solid #1A5A8A;">"... we only collect the minimum amount of personal information that is necessary to fulfill the purpose of your interaction with us ..."</p>
                    
                    <p>GitHub erfüllt als US-Unternehmen die Anforderungen des Privacy Shield für Nutzer aus der EU.</p>
                    
                    <p><strong>Hosting als statische Website</strong><br>
                    Dies ist eine statische Website, d.h. dieses „Tool" liegt vorgefertigt auf dem Web-Server des Hosters und wird unverändert ausgeliefert, sobald Sie das Tool im Browser öffnen. Bei einem solchen http-Request überträgt Ihr Browser Ihre IP-Adresse und den Pfad der angeforderten Seite. Dies ist notwendig, damit der Browser die angeforderte Seite laden und an Ihren Browser ausliefern kann.</p>
                    
                    <p><strong>Server-Logs</strong><br>
                    Beim http-Request werden neben Ihrer IP-Adresse und der angeforderten Seite auch der Referrer (die Seite auf der Sie den Link geklickt haben), Informationen über Ihren Browser und Ihr Betriebssystem an den Web-Server übermittelt. Der Hoster speichert diese Informationen in Server-Logs, um den Betrieb zu überwachen, damit Störungen und Missbrauchsfälle schnell erkannt und behoben werden können.</p>
                    
                    <h4>Geschäftsbezogene Verarbeitung</h4>
                    <p>Dieses Tool ist Open-Source und nicht kommerziell. Es werden keine Daten von Ihnen in diesem Hinblick vom Autor von „MeshNotes" verarbeitet.</p>
                    
                    <h4>Open-Source-Beiträge</h4>
                    <p>„MeshNotes" ist ein Open-Source-Projekt, gehostet auf <a href="https://github.com/NilsSchnorr/MeshNotes" target="_blank">github.com/NilsSchnorr/MeshNotes</a>. Sie können dazu beitragen, wenn Sie möchten, z. B. durch einen Pull-Request auf GitHub. Beachten Sie dabei: Dieses Projekt ist unter einer MIT Lizenz veröffentlicht, diese gilt dann auch für Ihre Beiträge, wenn die Pull-Requests angenommen werden.</p>
                </section>
            </div>
        </div>
    </div>

    <div id="toolbar">
        <input type="file" id="file-input" accept=".glb,.gltf,.obj,.ply">
        <input type="file" id="import-input" accept=".json,.jsonld">
        <input type="file" id="obj-material-input" accept=".mtl,.jpg,.jpeg,.png,.tif,.tiff" multiple>
        <input type="file" id="ply-texture-input" accept=".jpg,.jpeg,.png,.tif,.tiff">
        
        <button class="tool-btn" id="btn-load" title="Load 3D Model (GLB, GLTF, OBJ, PLY)">📂 Load Model</button>
        <button class="tool-btn" id="btn-texture" disabled title="Toggle Texture">🖼️ Texture</button>
        
        <div class="tool-separator"></div>
        
        <button class="tool-btn" id="btn-point" disabled title="Add Point Annotation">📍 Point</button>
        <button class="tool-btn" id="btn-line" disabled title="Add Line Annotation">📏 Line</button>
        <button class="tool-btn" id="btn-polygon" disabled title="Add Polygon Annotation">⬡ Polygon</button>
        <button class="tool-btn" id="btn-surface" disabled title="Add Surface Annotation">🎨 Surface</button>
        <button class="tool-btn" id="btn-measure" disabled title="Measure Distance">📐 Measure</button>
        
        <div class="tool-separator"></div>
        
        <button class="tool-btn" id="btn-screenshot" disabled title="Take Screenshot">📷 Screenshot</button>
        <button class="tool-btn" id="btn-export" disabled title="Export Annotations as JSON">💾 JSON</button>
        <button class="tool-btn" id="btn-export-pdf" disabled title="Export as PDF Report">📄 PDF</button>
        <button class="tool-btn" id="btn-import" title="Import Annotations">📥 Import</button>
        
        <button id="camera-toggle" title="Toggle Orthographic/Perspective View">Perspective</button>
    </div>

    <div id="container">
        <div id="viewport">
            <canvas id="canvas"></canvas>

            <div id="measurement-display">
                <div id="measurements-list"></div>
                <div class="hint">Click two points to measure. Press Esc to clear all.</div>
            </div>

            <div id="brush-display">
                <div class="brush-controls">
                    <label>
                        <span>Brush Size</span>
                        <span id="brush-value">5%</span>
                    </label>
                    <input type="range" id="brush-slider" min="0.1" max="20" value="5" step="0.1">
                </div>
                <div class="hint">Click/drag to paint. Hold Shift to erase. Double-click to finish.</div>
            </div>

            <div id="instructions">
                <strong>Controls:</strong> Left-drag rotate · Right-drag pan · Scroll zoom
            </div>

            <div id="model-stats">
                <span id="face-count"></span>
            </div>

            <div id="viewhelper-container">
                <canvas id="viewhelper-canvas" width="128" height="128"></canvas>
            </div>

            <div id="sliders-panel">
                <div id="sliders-panel-toggle">▼</div>
                <div id="sliders-panel-content">
                    <div class="light-mode-row">
                    <label>Light Source</label>
                    <button class="light-toggle-btn active" id="light-toggle" title="Toggle between camera-linked and fixed light">Follows Camera</button>
                </div>
                <div id="light-direction-row">
                    <div class="light-sliders-group">
                        <div class="slider-row">
                            <label>
                                <span>Horizontal</span>
                                <span id="light-azimuth-value">0°</span>
                            </label>
                            <input type="range" id="light-azimuth-slider" min="0" max="360" value="0">
                        </div>
                        <div class="slider-row">
                            <label>
                                <span>Vertical</span>
                                <span id="light-elevation-value">45°</span>
                            </label>
                            <input type="range" id="light-elevation-slider" min="-90" max="90" value="45">
                        </div>
                    </div>
                </div>
                <div class="slider-row">
                    <label>
                        <span>Brightness</span>
                        <span id="brightness-value">100%</span>
                    </label>
                    <input type="range" id="brightness-slider" min="0" max="300" value="100">
                </div>
                <div class="slider-row slider-divider">
                    <label>
                        <span>Model Opacity</span>
                        <span id="opacity-value">100%</span>
                    </label>
                    <input type="range" id="opacity-slider" min="10" max="100" value="100">
                </div>
                <div class="slider-row">
                    <label>
                        <span>Point Size</span>
                        <span id="point-size-value">100%</span>
                    </label>
                    <input type="range" id="point-size-slider" min="25" max="500" value="100">
                </div>
                <div class="slider-row">
                    <label>
                        <span>Text Size</span>
                        <span id="text-size-value">100%</span>
                    </label>
                    <input type="range" id="text-size-slider" min="25" max="300" value="100">
                </div>
                </div>
            </div>

            <div id="status"></div>
            <div id="loading">Loading model...</div>

            <!-- Annotation Popup -->
            <div class="popup" id="annotation-popup">
                <h3 id="popup-title">New Annotation</h3>
                
                <div id="popup-main-fields">
                    <label for="ann-name">Name *</label>
                    <input type="text" id="ann-name" placeholder="e.g., Door remains">
                    
                    <label for="ann-group">Group</label>
                    <select id="ann-group"></select>
                    
                    <div id="surface-projection-toggle" style="display: none;">
                        <label class="projection-checkbox-label">
                            <input type="checkbox" id="ann-surface-projection" checked>
                            Project line(s) to surface
                        </label>
                    </div>
                </div>
                
                <!-- Entries container (shown when editing) -->
                <div id="entries-container" style="display: none;">
                    <div id="entries-list"></div>
                    <button class="btn-add-entry" id="btn-add-entry">+ Add Entry</button>
                </div>
                
                <!-- New entry form (shown when creating or adding entry) -->
                <div id="new-entry-form">
                    <label for="ann-description">Description</label>
                    <textarea id="ann-description" placeholder="Describe what you observe..."></textarea>
                    
                    <label for="ann-author">Author</label>
                    <input type="text" id="ann-author" placeholder="Your name">
                    
                    <div class="links-section">
                        <label>External Links</label>
                        <div class="links-list" id="ann-links"></div>
                        <div class="add-link-row">
                            <input type="text" id="ann-new-link" placeholder="https://...">
                            <button class="btn-save" id="btn-add-link">+</button>
                        </div>
                    </div>
                </div>
                
                <div class="btn-row">
                    <button class="btn-delete" id="btn-popup-delete" style="display: none;">Delete Annotation</button>
                    <button class="btn-cancel" id="btn-popup-cancel">Cancel</button>
                    <button class="btn-save" id="btn-popup-save">Save</button>
                </div>
            </div>

            <!-- Confirmation Dialog -->
            <div class="confirm-overlay" id="confirm-overlay">
                <div class="confirm-dialog">
                    <p id="confirm-message">Are you sure?</p>
                    <div class="btn-row">
                        <button class="btn-cancel" id="confirm-cancel">Cancel</button>
                        <button class="btn-save" id="confirm-ok">Confirm</button>
                    </div>
                </div>
            </div>

            <!-- Scalebar Confirmation Dialog -->
            <div class="confirm-overlay" id="scalebar-confirm-overlay">
                <div class="confirm-dialog" style="max-width: 450px;">
                    <p id="scalebar-confirm-message">You are currently in <strong>Perspective</strong> view. A scalebar can only be included in <strong>Orthographic</strong> view where scale is uniform across the image.</p>
                    <p style="margin-top: 12px; font-size: 12px; color: #888;">Would you like to switch to Orthographic view to include a scalebar?</p>
                    <div class="btn-row" style="margin-top: 16px;">
                        <button class="btn-cancel" id="scalebar-no-switch">Continue without scalebar</button>
                        <button class="btn-save" id="scalebar-switch">Switch & include scalebar</button>
                    </div>
                </div>
            </div>

            <!-- OBJ Material Dialog -->
            <div id="obj-dialog-overlay">
                <div class="obj-dialog">
                    <h3>OBJ File Detected</h3>
                    <p>Would you like to add material (.mtl) and/or texture files (.jpg, .png)?<br>You can select one or multiple files.</p>
                    <div class="axis-selector">
                        <label class="axis-heading">Model up-axis orientation:</label>
                        <div class="axis-options">
                            <label><input type="radio" name="obj-up-axis" value="z-up" checked> Z-up (typically Metashape, CloudCompare, MeshLab, and others)</label>
                            <label><input type="radio" name="obj-up-axis" value="y-up"> Y-up (typically Blender OBJ export)</label>
                        </div>
                    </div>
                    <div class="btn-row">
                        <button class="btn-secondary" id="obj-load-plain">Load without materials</button>
                        <button class="btn-primary" id="obj-add-materials">Add Textures & Materials</button>
                    </div>
                </div>
            </div>

            <div id="ply-dialog-overlay">
                <div class="obj-dialog">
                    <h3>PLY File Detected</h3>
                    <p>Would you like to add a texture image (.jpg, .png)?<br>This requires your PLY to contain UV coordinates.</p>
                    <div class="axis-selector">
                        <label class="axis-heading">Model up-axis orientation:</label>
                        <div class="axis-options">
                            <label><input type="radio" name="ply-up-axis" value="z-up" checked> Z-up (typically Metashape, CloudCompare, MeshLab, Blender, and others)</label>
                            <label><input type="radio" name="ply-up-axis" value="y-up"> Y-up (e.g. manually converted)</label>
                        </div>
                    </div>
                    <div class="btn-row">
                        <button class="btn-secondary" id="ply-load-plain">Load without texture</button>
                        <button class="btn-primary" id="ply-add-texture">Add Texture</button>
                    </div>
                </div>
            </div>

            <!-- Group Popup -->
            <div class="popup" id="group-popup">
                <h3 id="group-popup-title">New Group</h3>
                <label for="group-name">Name</label>
                <input type="text" id="group-name" placeholder="e.g., Phase 1 features">
                
                <label for="group-color">Color</label>
                <input type="color" id="group-color" value="#EDC040">
                
                <div class="btn-row">
                    <button class="btn-delete" id="btn-group-delete" style="display: none;">Delete</button>
                    <button class="btn-cancel" id="btn-group-cancel">Cancel</button>
                    <button class="btn-save" id="btn-group-save">Save</button>
                </div>
            </div>
        </div>

        <div id="sidebar">
            <div class="sidebar-section" style="flex: 1; overflow-y: auto;">
                <h2>
                    Annotations
                    <button class="tool-btn" id="btn-add-group">+ Group</button>
                </h2>
                
                <!-- Search Box -->
                <div id="search-box">
                    <input type="text" id="search-input" placeholder="Search annotations...">
                </div>
                
                <!-- Model Information -->
                <div id="model-info-section">
                    <div class="model-info-item" id="model-info-item">
                        <div class="model-info-header">
                            <span class="model-info-icon">📋</span>
                            <span class="model-info-title">Model Information</span>
                        </div>
                        <div class="model-info-subtitle" id="model-info-subtitle">No entries yet</div>
                    </div>
                </div>
                
                <div id="groups-container">
                    <div class="empty-state" id="no-groups">No annotations yet. Load a model and use the tools to annotate.</div>
                </div>
            </div>
        </div>
    </div>

    <!-- jsPDF library for PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "three-mesh-bvh": "https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.8.0/+esm"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';
        import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';
        import { Line2 } from 'three/addons/lines/Line2.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
        import { ViewHelper } from 'three/addons/helpers/ViewHelper.js';
        import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh';

        // Register BVH extensions for accelerated raycasting and spatial queries
        THREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;
        THREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;
        THREE.Mesh.prototype.raycast = acceleratedRaycast;

        // ============ State ============
        let scene, camera, renderer, controls;
        let perspectiveCamera, orthographicCamera;
        let viewHelper, viewHelperRenderer;
        const clock = new THREE.Clock();
        let isOrthographic = false;
        let ambientLight, dirLight1, dirLight2;
        let currentModel = null;
        let modelFileName = '';
        let originalMaterials = new Map();
        let displayMode = 'texture'; // 'texture', 'vertexColors', 'gray'
        let hasVertexColors = false; // Detected on model load
        let modelOpacity = 1.0;
        let pointSizeMultiplier = 1.0;
        let textSizeMultiplier = 1.0;
        
        // Light controls
        let lightFollowsCamera = true;
        let fixedLightAzimuth = 0; // degrees (horizontal angle, 0 = front)
        let fixedLightElevation = 45; // degrees (vertical angle, 0 = horizon, 90 = top, -90 = bottom)
        
        // Tools
        let currentTool = null; // 'point', 'line', 'polygon', 'measure'
        let tempPoints = [];
        let tempProjectedEdges = []; // Cached projected edges during drawing
        let tempLine = null;
        let surfaceProjectionEnabled = true; // Project lines/polygons onto mesh surface
        let projectionDeviationRelative = 0.20; // Max deviation as fraction of edge length
        let projectionDeviationAbsolute = 0.03; // Max deviation as fraction of model bounding size
        let measurePoints = [];
        let measureMarkers = [];
        let measureLine = null;
        let measurements = []; // Array of {id, distance, markers, line}

        // Data
        let groups = [];
        let annotations = [];
        let selectedAnnotation = null;
        let editingAnnotation = null;
        
        // Model Information (general info about the whole model)
        let modelInfo = {
            entries: []
        };
        let editingModelInfo = false;

        // Point dragging
        let isDraggingPoint = false;
        let draggedAnnotation = null;
        let draggedPointIndex = -1;
        let draggedMarker = null;
        let wasDragging = false; // Prevent click event after drag
        
        // Point tool - capture position on mousedown to prevent slipping
        let pendingPointPosition = null;

        // Surface painting
        let isPaintingSurface = false;
        let surfaceBrushSize = 5; // Percentage of model size
        let paintedFaces = new Set(); // Set of face indices
        let surfaceHighlightMesh = null; // Mesh showing painted areas
        let surfaceHighlightDirty = false; // Flag for throttled highlight updates
        let surfaceHighlightRAF = null; // requestAnimationFrame ID for throttle
        let isErasingMode = false;
        let modelMeshes = []; // Cache of meshes in the model
        let modelBoundingSize = 1; // For brush size calculation
        let modelUpAxis = 'z-up'; // Track loaded model's original up-axis ('y-up' or 'z-up')

        // Three.js objects for annotations
        let annotationObjects = new THREE.Group();

        // ============ DOM Elements ============
        const canvas = document.getElementById('canvas');
        const fileInput = document.getElementById('file-input');
        const importInput = document.getElementById('import-input');
        const objMaterialInput = document.getElementById('obj-material-input');
        const objDialogOverlay = document.getElementById('obj-dialog-overlay');
        const objLoadPlain = document.getElementById('obj-load-plain');
        const objAddMaterials = document.getElementById('obj-add-materials');
        let pendingObjFile = null; // Holds OBJ file while dialog is open
        const plyTextureInput = document.getElementById('ply-texture-input');
        const plyDialogOverlay = document.getElementById('ply-dialog-overlay');
        const plyLoadPlain = document.getElementById('ply-load-plain');
        const plyAddTexture = document.getElementById('ply-add-texture');
        let pendingPlyFile = null; // Holds PLY file while dialog is open
        
        const btnLoad = document.getElementById('btn-load');
        const btnTexture = document.getElementById('btn-texture');
        const btnPoint = document.getElementById('btn-point');
        const btnLine = document.getElementById('btn-line');
        const btnPolygon = document.getElementById('btn-polygon');
        const btnSurface = document.getElementById('btn-surface');
        const btnMeasure = document.getElementById('btn-measure');
        const btnScreenshot = document.getElementById('btn-screenshot');
        const btnExport = document.getElementById('btn-export');
        const btnExportPdf = document.getElementById('btn-export-pdf');
        const btnImport = document.getElementById('btn-import');
        const btnAddGroup = document.getElementById('btn-add-group');
        
        const brushDisplay = document.getElementById('brush-display');
        const brushSlider = document.getElementById('brush-slider');
        const brushValue = document.getElementById('brush-value');

        const annotationPopup = document.getElementById('annotation-popup');
        const popupTitle = document.getElementById('popup-title');
        const annName = document.getElementById('ann-name');
        const annGroup = document.getElementById('ann-group');
        const surfaceProjectionToggle = document.getElementById('surface-projection-toggle');
        const annSurfaceProjection = document.getElementById('ann-surface-projection');
        const annDescription = document.getElementById('ann-description');
        const annAuthor = document.getElementById('ann-author');
        const annLinks = document.getElementById('ann-links');
        const annNewLink = document.getElementById('ann-new-link');
        const btnAddLink = document.getElementById('btn-add-link');
        const btnPopupSave = document.getElementById('btn-popup-save');
        const btnPopupCancel = document.getElementById('btn-popup-cancel');
        const btnPopupDelete = document.getElementById('btn-popup-delete');
        
        const entriesContainer = document.getElementById('entries-container');
        const entriesList = document.getElementById('entries-list');
        const btnAddEntry = document.getElementById('btn-add-entry');
        const newEntryForm = document.getElementById('new-entry-form');
        
        const confirmOverlay = document.getElementById('confirm-overlay');
        const confirmMessage = document.getElementById('confirm-message');
        const confirmOk = document.getElementById('confirm-ok');
        const confirmCancel = document.getElementById('confirm-cancel');
        
        const scalebarConfirmOverlay = document.getElementById('scalebar-confirm-overlay');
        const scalebarNoSwitch = document.getElementById('scalebar-no-switch');
        const scalebarSwitch = document.getElementById('scalebar-switch');
        
        const modelInfoItem = document.getElementById('model-info-item');
        const modelInfoSubtitle = document.getElementById('model-info-subtitle');
        
        const modelStats = document.getElementById('model-stats');
        const faceCountDisplay = document.getElementById('face-count');

        const groupPopup = document.getElementById('group-popup');
        const groupPopupTitle = document.getElementById('group-popup-title');
        const groupName = document.getElementById('group-name');
        const groupColor = document.getElementById('group-color');
        const btnGroupSave = document.getElementById('btn-group-save');
        const btnGroupCancel = document.getElementById('btn-group-cancel');
        const btnGroupDelete = document.getElementById('btn-group-delete');

        const groupsContainer = document.getElementById('groups-container');
        const noGroups = document.getElementById('no-groups');
        const searchInput = document.getElementById('search-input');

        const measurementDisplay = document.getElementById('measurement-display');
        const measurementsList = document.getElementById('measurements-list');
        const loading = document.getElementById('loading');
        const status = document.getElementById('status');

        const brightnessSlider = document.getElementById('brightness-slider');
        const brightnessValue = document.getElementById('brightness-value');
        const opacitySlider = document.getElementById('opacity-slider');
        const opacityValue = document.getElementById('opacity-value');
        const lightToggle = document.getElementById('light-toggle');
        const lightDirectionRow = document.getElementById('light-direction-row');
        const lightAzimuthSlider = document.getElementById('light-azimuth-slider');
        const lightAzimuthValue = document.getElementById('light-azimuth-value');
        const lightElevationSlider = document.getElementById('light-elevation-slider');
        const lightElevationValue = document.getElementById('light-elevation-value');
        const pointSizeSlider = document.getElementById('point-size-slider');
        const pointSizeValue = document.getElementById('point-size-value');
        const textSizeSlider = document.getElementById('text-size-slider');
        const textSizeValue = document.getElementById('text-size-value');
        const slidersPanel = document.getElementById('sliders-panel');
        const slidersPanelToggle = document.getElementById('sliders-panel-toggle');

        const aboutOverlay = document.getElementById('about-overlay');
        const btnAbout = document.getElementById('btn-about');
        const aboutModalClose = document.getElementById('about-modal-close');
        const btnDownloadManual = document.getElementById('btn-download-manual');
        const legalOverlay = document.getElementById('legal-overlay');
        const btnLegal = document.getElementById('btn-legal');
        const legalModalClose = document.getElementById('legal-modal-close');
        const cameraToggle = document.getElementById('camera-toggle');

        let pendingLinks = [];
        let editingGroup = null;
        let editingEntryId = null;
        let isAddingEntry = false;
        let confirmCallback = null;
        let scalebarConfirmCallback = null;
        let scalebarNoSwitchCallback = null;
        
        // Popup dragging
        let isDraggingPopup = false;
        let popupDragOffsetX = 0;
        let popupDragOffsetY = 0;
        
        function resetPopupPosition() {
            // Center the popup in the viewport
            const viewportWidth = window.innerWidth - 320;
            const viewportHeight = window.innerHeight - 50;
            annotationPopup.style.left = Math.max(20, (viewportWidth - 400) / 2) + 'px';
            annotationPopup.style.top = Math.max(20, (viewportHeight - 400) / 2) + 'px';
            annotationPopup.style.right = 'auto';
            annotationPopup.style.bottom = 'auto';
        }
        
        // Get last used author from localStorage
        const AUTHOR_STORAGE_KEY = 'meshnotes_author';
        function getLastAuthor() {
            return localStorage.getItem(AUTHOR_STORAGE_KEY) || '';
        }
        function saveLastAuthor(author) {
            if (author) localStorage.setItem(AUTHOR_STORAGE_KEY, author);
        }

        // ============ Initialize Three.js ============
        /**
         * Initializes the Three.js scene, cameras (perspective + orthographic),
         * renderer, orbit controls, lighting, grid helper, and the ViewHelper gizmo.
         * Called once on page load.
         */
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x041D31);

            const width = window.innerWidth - 320;
            const height = window.innerHeight - 50;

            // Create both cameras
            perspectiveCamera = new THREE.PerspectiveCamera(60, width / height, 0.001, 1000);
            perspectiveCamera.position.set(2, 2, 2);

            const frustumSize = 5;
            const aspect = width / height;
            orthographicCamera = new THREE.OrthographicCamera(
                -frustumSize * aspect / 2, frustumSize * aspect / 2,
                frustumSize / 2, -frustumSize / 2,
                0.001, 1000
            );
            orthographicCamera.position.set(2, 2, 2);

            // Start with perspective camera
            camera = perspectiveCamera;

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputColorSpace = THREE.SRGBColorSpace;

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // ViewHelper (orientation gizmo)
            const vhCanvas = document.getElementById('viewhelper-canvas');
            viewHelperRenderer = new THREE.WebGLRenderer({ canvas: vhCanvas, alpha: true, antialias: true });
            viewHelperRenderer.setPixelRatio(window.devicePixelRatio);
            viewHelperRenderer.setSize(128, 128);

            viewHelper = new ViewHelper(camera, viewHelperRenderer.domElement);
            viewHelper.center = controls.target;

            // Click on ViewHelper axes to animate camera
            vhCanvas.addEventListener('pointerup', (event) => {
                if (viewHelper.handleClick(event)) {
                    // ViewHelper handles the camera animation
                }
            });

            // When ViewHelper animation changes camera, update controls
            viewHelper.addEventListener('change', () => {
                controls.update();
            });

            // Lights
            ambientLight = new THREE.AmbientLight(0xffffff, 0.72);
            scene.add(ambientLight);

            dirLight1 = new THREE.DirectionalLight(0xffffff, 0.96);
            dirLight1.position.set(5, 10, 7);
            dirLight1.target = new THREE.Object3D(); // Add target for camera-linked mode
            scene.add(dirLight1);
            scene.add(dirLight1.target);

            dirLight2 = new THREE.DirectionalLight(0xffffff, 0.48);
            dirLight2.position.set(-5, -5, -5);
            scene.add(dirLight2);

            // Annotation objects group
            scene.add(annotationObjects);

            // Grid helper
            const gridHelper = new THREE.GridHelper(10, 10, 0x1A5A8A, 0x1A5A8A);
            gridHelper.name = 'gridHelper';
            scene.add(gridHelper);

            window.addEventListener('resize', onWindowResize);
            animate();

            // Show Z-up labels immediately on page load (before any model is loaded)
            updateViewHelperLabels();

            // Create default group
            createDefaultGroup();
        }

        function onWindowResize() {
            const width = window.innerWidth - 320;
            const height = window.innerHeight - 50;
            const aspect = width / height;

            // Update perspective camera
            perspectiveCamera.aspect = aspect;
            perspectiveCamera.updateProjectionMatrix();

            // Update orthographic camera
            const frustumSize = orthographicCamera.top * 2; // Current frustum size
            orthographicCamera.left = -frustumSize * aspect / 2;
            orthographicCamera.right = frustumSize * aspect / 2;
            orthographicCamera.updateProjectionMatrix();

            renderer.setSize(width, height);
            
            // Update line material resolutions
            annotationObjects.traverse((child) => {
                if (child.material && child.material.isLineMaterial) {
                    child.material.resolution.set(width, height);
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            controls.update();
            
            // Update light position if following camera
            if (lightFollowsCamera) {
                updateLightFromCamera();
            }
            
            renderer.render(scene, camera);

            // Update and render ViewHelper
            if (viewHelper.animating) {
                viewHelper.update(delta);
            }
            viewHelperRenderer.clear();
            viewHelper.render(viewHelperRenderer);
        }

        // ============ ViewHelper Relabeling ============
        /**
         * Updates ViewHelper axis labels and colors to match the loaded model's
         * coordinate system. For Z-up models (rotated into Three.js Y-up space),
         * the internal Y-axis is relabeled as Z (blue) and the internal Z-axis
         * as Y (green), so users see their model's original coordinate axes.
         * Click navigation remains correct without changes because the model
         * rotation aligns the axes: clicking "Z" (at internal +Y) navigates
         * to the top-down view, which IS the Z-down view for a Z-up model.
         */
        function updateViewHelperLabels() {
            if (!viewHelper) return;

            const colorRed   = new THREE.Color('#ff3653');
            const colorGreen = new THREE.Color('#8adb00');
            const colorBlue  = new THREE.Color('#2c8fff');

            // Helper: create a sprite canvas texture matching ViewHelper's internal format
            function makeSpriteMaterial(color, text) {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.beginPath();
                ctx.arc(32, 32, 16, 0, 2 * Math.PI);
                ctx.closePath();
                ctx.fillStyle = color.getStyle();
                ctx.fill();
                if (text) {
                    ctx.font = '24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = '#000000';
                    ctx.fillText(text, 32, 41);
                }
                const texture = new THREE.CanvasTexture(canvas);
                return new THREE.SpriteMaterial({ map: texture, toneMapped: false });
            }

            // Always show Z-up labels in ViewHelper for consistent UX.
            // Archaeological/heritage users universally work in Z-up coordinate systems
            // (Agisoft, CloudCompare, Blender), so the gizmo should always reflect that
            // convention regardless of the internal Three.js Y-up representation.
            // Mapping: Three.js +Y = Display +Z (up), Three.js -Z = Display +Y (front)
            const isZup = true;

            viewHelper.children.forEach(child => {
                if (child.isSprite && child.userData.type) {
                    const type = child.userData.type;
                    // Dispose old texture
                    if (child.material.map) child.material.map.dispose();
                    child.material.dispose();

                    switch (type) {
                        case 'posY':
                            // Internal +Y: in Z-up → model +Z (blue "Z"), in Y-up → green "Y"
                            child.material = isZup
                                ? makeSpriteMaterial(colorBlue, 'Z')
                                : makeSpriteMaterial(colorGreen, 'Y');
                            child.scale.setScalar(1); // positive axis = large
                            break;
                        case 'negY':
                            // Internal -Y: in Z-up → model -Z (blue dot), in Y-up → green dot
                            child.material = isZup
                                ? makeSpriteMaterial(colorBlue)
                                : makeSpriteMaterial(colorGreen);
                            child.scale.setScalar(0.8); // negative axis = small
                            break;
                        case 'posZ':
                            // Internal +Z: in Z-up → model -Y (green dot), in Y-up → blue "Z"
                            child.material = isZup
                                ? makeSpriteMaterial(colorGreen)
                                : makeSpriteMaterial(colorBlue, 'Z');
                            child.scale.setScalar(isZup ? 0.8 : 1);
                            break;
                        case 'negZ':
                            // Internal -Z: in Z-up → model +Y (green "Y"), in Y-up → blue dot
                            child.material = isZup
                                ? makeSpriteMaterial(colorGreen, 'Y')
                                : makeSpriteMaterial(colorBlue);
                            child.scale.setScalar(isZup ? 1 : 0.8);
                            break;
                        // posX, negX: always red, unchanged
                    }
                } else if (child.isMesh && child.material) {
                    // Axis line meshes: identify by rotation (stable across relabeling)
                    // ViewHelper internals: yAxis.rotation.z = PI/2, zAxis.rotation.y = -PI/2
                    const isYAxis = Math.abs(child.rotation.z - Math.PI / 2) < 0.01;
                    const isZAxis = Math.abs(child.rotation.y + Math.PI / 2) < 0.01;
                    if (isYAxis) {
                        child.material.color.copy(isZup ? colorBlue : colorGreen);
                    } else if (isZAxis) {
                        child.material.color.copy(isZup ? colorGreen : colorBlue);
                    }
                }
            });
        }

        // ============ Camera Toggle ============
        function toggleCamera() {
            isOrthographic = !isOrthographic;

            if (isOrthographic) {
                // Switch to orthographic
                // Copy position and rotation from perspective camera
                orthographicCamera.position.copy(perspectiveCamera.position);
                orthographicCamera.quaternion.copy(perspectiveCamera.quaternion);

                // Calculate frustum size based on distance to target
                const distance = perspectiveCamera.position.distanceTo(controls.target);
                const fov = perspectiveCamera.fov * Math.PI / 180;
                const frustumHeight = 2 * distance * Math.tan(fov / 2);
                const aspect = (window.innerWidth - 320) / (window.innerHeight - 50);

                orthographicCamera.left = -frustumHeight * aspect / 2;
                orthographicCamera.right = frustumHeight * aspect / 2;
                orthographicCamera.top = frustumHeight / 2;
                orthographicCamera.bottom = -frustumHeight / 2;
                orthographicCamera.updateProjectionMatrix();

                camera = orthographicCamera;
                cameraToggle.textContent = 'Orthographic';
                cameraToggle.classList.add('active');
            } else {
                // Switch to perspective
                // Copy position and rotation from orthographic camera
                perspectiveCamera.position.copy(orthographicCamera.position);
                perspectiveCamera.quaternion.copy(orthographicCamera.quaternion);

                camera = perspectiveCamera;
                cameraToggle.textContent = 'Perspective';
                cameraToggle.classList.remove('active');
            }

            // Update controls to use new camera
            controls.object = camera;
            controls.update();

            // Recreate ViewHelper with new camera
            viewHelper.dispose();
            viewHelper = new ViewHelper(camera, viewHelperRenderer.domElement);
            viewHelper.center = controls.target;
            viewHelper.addEventListener('change', () => {
                controls.update();
            });
            updateViewHelperLabels();
        }

        // ============ Model Loading ============
        /**
         * Entry point for loading a 3D model file. Detects the format (GLB/GLTF/OBJ/PLY)
         * and either loads directly or shows a dialog for additional files (materials/textures).
         * @param {File} file - The model file selected by the user
         */
        function loadModel(file) {
            const ext = file.name.split('.').pop().toLowerCase();
            
            if (ext === 'obj') {
                // Store OBJ file and show material dialog
                pendingObjFile = file;
                objDialogOverlay.classList.add('visible');
                return;
            }
            
            if (ext === 'ply') {
                // Store PLY file and show texture dialog
                pendingPlyFile = file;
                plyDialogOverlay.classList.add('visible');
                return;
            }
            
            // GLB/GLTF path
            loading.classList.add('visible');
            modelFileName = file.name;
            
            // Reset model info for new model
            modelInfo = { entries: [] };
            updateModelInfoDisplay();
            
            const loader = new GLTFLoader();
            const url = URL.createObjectURL(file);

            loader.load(
                url,
                (gltf) => {
                    // glTF/GLB spec mandates Y-up, no user choice needed
                    setupLoadedModel(gltf.scene, file.name, 'y-up');
                    URL.revokeObjectURL(url);
                },
                undefined,
                (error) => {
                    console.error('Error loading model:', error);
                    loading.classList.remove('visible');
                    showStatus('Error loading model!');
                }
            );
        }
        
        // Shared setup after any model (GLB/GLTF/OBJ) is loaded
        /**
         * Recursively disposes all geometries, materials, and textures of a Three.js object.
         * Call this before removing objects to prevent GPU memory leaks.
         * @param {THREE.Object3D} obj - The object to dispose
         */
        function disposeObject3D(obj) {
            if (!obj) return;
            obj.traverse((child) => {
                if (child.geometry) {
                    if (child.geometry.boundsTree) {
                        child.geometry.disposeBoundsTree();
                    }
                    child.geometry.dispose();
                }
                if (child.material) {
                    const materials = Array.isArray(child.material) ? child.material : [child.material];
                    materials.forEach(mat => {
                        if (mat.map) mat.map.dispose();
                        if (mat.normalMap) mat.normalMap.dispose();
                        if (mat.roughnessMap) mat.roughnessMap.dispose();
                        if (mat.metalnessMap) mat.metalnessMap.dispose();
                        if (mat.aoMap) mat.aoMap.dispose();
                        if (mat.emissiveMap) mat.emissiveMap.dispose();
                        mat.dispose();
                    });
                }
            });
        }

        /**
         * Shared setup after any model format is loaded. Disposes the previous model,
         * centers the new one, builds BVH acceleration structures for raycasting,
         * detects vertex colors (sampling 50 vertices to ignore all-white defaults),
         * counts faces, and configures the camera to frame the model.
         * @param {THREE.Object3D} model - The loaded Three.js model/scene
         * @param {string} fileName - Original filename for display and export metadata
         * @param {string} [upAxis='y-up'] - Original up-axis of the model ('y-up' or 'z-up').
         *   Z-up models (from Agisoft, CloudCompare, Blender) are rotated -90° around X.
         *   GLB/GLTF always pass 'y-up' per glTF spec.
         */
        function setupLoadedModel(model, fileName, upAxis) {
            // Store the model's original up-axis for coordinate transforms in export/import
            modelUpAxis = upAxis || 'y-up';

            if (currentModel) {
                // Dispose old model's GPU resources (geometries, materials, textures, BVH trees)
                disposeObject3D(currentModel);
                scene.remove(currentModel);
                // Dispose cloned materials stored for display mode switching
                originalMaterials.forEach(mat => mat.dispose());
            }

            const grid = scene.getObjectByName('gridHelper');
            if (grid) scene.remove(grid);

            // If the model uses Z-up (standard in photogrammetry/archaeology), rotate it
            // into Three.js Y-up space: rotate -90° around X so Z points up visually
            if (modelUpAxis === 'z-up') {
                model.rotation.x = -Math.PI / 2;
                model.updateMatrixWorld(true);
            }

            currentModel = model;
            scene.add(currentModel);

            originalMaterials.clear();
            modelMeshes = []; // Clear mesh cache
            hasVertexColors = false; // Reset vertex color detection
            let totalFaces = 0;
            currentModel.traverse((child) => {
                if (child.isMesh) {
                    originalMaterials.set(child.uuid, child.material.clone());
                    modelMeshes.push(child); // Cache meshes for surface painting
                    
                    // Build BVH for accelerated raycasting and surface projection
                    if (!child.geometry.boundsTree) {
                        child.geometry.computeBoundsTree();
                    }
                    
                    // Check for vertex colors (COLOR_0 attribute)
                    if (child.geometry.attributes.color) {
                        hasVertexColors = true;
                    }
                    
                    // Count faces
                    const geometry = child.geometry;
                    if (geometry.index) {
                        totalFaces += geometry.index.count / 3;
                    } else if (geometry.attributes.position) {
                        totalFaces += geometry.attributes.position.count / 3;
                    }
                }
            });
            
            // Display face count
            updateFaceCountDisplay(totalFaces);

            // Center and fit
            const box = new THREE.Box3().setFromObject(currentModel);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            modelBoundingSize = maxDim; // Store for brush size calculation

            currentModel.position.sub(center);
            camera.position.set(maxDim * 1.5, maxDim * 1.5, maxDim * 1.5);
            controls.target.set(0, 0, 0);
            controls.update();

            // Enable tools
            btnTexture.disabled = false;
            btnPoint.disabled = false;
            btnLine.disabled = false;
            btnPolygon.disabled = false;
            btnSurface.disabled = false;
            btnMeasure.disabled = false;
            btnScreenshot.disabled = false;
            btnExport.disabled = false;
            btnExportPdf.disabled = false;
            displayMode = 'texture';
            updateTextureButtonLabel();
            
            // Apply display mode to fix vertex color multiplicative issue on first load
            applyDisplayMode();
            
            // Log vertex color detection result
            if (hasVertexColors) {
                console.log('Vertex colors detected in model');
            }

            // Apply current opacity setting
            if (modelOpacity < 1.0) {
                setModelOpacity(parseInt(opacitySlider.value));
            }

            loading.classList.remove('visible');
            showStatus(`Loaded: ${fileName}`);

            // Update ViewHelper labels to match the model's coordinate system
            updateViewHelperLabels();
        }
        
        // Load OBJ model with optional material/texture files
        function loadOBJModel(objFile, materialFiles, upAxis) {
            loading.classList.add('visible');
            modelFileName = objFile.name;
            
            // Reset model info for new model
            modelInfo = { entries: [] };
            updateModelInfoDisplay();
            
            const objUrl = URL.createObjectURL(objFile);
            
            // Separate material files by type
            let mtlFile = null;
            const textureFiles = [];
            
            if (materialFiles && materialFiles.length > 0) {
                for (const f of materialFiles) {
                    const fExt = f.name.split('.').pop().toLowerCase();
                    if (fExt === 'mtl') {
                        mtlFile = f;
                    } else {
                        textureFiles.push(f);
                    }
                }
            }
            
            // Create object URLs for texture files (for MTLLoader to find them)
            const textureUrlMap = {};
            for (const tf of textureFiles) {
                textureUrlMap[tf.name] = URL.createObjectURL(tf);
            }
            
            if (mtlFile) {
                // Path A: MTL + Textures
                // Read MTL as text and use custom loading manager to resolve texture URLs
                const mtlReader = new FileReader();
                mtlReader.onload = (e) => {
                    const mtlText = e.target.result;
                    
                    // Custom loading manager that resolves texture filenames to our object URLs
                    const loadingManager = new THREE.LoadingManager();
                    loadingManager.setURLModifier((url) => {
                        // Extract just the filename from the URL path
                        const fileName = url.split('/').pop().split('\\').pop();
                        if (textureUrlMap[fileName]) {
                            return textureUrlMap[fileName];
                        }
                        return url;
                    });
                    
                    const mtlLoader = new MTLLoader(loadingManager);
                    const materials = mtlLoader.parse(mtlText, '');
                    materials.preload();
                    
                    const objLoader = new OBJLoader(loadingManager);
                    objLoader.setMaterials(materials);
                    
                    objLoader.load(
                        objUrl,
                        (obj) => {
                            // Ensure correct color space on all texture maps
                            obj.traverse((child) => {
                                if (child.isMesh && child.material) {
                                    const mat = child.material;
                                    if (mat.map) mat.map.colorSpace = THREE.SRGBColorSpace;
                                }
                            });
                            setupLoadedModel(obj, objFile.name, upAxis);
                            // Clean up object URLs
                            URL.revokeObjectURL(objUrl);
                            Object.values(textureUrlMap).forEach(u => URL.revokeObjectURL(u));
                        },
                        undefined,
                        (error) => {
                            console.error('Error loading OBJ:', error);
                            loading.classList.remove('visible');
                            showStatus('Error loading OBJ model!');
                        }
                    );
                };
                mtlReader.onerror = () => {
                    console.error('Error reading MTL file');
                    showStatus('MTL failed, loading OBJ without materials...');
                    loadOBJPlain(objUrl, textureUrlMap, objFile.name, upAxis);
                };
                mtlReader.readAsText(mtlFile);
            } else if (textureFiles.length > 0) {
                // Path B: Texture only (no MTL) - apply as diffuse map to all meshes
                loadOBJPlain(objUrl, textureUrlMap, objFile.name, upAxis);
            } else {
                // Path C: No materials at all
                loadOBJPlain(objUrl, {}, objFile.name, upAxis);
            }
        }
        
        // Load OBJ without MTL, optionally applying a single texture as diffuse map
        function loadOBJPlain(objUrl, textureUrlMap, fileName, upAxis) {
            const objLoader = new OBJLoader();
            
            objLoader.load(
                objUrl,
                (obj) => {
                    // If we have texture files, apply the first one as diffuse map
                    const textureUrls = Object.values(textureUrlMap);
                    if (textureUrls.length > 0) {
                        const textureLoader = new THREE.TextureLoader();
                        const texture = textureLoader.load(textureUrls[0]);
                        texture.colorSpace = THREE.SRGBColorSpace;
                        
                        obj.traverse((child) => {
                            if (child.isMesh) {
                                child.material = new THREE.MeshStandardMaterial({
                                    map: texture,
                                    roughness: 0.7,
                                    metalness: 0.0
                                });
                            }
                        });
                    }
                    
                    setupLoadedModel(obj, fileName, upAxis);
                    URL.revokeObjectURL(objUrl);
                    Object.values(textureUrlMap).forEach(u => URL.revokeObjectURL(u));
                },
                undefined,
                (error) => {
                    console.error('Error loading OBJ:', error);
                    loading.classList.remove('visible');
                    showStatus('Error loading OBJ model!');
                }
            );
        }

        // Load PLY with optional texture
        function loadPLYModel(plyFile, textureFile, upAxis) {
            loading.classList.add('visible');
            modelFileName = plyFile.name;
            modelInfo = { entries: [] };
            updateModelInfoDisplay();
            
            const loader = new PLYLoader();
            const url = URL.createObjectURL(plyFile);
            
            loader.load(
                url,
                (geometry) => {
                    geometry.computeVertexNormals();
                    
                    const hasColors = !!geometry.attributes.color;
                    const hasUVs = !!geometry.attributes.uv;
                    
                    let material;
                    
                    if (textureFile && hasUVs) {
                        // Apply texture using UV coordinates
                        const texUrl = URL.createObjectURL(textureFile);
                        const textureLoader = new THREE.TextureLoader();
                        const texture = textureLoader.load(texUrl, () => {
                            URL.revokeObjectURL(texUrl);
                        });
                        texture.colorSpace = THREE.SRGBColorSpace;
                        texture.flipY = true;
                        
                        material = new THREE.MeshStandardMaterial({
                            map: texture,
                            roughness: 0.7,
                            metalness: 0.0,
                            side: THREE.DoubleSide
                        });
                    } else if (textureFile && !hasUVs) {
                        // User provided texture but PLY has no UVs
                        showStatus('Warning: PLY has no UV coordinates — texture ignored');
                        material = new THREE.MeshStandardMaterial({
                            roughness: 0.7,
                            metalness: 0.0,
                            vertexColors: hasColors,
                            color: hasColors ? 0xffffff : 0xcccccc,
                            side: THREE.DoubleSide
                        });
                    } else {
                        // No texture — use vertex colors or plain gray
                        material = new THREE.MeshStandardMaterial({
                            roughness: 0.7,
                            metalness: 0.0,
                            vertexColors: hasColors,
                            color: hasColors ? 0xffffff : 0xcccccc,
                            side: THREE.DoubleSide
                        });
                    }
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    const group = new THREE.Group();
                    group.add(mesh);
                    
                    setupLoadedModel(group, plyFile.name, upAxis);
                    URL.revokeObjectURL(url);
                },
                undefined,
                (error) => {
                    console.error('Error loading PLY:', error);
                    loading.classList.remove('visible');
                    showStatus('Error loading PLY model!');
                }
            );
        }

        // ============ Texture Toggle (3-mode cycle) ============
        function toggleTexture() {
            if (!currentModel) return;
            
            // Cycle through modes: texture -> vertexColors (if available) -> gray -> texture
            if (displayMode === 'texture') {
                displayMode = hasVertexColors ? 'vertexColors' : 'gray';
            } else if (displayMode === 'vertexColors') {
                displayMode = 'gray';
            } else {
                displayMode = 'texture';
            }

            applyDisplayMode();
            updateTextureButtonLabel();
            
            const modeLabels = {
                'texture': 'Texture',
                'vertexColors': 'Vertex Colors',
                'gray': 'Gray'
            };
            showStatus(`Display: ${modeLabels[displayMode]}`);
        }
        
        function applyDisplayMode() {
            if (!currentModel) return;
            
            currentModel.traverse((child) => {
                if (child.isMesh) {
                    const original = originalMaterials.get(child.uuid);
                    
                    if (displayMode === 'texture') {
                        // Restore original material with textures, but disable vertex colors
                        // to prevent multiplicative darkening (glTF 2.0 multiplies vertex colors with texture)
                        if (original) {
                            child.material = original.clone();
                            child.material.vertexColors = false;
                        }
                    } else if (displayMode === 'vertexColors') {
                        // Show vertex colors only (no texture)
                        child.material = new THREE.MeshStandardMaterial({
                            vertexColors: true,
                            roughness: 0.7,
                            metalness: 0.0
                        });
                    } else {
                        // Gray mode - no texture, no vertex colors
                        child.material = new THREE.MeshStandardMaterial({
                            color: 0x888888,
                            roughness: 0.7,
                            metalness: 0.0
                        });
                    }
                    
                    // Preserve opacity setting
                    child.material.transparent = true;
                    child.material.opacity = modelOpacity;
                    child.material.depthWrite = modelOpacity > 0.9;
                }
            });
        }
        
        function updateTextureButtonLabel() {
            // Update button text and style based on current mode
            const labels = {
                'texture': '🖼️ Texture',
                'vertexColors': '🎨 Colors',
                'gray': '⬜ Gray'
            };
            btnTexture.innerHTML = labels[displayMode] || '🖼️ Texture';
            
            // Button is "active" (highlighted) when NOT in texture mode
            btnTexture.classList.toggle('active', displayMode !== 'texture');
        }

        // ============ Brightness Control ============
        function setBrightness(value) {
            const factor = value / 100;
            ambientLight.intensity = 0.72 * factor;
            // Apply 1.5x boost when in fixed direction mode for better raking light effect
            const dirLightMultiplier = lightFollowsCamera ? 1.0 : 1.5;
            dirLight1.intensity = 0.96 * factor * dirLightMultiplier;
            dirLight2.intensity = 0.48 * factor;
            brightnessValue.textContent = `${value}%`;
        }

        // ============ Opacity Control ============
        function setModelOpacity(value) {
            modelOpacity = value / 100;
            opacityValue.textContent = `${value}%`;
            
            if (!currentModel) return;

            currentModel.traverse((child) => {
                if (child.isMesh) {
                    child.material.transparent = true;
                    child.material.opacity = modelOpacity;
                    child.material.depthWrite = modelOpacity > 0.9;
                    child.material.needsUpdate = true;
                }
            });
        }

        // ============ Point Size Control ============
        function setPointSize(value) {
            pointSizeMultiplier = value / 100;
            pointSizeValue.textContent = `${value}%`;
            localStorage.setItem('meshnotes_pointSize', value);
            renderAnnotations();
        }

        // ============ Text Size Control ============
        function setTextSize(value) {
            textSizeMultiplier = value / 100;
            textSizeValue.textContent = `${value}%`;
            localStorage.setItem('meshnotes_textSize', value);
            renderAnnotations();
        }

        // ============ Light Controls ============
        function toggleLightMode() {
            lightFollowsCamera = !lightFollowsCamera;
            
            if (lightFollowsCamera) {
                lightToggle.textContent = 'Follows Camera';
                lightToggle.classList.add('active');
                lightDirectionRow.classList.remove('visible');
                // Restore normal light intensity
                dirLight1.intensity = 0.96 * (parseInt(brightnessSlider.value) / 100);
                updateLightFromCamera();
            } else {
                lightToggle.textContent = 'Fixed Direction';
                lightToggle.classList.remove('active');
                lightDirectionRow.classList.add('visible');
                // Boost light intensity 1.5x for better raking light shadow visibility
                dirLight1.intensity = 0.96 * (parseInt(brightnessSlider.value) / 100) * 1.5;
                updateFixedLightDirection();
            }
        }
        
        function updateLightFromCamera() {
            // Position light relative to camera direction
            const cameraDir = new THREE.Vector3();
            camera.getWorldDirection(cameraDir);
            
            // Light comes from camera direction (slightly above)
            const lightDistance = 10;
            const lightPos = camera.position.clone().sub(cameraDir.multiplyScalar(lightDistance));
            lightPos.y += 5; // Slightly above camera level
            
            dirLight1.position.copy(lightPos);
            dirLight1.target.position.copy(controls.target);
        }
        
        function updateFixedLightDirection() {
            // Convert spherical coordinates to Cartesian
            const azimuthRad = (fixedLightAzimuth * Math.PI) / 180;
            const elevationRad = (fixedLightElevation * Math.PI) / 180;
            
            const distance = 10;
            
            // Spherical to Cartesian conversion
            // Elevation: 0° = horizon, 90° = straight up, -90° = straight down
            const y = Math.sin(elevationRad) * distance;
            const horizontalDist = Math.cos(elevationRad) * distance;
            const x = Math.sin(azimuthRad) * horizontalDist;
            const z = Math.cos(azimuthRad) * horizontalDist;
            
            dirLight1.position.set(x, y, z);
            dirLight1.target.position.set(0, 0, 0);
        }
        
        function setLightAzimuth(value) {
            fixedLightAzimuth = value;
            lightAzimuthValue.textContent = `${value}°`;
            if (!lightFollowsCamera) {
                updateFixedLightDirection();
            }
        }
        
        function setLightElevation(value) {
            fixedLightElevation = value;
            lightElevationValue.textContent = `${value}°`;
            if (!lightFollowsCamera) {
                updateFixedLightDirection();
            }
        }

        // ============ Text Sprite Helper ============
        function createTextSprite(text, color = '#EDC040', backgroundColor = null, fontSize = 48) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            
            // Measure text to size canvas appropriately
            context.font = `bold ${fontSize}px Arial`;
            const metrics = context.measureText(text);
            const textWidth = metrics.width;
            const textHeight = fontSize;
            
            // Add small padding for text outline
            const padding = 8;
            canvas.width = textWidth + padding * 2;
            canvas.height = textHeight + padding * 2;
            
            // Draw text with outline for readability
            context.font = `bold ${fontSize}px Arial`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // Dark outline for contrast
            context.strokeStyle = 'rgba(0, 0, 0, 0.8)';
            context.lineWidth = 4;
            context.strokeText(text, canvas.width / 2, canvas.height / 2);
            
            // Main text color
            context.fillStyle = color;
            context.fillText(text, canvas.width / 2, canvas.height / 2);
            
            // Create sprite
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                depthTest: false,
                depthWrite: false
            });
            
            const sprite = new THREE.Sprite(spriteMaterial);
            
            // Scale sprite based on canvas aspect ratio
            const aspect = canvas.width / canvas.height;
            sprite.scale.set(aspect * 0.15, 0.15, 1);
            
            return sprite;
        }

        function createScaledTextSprite(text, color, position, scaleFactor = 1) {
            const sprite = createTextSprite(text, color);
            sprite.position.copy(position);
            
            // Scale using power of 0.7 - keeps large model labels the same, shrinks small model labels more
            if (currentModel) {
                const box = new THREE.Box3().setFromObject(currentModel);
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                sprite.scale.multiplyScalar(Math.pow(maxDim, 0.7) * 0.085 * scaleFactor * textSizeMultiplier);
            }
            
            return sprite;
        }

        // ============ Tool Selection ============
        function setTool(tool) {
            // Clear previous tool state
            clearTempDrawing();
            
            // If switching away from measure tool, clear all measurements
            if (currentTool === 'measure' && tool !== 'measure') {
                clearAllMeasurements();
                measurementDisplay.classList.remove('visible');
            }
            
            // If switching away from surface tool, clear temp surface
            if (currentTool === 'surface' && tool !== 'surface') {
                clearTempSurface();
                brushDisplay.classList.remove('visible');
            }

            if (currentTool === tool) {
                // If clicking same tool, deactivate it
                if (currentTool === 'measure') {
                    clearAllMeasurements();
                }
                if (currentTool === 'surface') {
                    clearTempSurface();
                }
                currentTool = null;
                canvas.style.cursor = 'default';
                measurementDisplay.classList.remove('visible');
                brushDisplay.classList.remove('visible');
            } else {
                currentTool = tool;
                canvas.style.cursor = 'crosshair';
            }

            // Update button states
            btnPoint.classList.toggle('active', currentTool === 'point');
            btnLine.classList.toggle('active', currentTool === 'line');
            btnPolygon.classList.toggle('active', currentTool === 'polygon');
            btnSurface.classList.toggle('active', currentTool === 'surface');
            btnMeasure.classList.toggle('active', currentTool === 'measure');

            if (currentTool === 'measure') {
                measurementDisplay.classList.add('visible');
                updateMeasurementsDisplay();
            }
            
            if (currentTool === 'surface') {
                brushDisplay.classList.add('visible');
                // Change right-click from pan to rotate for easier multi-angle painting
                controls.mouseButtons.RIGHT = THREE.MOUSE.ROTATE;
            } else {
                // Restore default right-click = pan behavior
                controls.mouseButtons.RIGHT = THREE.MOUSE.PAN;
            }

            updateInstructions();
        }

        function updateInstructions() {
            const instr = document.getElementById('instructions');
            let text = '<strong>Controls:</strong> Left-drag rotate · Right-drag pan · Scroll zoom';
            
            if (currentTool === 'point') {
                text = '<strong>Point:</strong> Click on model to place point';
            } else if (currentTool === 'line') {
                text = '<strong>Line:</strong> Click to add points · Double-click to finish';
            } else if (currentTool === 'polygon') {
                text = '<strong>Polygon:</strong> Click to add points · Double-click to close';
            } else if (currentTool === 'surface') {
                text = '<strong>Surface:</strong> Click/drag to paint · Right-drag to rotate · Hold Shift to erase · Double-click to finish';
            } else if (currentTool === 'measure') {
                text = '<strong>Measure:</strong> Click two points to measure distance';
            }
            
            instr.innerHTML = text;
        }

        function clearTempDrawing() {
            tempPoints = [];
            tempProjectedEdges = [];
            if (tempLine) {
                if (tempLine.geometry) tempLine.geometry.dispose();
                if (tempLine.material) tempLine.material.dispose();
                annotationObjects.remove(tempLine);
                tempLine = null;
            }
            // Only clear in-progress measurement points, not saved measurements
            measurePoints = [];
            measureMarkers.forEach(m => {
                if (m.geometry) m.geometry.dispose();
                if (m.material) m.material.dispose();
                annotationObjects.remove(m);
            });
            measureMarkers = [];
            if (measureLine) {
                if (measureLine.geometry) measureLine.geometry.dispose();
                if (measureLine.material) measureLine.material.dispose();
                annotationObjects.remove(measureLine);
                measureLine = null;
            }
            // Clear temp surface painting
            clearTempSurface();
        }

        // ============ Surface Painting ============
        function clearTempSurface() {
            paintedFaces.clear();
            isPaintingSurface = false;
            surfaceHighlightDirty = false;
            if (surfaceHighlightRAF) {
                cancelAnimationFrame(surfaceHighlightRAF);
                surfaceHighlightRAF = null;
            }
            if (surfaceHighlightMesh) {
                annotationObjects.remove(surfaceHighlightMesh);
                surfaceHighlightMesh.geometry.dispose();
                surfaceHighlightMesh.material.dispose();
                surfaceHighlightMesh = null;
            }
        }

        /**
         * Raycasts from a mouse event to the model surface, returning the hit point,
         * face index, and mesh reference. Used by the surface painting tool.
         * @param {MouseEvent} event - The mouse event with clientX/clientY
         * @returns {{point: THREE.Vector3, faceIndex: number, mesh: THREE.Mesh}|null}
         */
        function getIntersectionWithFace(event) {
            if (!currentModel) return null;

            const rect = canvas.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(modelMeshes, false);

            if (intersects.length > 0) {
                return {
                    point: intersects[0].point.clone(),
                    faceIndex: intersects[0].faceIndex,
                    mesh: intersects[0].object
                };
            }
            return null;
        }

        /**
         * Paints or erases faces within the brush radius around a point on the mesh surface.
         * Uses BVH shapecast for fast spatial queries — a bounding sphere in local mesh space
         * is tested against the BVH tree to find all triangles within the brush radius,
         * avoiding expensive per-face distance checks.
         * Hold Shift to erase (remove faces from paintedFaces set).
         * @param {THREE.Vector3} point - World-space point where the brush is centered
         * @param {THREE.Mesh} mesh - The mesh being painted on
         * @param {number} faceIndex - Index of the face directly under the cursor
         */
        function paintAtPoint(point, mesh, faceIndex) {
            if (!mesh || !mesh.geometry) return;

            const brushRadius = (surfaceBrushSize / 100) * modelBoundingSize;
            const geometry = mesh.geometry;
            const position = geometry.attributes.position;
            const meshIndex = modelMeshes.indexOf(mesh);
            
            // Use BVH shapecast for fast spatial query if available
            if (geometry.boundsTree) {
                // Transform brush center to local space
                const invMatrix = new THREE.Matrix4().copy(mesh.matrixWorld).invert();
                const localCenter = point.clone().applyMatrix4(invMatrix);
                
                // Compute local-space brush radius (account for non-uniform scale)
                const scale = new THREE.Vector3();
                mesh.matrixWorld.decompose(new THREE.Vector3(), new THREE.Quaternion(), scale);
                const avgScale = (scale.x + scale.y + scale.z) / 3;
                const localRadius = brushRadius / avgScale;
                
                const localRadiusSq = localRadius * localRadius;
                
                geometry.boundsTree.shapecast({
                    intersectsBounds: (box) => {
                        // Quick AABB vs sphere test
                        const closestPoint = new THREE.Vector3();
                        box.clampPoint(localCenter, closestPoint);
                        return closestPoint.distanceToSquared(localCenter) <= localRadiusSq;
                    },
                    intersectsTriangle: (triangle, triIndex) => {
                        // Check face center distance
                        const faceCenter = new THREE.Vector3()
                            .addVectors(triangle.a, triangle.b)
                            .add(triangle.c)
                            .divideScalar(3);
                        
                        if (faceCenter.distanceToSquared(localCenter) <= localRadiusSq) {
                            const faceId = `${meshIndex}_${triIndex}`;
                            if (isErasingMode) {
                                paintedFaces.delete(faceId);
                            } else {
                                paintedFaces.add(faceId);
                            }
                        }
                        return false; // Continue traversal
                    }
                });
            } else {
                // Fallback: brute-force for geometries without BVH
                const faceCount = geometry.index 
                    ? geometry.index.count / 3 
                    : position.count / 3;

                for (let i = 0; i < faceCount; i++) {
                    let a, b, c;
                    if (geometry.index) {
                        a = geometry.index.getX(i * 3);
                        b = geometry.index.getX(i * 3 + 1);
                        c = geometry.index.getX(i * 3 + 2);
                    } else {
                        a = i * 3;
                        b = i * 3 + 1;
                        c = i * 3 + 2;
                    }

                    const vA = new THREE.Vector3().fromBufferAttribute(position, a);
                    const vB = new THREE.Vector3().fromBufferAttribute(position, b);
                    const vC = new THREE.Vector3().fromBufferAttribute(position, c);
                    vA.applyMatrix4(mesh.matrixWorld);
                    vB.applyMatrix4(mesh.matrixWorld);
                    vC.applyMatrix4(mesh.matrixWorld);

                    const faceCenter = new THREE.Vector3()
                        .addVectors(vA, vB)
                        .add(vC)
                        .divideScalar(3);

                    if (faceCenter.distanceTo(point) <= brushRadius) {
                        const faceId = `${meshIndex}_${i}`;
                        if (isErasingMode) {
                            paintedFaces.delete(faceId);
                        } else {
                            paintedFaces.add(faceId);
                        }
                    }
                }
            }

            // Schedule throttled highlight update (batches rapid paint strokes)
            scheduleSurfaceHighlight();
        }

        function scheduleSurfaceHighlight() {
            surfaceHighlightDirty = true;
            if (!surfaceHighlightRAF) {
                surfaceHighlightRAF = requestAnimationFrame(() => {
                    surfaceHighlightRAF = null;
                    if (surfaceHighlightDirty) {
                        surfaceHighlightDirty = false;
                        updateSurfaceHighlight();
                    }
                });
            }
        }

        /**
         * Rebuilds the visual highlight mesh for all currently painted faces.
         * Groups faces by source mesh, extracts triangle vertices in world space,
         * and creates a single semi-transparent BufferGeometry overlay.
         * Throttled via requestAnimationFrame to run at most once per frame.
         */
        function updateSurfaceHighlight() {
            // Remove old highlight mesh
            if (surfaceHighlightMesh) {
                annotationObjects.remove(surfaceHighlightMesh);
                surfaceHighlightMesh.geometry.dispose();
                surfaceHighlightMesh.material.dispose();
                surfaceHighlightMesh = null;
            }

            if (paintedFaces.size === 0) return;

            // Group faces by mesh index
            const facesByMesh = new Map();
            paintedFaces.forEach(faceId => {
                const [meshIdx, faceIdx] = faceId.split('_');
                if (!facesByMesh.has(meshIdx)) {
                    facesByMesh.set(meshIdx, []);
                }
                facesByMesh.set(meshIdx, [...facesByMesh.get(meshIdx), parseInt(faceIdx)]);
            });

            // Build combined geometry
            const vertices = [];
            
            facesByMesh.forEach((faceIndices, meshIdx) => {
                const mesh = modelMeshes[parseInt(meshIdx)];
                if (!mesh) return;

                const geometry = mesh.geometry;
                const position = geometry.attributes.position;

                faceIndices.forEach(faceIdx => {
                    let a, b, c;
                    if (geometry.index) {
                        a = geometry.index.getX(faceIdx * 3);
                        b = geometry.index.getX(faceIdx * 3 + 1);
                        c = geometry.index.getX(faceIdx * 3 + 2);
                    } else {
                        a = faceIdx * 3;
                        b = faceIdx * 3 + 1;
                        c = faceIdx * 3 + 2;
                    }

                    const vA = new THREE.Vector3().fromBufferAttribute(position, a);
                    const vB = new THREE.Vector3().fromBufferAttribute(position, b);
                    const vC = new THREE.Vector3().fromBufferAttribute(position, c);

                    // Apply mesh world transform
                    vA.applyMatrix4(mesh.matrixWorld);
                    vB.applyMatrix4(mesh.matrixWorld);
                    vC.applyMatrix4(mesh.matrixWorld);

                    vertices.push(vA.x, vA.y, vA.z);
                    vertices.push(vB.x, vB.y, vB.z);
                    vertices.push(vC.x, vC.y, vC.z);
                });
            });

            if (vertices.length === 0) return;

            // Create highlight geometry
            const highlightGeometry = new THREE.BufferGeometry();
            highlightGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            highlightGeometry.computeVertexNormals();

            // Get current group color or use default gold
            const color = groups.length > 0 ? groups[0].color : '#EDC040';

            const highlightMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide,
                depthTest: true,
                depthWrite: false,
                polygonOffset: true,
                polygonOffsetFactor: -4,
                polygonOffsetUnits: -4
            });

            surfaceHighlightMesh = new THREE.Mesh(highlightGeometry, highlightMaterial);
            surfaceHighlightMesh.renderOrder = 999;
            annotationObjects.add(surfaceHighlightMesh);
        }

        /**
         * Completes a surface painting session: calculates the centroid of all painted faces,
         * stores the face data (mesh index + face index pairs), and opens the annotation popup.
         * The painted faces are stored as a serializable format for export/import.
         * @param {MouseEvent} event - The double-click event that triggered completion
         */
        function finishSurfacePainting(event) {
            if (paintedFaces.size === 0) {
                showStatus('No surface painted');
                clearTempSurface();
                return;
            }

            // Calculate center point from all painted faces
            const center = new THREE.Vector3();
            let count = 0;

            paintedFaces.forEach(faceId => {
                const [meshIdx, faceIdx] = faceId.split('_');
                const mesh = modelMeshes[parseInt(meshIdx)];
                if (!mesh) return;

                const geometry = mesh.geometry;
                const position = geometry.attributes.position;
                const idx = parseInt(faceIdx);

                let a, b, c;
                if (geometry.index) {
                    a = geometry.index.getX(idx * 3);
                    b = geometry.index.getX(idx * 3 + 1);
                    c = geometry.index.getX(idx * 3 + 2);
                } else {
                    a = idx * 3;
                    b = idx * 3 + 1;
                    c = idx * 3 + 2;
                }

                const vA = new THREE.Vector3().fromBufferAttribute(position, a);
                const vB = new THREE.Vector3().fromBufferAttribute(position, b);
                const vC = new THREE.Vector3().fromBufferAttribute(position, c);

                vA.applyMatrix4(mesh.matrixWorld);
                vB.applyMatrix4(mesh.matrixWorld);
                vC.applyMatrix4(mesh.matrixWorld);

                const faceCenter = new THREE.Vector3()
                    .addVectors(vA, vB)
                    .add(vC)
                    .divideScalar(3);

                center.add(faceCenter);
                count++;
            });

            center.divideScalar(count);

            // Store face IDs as the "points" data for surface annotations
            const faceData = Array.from(paintedFaces);

            // Open popup with center point
            openAnnotationPopup(event, 'surface', [center], faceData);
            
            // Clear temp highlight (will be re-rendered as annotation)
            if (surfaceHighlightMesh) {
                annotationObjects.remove(surfaceHighlightMesh);
                surfaceHighlightMesh.geometry.dispose();
                surfaceHighlightMesh.material.dispose();
                surfaceHighlightMesh = null;
            }
            paintedFaces.clear();
            isPaintingSurface = false;
        }

        // ============ Raycasting ============
        /**
         * Raycasts from a mouse event to the model surface, returning the world-space hit point.
         * Used by point, line, polygon, and measurement tools.
         * @param {MouseEvent} event - The mouse event with clientX/clientY
         * @returns {THREE.Vector3|null} World-space intersection point, or null if no hit
         */
        function getIntersection(event) {
            if (!currentModel) return null;

            const rect = canvas.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(currentModel, true);

            return intersects.length > 0 ? intersects[0].point.clone() : null;
        }

        // ============ Surface Projection (BVH) ============
        /**
         * Projects a straight line between two points onto the mesh surface.
         * Uses BVH closestPointToPoint for robust, direction-independent projection.
         * @param {THREE.Vector3} pointA - Start point (world coordinates)
         * @param {THREE.Vector3} pointB - End point (world coordinates)
         * @param {number} segments - Number of intermediate sample points
         * @returns {Array<{x,y,z}>|null} - Array of surface-projected points, or null if no mesh
         */
        function projectEdgeToSurface(pointA, pointB, segments = 30) {
            if (modelMeshes.length === 0) return null;
            
            const projectedPoints = [];
            const tempPoint = new THREE.Vector3();
            const localPoint = new THREE.Vector3();
            const invMatrix = new THREE.Matrix4();
            
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                tempPoint.lerpVectors(pointA, pointB, t);
                
                let bestDistance = Infinity;
                let bestPoint = null;
                
                for (const mesh of modelMeshes) {
                    if (!mesh.geometry.boundsTree) continue;
                    
                    // Transform point to geometry's local space
                    invMatrix.copy(mesh.matrixWorld).invert();
                    localPoint.copy(tempPoint).applyMatrix4(invMatrix);
                    
                    const target = { point: new THREE.Vector3(), distance: 0, faceIndex: 0 };
                    const result = mesh.geometry.boundsTree.closestPointToPoint(localPoint, target);
                    
                    if (result && result.distance < bestDistance) {
                        bestDistance = result.distance;
                        bestPoint = result.point.clone().applyMatrix4(mesh.matrixWorld);
                    }
                }
                
                if (bestPoint) {
                    projectedPoints.push({ x: bestPoint.x, y: bestPoint.y, z: bestPoint.z });
                } else {
                    projectedPoints.push({ x: tempPoint.x, y: tempPoint.y, z: tempPoint.z });
                }
            }
            
            return projectedPoints;
        }

        /**
         * Measures the maximum perpendicular deviation of projected points from
         * the straight line between pointA and pointB.
         * @returns {number} Maximum deviation as fraction of edge length (0 = no deviation)
         */
        /**
         * Checks whether a projected edge stays close enough to the straight line.
         * Uses two limits (whichever is stricter wins):
         *  - Relative: max deviation as fraction of edge length (handles short edges)
         *  - Absolute: max deviation as fraction of model size (catches long edges over rubble)
         * @returns {boolean} true if projection is acceptable
         */
        function isProjectionAcceptable(projectedPoints, pointA, pointB) {
            const lineDir = new THREE.Vector3().subVectors(pointB, pointA);
            const lineLength = lineDir.length();
            if (lineLength < 1e-10) return true;
            lineDir.normalize();
            
            // Compute allowed deviation: minimum of relative and absolute limit
            const relativeLimit = projectionDeviationRelative * lineLength;
            const absoluteLimit = projectionDeviationAbsolute * modelBoundingSize;
            const maxAllowed = Math.min(relativeLimit, absoluteLimit);
            
            const toPoint = new THREE.Vector3();
            const closestOnLine = new THREE.Vector3();
            
            for (const p of projectedPoints) {
                toPoint.set(p.x, p.y, p.z).sub(pointA);
                const t = Math.max(0, Math.min(lineLength, toPoint.dot(lineDir)));
                closestOnLine.copy(pointA).addScaledVector(lineDir, t);
                const deviation = closestOnLine.distanceTo(new THREE.Vector3(p.x, p.y, p.z));
                if (deviation > maxAllowed) return false; // Early exit
            }
            
            return true;
        }

        /**
         * Computes projected edges for all consecutive point pairs.
         * @param {Array<{x,y,z}>} points - The user-clicked corner points
         * @param {boolean} closePolygon - Whether to add a closing edge (last→first)
         * @param {number} segments - Segments per edge
         * @returns {Array<Array<{x,y,z}>>} - Array of projected edge arrays
         */
        function computeProjectedEdges(points, closePolygon = false, segments = 30) {
            const edges = [];
            const vec3Points = points.map(p => new THREE.Vector3(p.x, p.y, p.z));
            
            for (let i = 0; i < vec3Points.length - 1; i++) {
                const projected = projectEdgeToSurface(vec3Points[i], vec3Points[i + 1], segments);
                if (projected && isProjectionAcceptable(projected, vec3Points[i], vec3Points[i + 1])) {
                    edges.push(projected);
                } else {
                    edges.push([points[i], points[i + 1]]); // Fallback: straight line
                }
            }
            
            if (closePolygon && vec3Points.length > 2) {
                const lastEdge = projectEdgeToSurface(
                    vec3Points[vec3Points.length - 1], vec3Points[0], segments
                );
                if (lastEdge && isProjectionAcceptable(lastEdge, vec3Points[vec3Points.length - 1], vec3Points[0])) {
                    edges.push(lastEdge);
                } else {
                    edges.push([points[points.length - 1], points[0]]);
                }
            }
            
            return edges;
        }

        /**
         * Recomputes only the edges adjacent to a moved point.
         * @param {Object} ann - The annotation object
         * @param {number} pointIndex - Index of the moved point
         */
        function recomputeAdjacentEdges(ann, pointIndex) {
            if (!ann.projectedEdges) return;
            const n = ann.points.length;
            const vec3Points = ann.points.map(p => new THREE.Vector3(p.x, p.y, p.z));
            
            // Edge from previous point to this point
            const prevIdx = (ann.type === 'polygon') 
                ? (pointIndex - 1 + n) % n 
                : pointIndex - 1;
            if (prevIdx >= 0 && prevIdx < n) {
                const edgeIdx = (ann.type === 'polygon') ? prevIdx : prevIdx;
                if (edgeIdx < ann.projectedEdges.length) {
                    const projected = projectEdgeToSurface(vec3Points[prevIdx], vec3Points[pointIndex], 15);
                    if (projected && isProjectionAcceptable(projected, vec3Points[prevIdx], vec3Points[pointIndex])) {
                        ann.projectedEdges[edgeIdx] = projected;
                    } else {
                        ann.projectedEdges[edgeIdx] = [ann.points[prevIdx], ann.points[pointIndex]];
                    }
                }
            }
            
            // Edge from this point to next point
            const nextIdx = pointIndex + 1;
            if (nextIdx < n) {
                const edgeIdx = pointIndex;
                if (edgeIdx < ann.projectedEdges.length) {
                    const projected = projectEdgeToSurface(vec3Points[pointIndex], vec3Points[nextIdx], 15);
                    if (projected && isProjectionAcceptable(projected, vec3Points[pointIndex], vec3Points[nextIdx])) {
                        ann.projectedEdges[edgeIdx] = projected;
                    } else {
                        ann.projectedEdges[edgeIdx] = [ann.points[pointIndex], ann.points[nextIdx]];
                    }
                }
            } else if (ann.type === 'polygon' && pointIndex === n - 1) {
                // Closing edge of polygon: last → first
                const closingIdx = ann.projectedEdges.length - 1;
                const projected = projectEdgeToSurface(vec3Points[pointIndex], vec3Points[0], 15);
                if (projected && isProjectionAcceptable(projected, vec3Points[pointIndex], vec3Points[0])) {
                    ann.projectedEdges[closingIdx] = projected;
                } else {
                    ann.projectedEdges[closingIdx] = [ann.points[pointIndex], ann.points[0]];
                }
            }
        }

        /**
         * Re-projects all line/polygon annotations onto the current model surface.
         * Call after importing annotations or loading a new model.
         */
        function reprojectAllAnnotations() {
            if (modelMeshes.length === 0 || !surfaceProjectionEnabled) return;
            
            let count = 0;
            annotations.forEach(ann => {
                if ((ann.type === 'line' || ann.type === 'polygon') && ann.points.length >= 2 && ann.surfaceProjection !== false) {
                    ann.projectedEdges = computeProjectedEdges(ann.points, ann.type === 'polygon');
                    ann.surfaceProjection = true;
                    count++;
                }
            });
            
            if (count > 0) {
                renderAnnotations();
                showStatus(`Re-projected ${count} annotations onto surface`);
            }
        }

        // ============ Canvas Events ============
        function onCanvasClick(event) {
            // Prevent click event right after dragging
            if (wasDragging) {
                wasDragging = false;
                return;
            }
            
            if (!currentTool || !currentModel) return;

            const point = getIntersection(event);
            if (!point) return;

            if (currentTool === 'point') {
                // Use position captured on mousedown to prevent slipping
                const pointToUse = pendingPointPosition || point;
                pendingPointPosition = null;
                if (!pointToUse) return;
                openAnnotationPopup(event, 'point', [pointToUse]);
                setTool(null);
            } else if (currentTool === 'line') {
                tempPoints.push(point);
                updateTempLine();
            } else if (currentTool === 'polygon') {
                tempPoints.push(point);
                updateTempLine();
            } else if (currentTool === 'measure') {
                measurePoints.push(point);
                addMeasureMarker(point);
                
                if (measurePoints.length === 2) {
                    const dist = measurePoints[0].distanceTo(measurePoints[1]);
                    
                    // Create the line
                    updateMeasureLine();
                    
                    // Create label at midpoint
                    const midpoint = new THREE.Vector3().addVectors(measurePoints[0], measurePoints[1]).multiplyScalar(0.5);
                    const labelText = `${dist.toFixed(3)} units`;
                    const label = createScaledTextSprite(labelText, '#AA8101', midpoint, 0.5);
                    annotationObjects.add(label);
                    
                    // Store this measurement
                    const measurementId = measurements.length + 1;
                    measurements.push({
                        id: measurementId,
                        distance: dist,
                        markers: [...measureMarkers],
                        line: measureLine,
                        label: label
                    });
                    
                    // Update display
                    updateMeasurementsDisplay();
                    
                    // Reset for next measurement but keep existing ones
                    measurePoints = [];
                    measureMarkers = [];
                    measureLine = null;
                }
            } else if (currentTool === 'surface') {
                // Surface painting is handled by mousedown/mousemove
                // Single click just paints at that point
                isErasingMode = event.shiftKey;
                const hitInfo = getIntersectionWithFace(event);
                if (hitInfo) {
                    paintAtPoint(hitInfo.point, hitInfo.mesh, hitInfo.faceIndex);
                }
            }
        }

        function onCanvasDblClick(event) {
            if (!currentModel) return;

            const point = getIntersection(event);

            if (currentTool === 'line' && tempPoints.length >= 2) {
                openAnnotationPopup(event, 'line', [...tempPoints]);
                setTool(null);
            } else if (currentTool === 'polygon' && tempPoints.length >= 3) {
                openAnnotationPopup(event, 'polygon', [...tempPoints]);
                setTool(null);
            } else if (currentTool === 'surface' && paintedFaces.size > 0) {
                finishSurfacePainting(event);
                setTool(null);
            }
        }

        function onCanvasMouseDown(event) {
            // Handle point tool - capture position on mousedown to prevent slipping
            if (currentTool === 'point' && currentModel && event.button === 0) {
                pendingPointPosition = getIntersection(event);
                return;
            }
            
            // Handle surface painting - only on left click (button 0)
            // Right click (button 2) allows panning to rotate view while painting
            if (currentTool === 'surface' && currentModel && event.button === 0) {
                isPaintingSurface = true;
                isErasingMode = event.shiftKey;
                controls.enabled = false; // Disable orbit during painting
                
                const hitInfo = getIntersectionWithFace(event);
                if (hitInfo) {
                    paintAtPoint(hitInfo.point, hitInfo.mesh, hitInfo.faceIndex);
                }
                return;
            }
            
            if (!currentModel || currentTool) return; // Don't drag when a tool is active
            
            const rect = canvas.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            // Check for intersection with annotation markers
            const markerObjects = annotationObjects.children.filter(obj => 
                obj.userData.isAnnotationMarker && obj.isMesh
            );
            
            const intersects = raycaster.intersectObjects(markerObjects);
            
            if (intersects.length > 0) {
                const marker = intersects[0].object;
                const annId = marker.userData.annotationId;
                const pointIndex = marker.userData.pointIndex;
                
                draggedAnnotation = annotations.find(a => a.id === annId);
                if (draggedAnnotation) {
                    isDraggingPoint = true;
                    draggedPointIndex = pointIndex;
                    draggedMarker = marker;
                    controls.enabled = false; // Disable orbit controls during drag
                    canvas.style.cursor = 'grabbing';
                }
            }
        }

        function onCanvasMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );
            
            // Handle surface painting
            if (isPaintingSurface && currentTool === 'surface' && currentModel) {
                isErasingMode = event.shiftKey;
                const hitInfo = getIntersectionWithFace(event);
                if (hitInfo) {
                    paintAtPoint(hitInfo.point, hitInfo.mesh, hitInfo.faceIndex);
                }
                return;
            }
            
            // Handle active dragging
            if (isDraggingPoint && draggedMarker && currentModel) {
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);
                
                const intersects = raycaster.intersectObject(currentModel, true);
                
                if (intersects.length > 0) {
                    const newPos = intersects[0].point;
                    draggedMarker.position.copy(newPos);
                    
                    // Update the annotation data in real-time for visual feedback
                    if (draggedAnnotation && draggedPointIndex >= 0) {
                        draggedAnnotation.points[draggedPointIndex] = {
                            x: newPos.x,
                            y: newPos.y,
                            z: newPos.z
                        };
                        
                        // Recompute adjacent projected edges (uses fewer segments for responsiveness)
                        if (draggedAnnotation.projectedEdges && draggedAnnotation.surfaceProjection) {
                            recomputeAdjacentEdges(draggedAnnotation, draggedPointIndex);
                        }
                        
                        // Re-render to update lines/polygons
                        renderAnnotations();
                        
                        // Re-find the marker after re-render
                        const markers = annotationObjects.children.filter(obj => 
                            obj.userData.isAnnotationMarker && 
                            obj.userData.annotationId === draggedAnnotation.id &&
                            obj.userData.pointIndex === draggedPointIndex
                        );
                        if (markers.length > 0) {
                            draggedMarker = markers[0];
                        }
                    }
                }
                return;
            }
            
            // Handle hover cursor when not dragging and no tool active
            if (!currentTool && currentModel) {
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);
                
                const markerObjects = annotationObjects.children.filter(obj => 
                    obj.userData.isAnnotationMarker && obj.isMesh
                );
                
                const intersects = raycaster.intersectObjects(markerObjects);
                
                if (intersects.length > 0) {
                    canvas.style.cursor = 'grab';
                } else {
                    canvas.style.cursor = 'default';
                }
            }
        }

        function onCanvasMouseUp(event) {
            // Handle surface painting stop
            if (isPaintingSurface) {
                isPaintingSurface = false;
                controls.enabled = true; // Re-enable orbit controls
            }
            
            if (isDraggingPoint) {
                wasDragging = true; // Prevent click event
                
                // Full-quality recompute of all projected edges after drag
                if (draggedAnnotation && draggedAnnotation.surfaceProjection && 
                    (draggedAnnotation.type === 'line' || draggedAnnotation.type === 'polygon')) {
                    draggedAnnotation.projectedEdges = computeProjectedEdges(
                        draggedAnnotation.points, 
                        draggedAnnotation.type === 'polygon'
                    );
                }
                
                isDraggingPoint = false;
                draggedAnnotation = null;
                draggedPointIndex = -1;
                draggedMarker = null;
                controls.enabled = true; // Re-enable orbit controls
                canvas.style.cursor = 'default';
                
                // Final render and update UI
                renderAnnotations();
                updateGroupsList();
                showStatus('Point moved');
            }
        }

        function updateTempLine() {
            if (tempLine) {
                annotationObjects.remove(tempLine);
            }

            if (tempPoints.length < 2) return;

            const positions = [];
            
            if (surfaceProjectionEnabled && modelMeshes.length > 0) {
                // Surface-projected preview
                for (let i = 0; i < tempPoints.length - 1; i++) {
                    let edgePoints;
                    if (i < tempProjectedEdges.length && tempProjectedEdges[i]) {
                        // Use cached projection for completed edges
                        edgePoints = tempProjectedEdges[i];
                    } else {
                        // Compute projection for latest edge (fewer segments for responsiveness)
                        const projected = projectEdgeToSurface(tempPoints[i], tempPoints[i + 1], 20);
                        const straightFallback = [
                            { x: tempPoints[i].x, y: tempPoints[i].y, z: tempPoints[i].z },
                            { x: tempPoints[i + 1].x, y: tempPoints[i + 1].y, z: tempPoints[i + 1].z }
                        ];
                        // Check deviation threshold
                        if (projected && isProjectionAcceptable(projected, tempPoints[i], tempPoints[i + 1])) {
                            edgePoints = projected;
                        } else {
                            edgePoints = straightFallback;
                        }
                        // Cache completed edges (not the last one, which may change)
                        if (i < tempPoints.length - 2) {
                            tempProjectedEdges[i] = edgePoints;
                        }
                    }
                    // Add points, skip first point of subsequent edges to avoid duplicates
                    const startIdx = (i === 0) ? 0 : 1;
                    for (let j = startIdx; j < edgePoints.length; j++) {
                        positions.push(edgePoints[j].x, edgePoints[j].y, edgePoints[j].z);
                    }
                }
            } else {
                // Classic straight-line preview
                tempPoints.forEach(p => positions.push(p.x, p.y, p.z));
            }

            const geometry = new LineGeometry();
            geometry.setPositions(positions);

            const material = new LineMaterial({
                color: 0xEDC040,
                linewidth: 3,
                resolution: new THREE.Vector2(window.innerWidth - 320, window.innerHeight - 50),
                polygonOffset: true,
                polygonOffsetFactor: -4,
                polygonOffsetUnits: -4
            });

            tempLine = new Line2(geometry, material);
            annotationObjects.add(tempLine);
        }

        function addMeasureMarker(point) {
            const geometry = new THREE.SphereGeometry(0.01, 16, 16);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xFFFFFF,  // White for contrast
                depthTest: true,
                polygonOffset: true,
                polygonOffsetFactor: -5,
                polygonOffsetUnits: -5
            });
            const marker = new THREE.Mesh(geometry, material);
            marker.position.copy(point);
            marker.renderOrder = 1000;  // Render on top
            
            if (currentModel) {
                const box = new THREE.Box3().setFromObject(currentModel);
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                marker.scale.setScalar(Math.pow(maxDim, 0.8) * 0.05 * pointSizeMultiplier);  // Larger markers
            }

            annotationObjects.add(marker);
            measureMarkers.push(marker);
        }

        function updateMeasureLine() {
            if (measureLine) {
                annotationObjects.remove(measureLine);
            }

            if (measurePoints.length !== 2) return;

            const positions = [
                measurePoints[0].x, measurePoints[0].y, measurePoints[0].z,
                measurePoints[1].x, measurePoints[1].y, measurePoints[1].z
            ];

            const geometry = new LineGeometry();
            geometry.setPositions(positions);

            const material = new LineMaterial({
                color: 0xAA8101,
                linewidth: 3,
                resolution: new THREE.Vector2(window.innerWidth - 320, window.innerHeight - 50),
                polygonOffset: true,
                polygonOffsetFactor: -4,
                polygonOffsetUnits: -4
            });

            measureLine = new Line2(geometry, material);
            annotationObjects.add(measureLine);
        }

        function updateMeasurementsDisplay() {
            if (measurements.length === 0) {
                measurementsList.innerHTML = '<div style="color: #888;">No measurements yet</div>';
            } else {
                measurementsList.innerHTML = measurements.map(m => `
                    <div class="measurement-item">
                        <span class="label">Distance ${m.id}:</span>
                        <span class="value">${m.distance.toFixed(3)} units</span>
                    </div>
                `).join('');
            }
        }

        function clearAllMeasurements() {
            // Clear current in-progress measurement
            measurePoints = [];
            measureMarkers.forEach(m => {
                if (m.geometry) m.geometry.dispose();
                if (m.material) m.material.dispose();
                annotationObjects.remove(m);
            });
            measureMarkers = [];
            if (measureLine) {
                if (measureLine.geometry) measureLine.geometry.dispose();
                if (measureLine.material) measureLine.material.dispose();
                annotationObjects.remove(measureLine);
                measureLine = null;
            }
            
            // Clear all saved measurements
            measurements.forEach(m => {
                m.markers.forEach(marker => {
                    if (marker.geometry) marker.geometry.dispose();
                    if (marker.material) marker.material.dispose();
                    annotationObjects.remove(marker);
                });
                if (m.line) {
                    if (m.line.geometry) m.line.geometry.dispose();
                    if (m.line.material) m.line.material.dispose();
                    annotationObjects.remove(m.line);
                }
                if (m.label) {
                    if (m.label.material && m.label.material.map) m.label.material.map.dispose();
                    if (m.label.material) m.label.material.dispose();
                    annotationObjects.remove(m.label);
                }
            });
            measurements = [];
            
            updateMeasurementsDisplay();
        }

        // ============ Groups ============
        function createDefaultGroup() {
            if (groups.length === 0) {
                groups.push({
                    id: Date.now(),
                    uuid: generateUUID(),
                    name: 'Default',
                    color: '#EDC040',
                    visible: true
                });
                updateGroupsList();
            }
        }

        function openGroupPopup(group = null) {
            editingGroup = group;
            
            if (group) {
                groupPopupTitle.textContent = 'Edit Group';
                groupName.value = group.name;
                groupColor.value = group.color;
                btnGroupDelete.style.display = groups.length > 1 ? 'block' : 'none';
            } else {
                groupPopupTitle.textContent = 'New Group';
                groupName.value = '';
                groupColor.value = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
                btnGroupDelete.style.display = 'none';
            }

            groupPopup.classList.add('visible');
            groupName.focus();
        }

        function saveGroup() {
            const name = groupName.value.trim() || 'Unnamed Group';
            const color = groupColor.value;

            if (editingGroup) {
                editingGroup.name = name;
                editingGroup.color = color;
            } else {
                groups.push({
                    id: Date.now(),
                    uuid: generateUUID(),
                    name,
                    color,
                    visible: true
                });
            }

            groupPopup.classList.remove('visible');
            editingGroup = null;
            updateGroupsList();
            updateGroupSelect();
            renderAnnotations();
        }

        function deleteGroup(group) {
            if (groups.length <= 1) {
                showStatus('Cannot delete the last group');
                return;
            }

            // Move annotations to first other group
            const targetGroup = groups.find(g => g.id !== group.id);
            annotations.forEach(ann => {
                if (ann.groupId === group.id) {
                    ann.groupId = targetGroup.id;
                }
            });

            groups = groups.filter(g => g.id !== group.id);
            groupPopup.classList.remove('visible');
            editingGroup = null;
            updateGroupsList();
            updateGroupSelect();
            renderAnnotations();
        }

        function toggleGroupVisibility(group) {
            group.visible = !group.visible;
            updateGroupsList();
            renderAnnotations();
        }

        function updateGroupsList() {
            if (groups.length === 0) {
                noGroups.style.display = 'block';
                groupsContainer.innerHTML = '';
                return;
            }

            noGroups.style.display = 'none';
            
            groupsContainer.innerHTML = groups.map(group => {
                const groupAnnotations = annotations.filter(a => a.groupId === group.id);
                return `
                    <div class="group-item" data-id="${group.id}">
                        <div class="group-header">
                            <div class="group-color" style="background: ${group.color}" data-action="edit"></div>
                            <span class="group-name" data-action="edit">${escapeHtml(group.name)} (${groupAnnotations.length})</span>
                            <button class="group-visibility ${group.visible ? '' : 'hidden'}" data-action="visibility">
                                ${group.visible ? '👁' : '👁‍🗨'}
                            </button>
                            <div class="group-actions">
                                <button data-action="edit">✏️</button>
                            </div>
                        </div>
                        ${group.visible ? `
                            <div class="annotation-list">
                                ${groupAnnotations.map(ann => renderAnnotationItem(ann)).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');

            // Event listeners
            groupsContainer.querySelectorAll('.group-header').forEach(header => {
                header.addEventListener('click', (e) => {
                    const groupId = parseInt(header.closest('.group-item').dataset.id);
                    const group = groups.find(g => g.id === groupId);
                    const action = e.target.dataset.action || e.target.closest('[data-action]')?.dataset.action;

                    if (action === 'visibility') {
                        toggleGroupVisibility(group);
                    } else if (action === 'edit') {
                        openGroupPopup(group);
                    }
                });
            });

            // Annotation click handlers
            groupsContainer.querySelectorAll('.annotation-item').forEach(item => {
                item.addEventListener('click', () => {
                    const id = parseInt(item.dataset.id);
                    selectAnnotation(id);
                });
                item.addEventListener('dblclick', () => {
                    const id = parseInt(item.dataset.id);
                    const ann = annotations.find(a => a.id === id);
                    if (ann) openAnnotationPopupForEdit(ann);
                });
            });
        }

        function renderAnnotationItem(ann) {
            const icons = { point: '📍', line: '📏', polygon: '⬡', surface: '🎨' };
            const entryCount = (ann.entries && ann.entries.length) || 0;
            const entryText = entryCount === 1 ? '1 entry' : `${entryCount} entries`;
            return `
                <div class="annotation-item ${selectedAnnotation === ann.id ? 'selected' : ''}" data-id="${ann.id}">
                    <div class="header">
                        <span class="type-icon">${icons[ann.type] || '📍'}</span>
                        <span class="name">${escapeHtml(ann.name)}</span>
                    </div>
                    <div class="description">${entryText}</div>
                </div>
            `;
        }

        function updateGroupSelect() {
            annGroup.innerHTML = groups.map(g => 
                `<option value="${g.id}">${escapeHtml(g.name)}</option>`
            ).join('');
        }

        // ============ Annotations ============
        function openAnnotationPopup(event, type, points, faceData = null) {
            editingAnnotation = null;
            editingModelInfo = false;
            isAddingEntry = false;
            editingEntryId = null;
            pendingLinks = [];
            
            popupTitle.textContent = `New ${type.charAt(0).toUpperCase() + type.slice(1)}`;
            annName.value = '';
            annDescription.value = '';
            annAuthor.value = getLastAuthor();
            updateGroupSelect();
            updateLinksDisplay();
            btnPopupDelete.style.display = 'none';
            
            // Show name/group fields, new entry form, hide entries container
            document.getElementById('popup-main-fields').style.display = 'block';
            entriesContainer.style.display = 'none';
            newEntryForm.style.display = 'block';

            // Store temp data
            annotationPopup.dataset.type = type;
            annotationPopup.dataset.points = JSON.stringify(points.map(p => ({ x: p.x, y: p.y, z: p.z })));
            
            // Show surface projection toggle for line/polygon
            if ((type === 'line' || type === 'polygon') && surfaceProjectionEnabled) {
                surfaceProjectionToggle.style.display = 'block';
                annSurfaceProjection.checked = true;
            } else {
                surfaceProjectionToggle.style.display = 'none';
            }

            // Store face data for surface annotations
            if (faceData) {
                annotationPopup.dataset.faceData = JSON.stringify(faceData);
            } else {
                delete annotationPopup.dataset.faceData;
            }

            // For surface annotations, center the popup since double-click position is arbitrary
            if (type === 'surface') {
                resetPopupPosition();
            } else {
                positionPopup(annotationPopup, event.clientX, event.clientY);
            }
            annotationPopup.classList.add('visible');
            annName.focus();
        }

        function openAnnotationPopupForEdit(ann) {
            editingAnnotation = ann;
            editingModelInfo = false;
            isAddingEntry = false;
            editingEntryId = null;
            pendingLinks = [];

            popupTitle.textContent = `Edit ${ann.type.charAt(0).toUpperCase() + ann.type.slice(1)}`;
            annName.value = ann.name;
            updateGroupSelect();
            annGroup.value = ann.groupId;
            btnPopupDelete.style.display = 'block';

            annotationPopup.dataset.type = ann.type;
            annotationPopup.dataset.points = JSON.stringify(ann.points);

            // Show surface projection toggle for line/polygon
            if ((ann.type === 'line' || ann.type === 'polygon') && surfaceProjectionEnabled) {
                surfaceProjectionToggle.style.display = 'block';
                annSurfaceProjection.checked = ann.surfaceProjection !== false;
            } else {
                surfaceProjectionToggle.style.display = 'none';
            }

            // Show name/group fields, entries container, hide new entry form initially
            document.getElementById('popup-main-fields').style.display = 'block';
            entriesContainer.style.display = 'block';
            newEntryForm.style.display = 'none';
            
            // Render existing entries
            renderEntriesList(ann);

            resetPopupPosition();
            annotationPopup.classList.add('visible');
            annName.focus();
        }
        
        // ============ Model Information ============
        function openModelInfoPopup() {
            editingAnnotation = null;
            editingModelInfo = true;
            isAddingEntry = false;
            editingEntryId = null;
            pendingLinks = [];

            popupTitle.textContent = 'Model Information';
            
            // Hide name/group fields for model info
            document.getElementById('popup-main-fields').style.display = 'none';
            btnPopupDelete.style.display = 'none';

            // Show entries container
            entriesContainer.style.display = 'block';
            
            // Show new entry form if no entries exist, otherwise hide it
            if (modelInfo.entries.length === 0) {
                newEntryForm.style.display = 'block';
                annDescription.value = '';
                annAuthor.value = getLastAuthor();
                updateLinksDisplay();
            } else {
                newEntryForm.style.display = 'none';
            }
            
            // Render existing entries
            renderModelInfoEntriesList();

            resetPopupPosition();
            annotationPopup.classList.add('visible');
        }
        
        function renderModelInfoEntriesList() {
            const entries = modelInfo.entries || [];
            
            if (entries.length === 0) {
                entriesList.innerHTML = '<div style="color: #888; padding: 10px; text-align: center;">No entries yet. Add general information about this model.</div>';
                return;
            }
            
            entriesList.innerHTML = entries.map((entry, index) => {
                const date = new Date(entry.timestamp);
                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                const linksHtml = (entry.links && entry.links.length > 0) ? `
                    <div class="entry-card-links">
                        ${entry.links.map(link => `<a href="${escapeHtml(link)}" target="_blank">🔗 ${escapeHtml(link.split('/').pop() || link)}</a>`).join('')}
                    </div>
                ` : '';
                
                return `
                    <div class="entry-card" data-entry-id="${entry.id}">
                        <div class="entry-card-header">
                            <div class="entry-card-meta">
                                <span class="author">${escapeHtml(entry.author || 'Unknown')}</span> • ${dateStr}
                            </div>
                            <div class="entry-card-actions">
                                <button data-action="edit" data-entry-id="${entry.id}">✏️ Edit</button>
                                <button data-action="delete" data-entry-id="${entry.id}">🗑️</button>
                            </div>
                        </div>
                        <div class="entry-card-description">${escapeHtml(entry.description || '')}</div>
                        ${linksHtml}
                        <div class="entry-edit-form">
                            <textarea data-field="description">${escapeHtml(entry.description || '')}</textarea>
                            <input type="text" data-field="author" value="${escapeHtml(entry.author || '')}" placeholder="Author">
                            <div class="links-section">
                                <label>Links</label>
                                <div class="entry-links-list" data-entry-id="${entry.id}">
                                    ${(entry.links || []).map((link, li) => `
                                        <div class="link-item">
                                            <a href="${escapeHtml(link)}" target="_blank">${escapeHtml(link)}</a>
                                            <button data-link-index="${li}">✕</button>
                                        </div>
                                    `).join('')}
                                </div>
                                <div class="add-link-row">
                                    <input type="text" data-field="new-link" placeholder="https://...">
                                    <button class="btn-save" data-action="add-link">+</button>
                                </div>
                            </div>
                            <div class="entry-edit-buttons">
                                <button class="btn-cancel" data-action="cancel-edit">Cancel</button>
                                <button class="btn-save" data-action="save-edit">Save Entry</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Add event listeners for model info entries
            entriesList.querySelectorAll('.entry-card-actions button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const entryId = parseInt(btn.dataset.entryId);
                    const action = btn.dataset.action;
                    
                    if (action === 'edit') {
                        showConfirm('Are you sure you want to edit this entry instead of adding a new one?', () => {
                            startEditingModelInfoEntry(entryId);
                        });
                    } else if (action === 'delete') {
                        showConfirm('Are you sure you want to delete this entry? This cannot be undone.', () => {
                            deleteModelInfoEntry(entryId);
                        });
                    }
                });
            });
            
            // Entry edit form buttons
            entriesList.querySelectorAll('.entry-edit-form button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const action = btn.dataset.action;
                    const card = btn.closest('.entry-card');
                    const entryId = parseInt(card.dataset.entryId);
                    
                    if (action === 'cancel-edit') {
                        cancelEditingEntry();
                        renderModelInfoEntriesList();
                    } else if (action === 'save-edit') {
                        saveModelInfoEntryEdit(entryId, card);
                    } else if (action === 'add-link') {
                        const input = card.querySelector('[data-field="new-link"]');
                        const link = input.value.trim();
                        if (link) {
                            const entry = modelInfo.entries.find(en => en.id === entryId);
                            if (!entry.links) entry.links = [];
                            entry.links.push(link);
                            input.value = '';
                            renderModelInfoEntriesList();
                            startEditingModelInfoEntry(entryId);
                        }
                    }
                });
            });
            
            // Link delete buttons in edit mode
            entriesList.querySelectorAll('.entry-links-list button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const card = btn.closest('.entry-card');
                    const entryId = parseInt(card.dataset.entryId);
                    const linkIndex = parseInt(btn.dataset.linkIndex);
                    const entry = modelInfo.entries.find(en => en.id === entryId);
                    if (entry && entry.links) {
                        entry.links.splice(linkIndex, 1);
                        renderModelInfoEntriesList();
                        startEditingModelInfoEntry(entryId);
                    }
                });
            });
        }
        
        function startEditingModelInfoEntry(entryId) {
            editingEntryId = entryId;
            entriesList.querySelectorAll('.entry-card').forEach(card => {
                if (parseInt(card.dataset.entryId) === entryId) {
                    card.classList.add('editing');
                } else {
                    card.classList.remove('editing');
                }
            });
        }
        
        function saveModelInfoEntryEdit(entryId, card) {
            const entry = modelInfo.entries.find(en => en.id === entryId);
            if (!entry) return;
            
            const description = card.querySelector('[data-field="description"]').value.trim();
            const author = card.querySelector('[data-field="author"]').value.trim();
            
            entry.description = description;
            entry.author = author;
            entry.modified = new Date().toISOString();
            saveLastAuthor(author);
            
            editingEntryId = null;
            renderModelInfoEntriesList();
            updateModelInfoDisplay();
            showStatus('Entry updated');
        }
        
        function deleteModelInfoEntry(entryId) {
            modelInfo.entries = modelInfo.entries.filter(e => e.id !== entryId);
            renderModelInfoEntriesList();
            updateModelInfoDisplay();
            showStatus('Entry deleted');
        }
        
        function updateModelInfoDisplay() {
            const entryCount = modelInfo.entries.length;
            if (entryCount === 0) {
                modelInfoSubtitle.textContent = 'No entries yet';
            } else {
                modelInfoSubtitle.textContent = entryCount === 1 ? '1 entry' : `${entryCount} entries`;
            }
        }
        
        function renderEntriesList(ann) {
            const entries = ann.entries || [];
            
            if (entries.length === 0) {
                entriesList.innerHTML = '<div style="color: #888; padding: 10px; text-align: center;">No entries yet</div>';
                return;
            }
            
            entriesList.innerHTML = entries.map((entry, index) => {
                const date = new Date(entry.timestamp);
                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                const linksHtml = (entry.links && entry.links.length > 0) ? `
                    <div class="entry-card-links">
                        ${entry.links.map(link => `<a href="${escapeHtml(link)}" target="_blank">🔗 ${escapeHtml(link.split('/').pop() || link)}</a>`).join('')}
                    </div>
                ` : '';
                
                return `
                    <div class="entry-card" data-entry-id="${entry.id}">
                        <div class="entry-card-header">
                            <div class="entry-card-meta">
                                <span class="author">${escapeHtml(entry.author || 'Unknown')}</span> • ${dateStr}
                            </div>
                            <div class="entry-card-actions">
                                <button data-action="edit" data-entry-id="${entry.id}">✏️ Edit</button>
                                <button data-action="delete" data-entry-id="${entry.id}">🗑️</button>
                            </div>
                        </div>
                        <div class="entry-card-description">${escapeHtml(entry.description || '')}</div>
                        ${linksHtml}
                        <div class="entry-edit-form">
                            <textarea data-field="description">${escapeHtml(entry.description || '')}</textarea>
                            <input type="text" data-field="author" value="${escapeHtml(entry.author || '')}" placeholder="Author">
                            <div class="links-section">
                                <label>Links</label>
                                <div class="entry-links-list" data-entry-id="${entry.id}">
                                    ${(entry.links || []).map((link, li) => `
                                        <div class="link-item">
                                            <a href="${escapeHtml(link)}" target="_blank">${escapeHtml(link)}</a>
                                            <button data-link-index="${li}">✕</button>
                                        </div>
                                    `).join('')}
                                </div>
                                <div class="add-link-row">
                                    <input type="text" data-field="new-link" placeholder="https://...">
                                    <button class="btn-save" data-action="add-link">+</button>
                                </div>
                            </div>
                            <div class="entry-edit-buttons">
                                <button class="btn-cancel" data-action="cancel-edit">Cancel</button>
                                <button class="btn-save" data-action="save-edit">Save Entry</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Add event listeners
            entriesList.querySelectorAll('.entry-card-actions button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const entryId = parseInt(btn.dataset.entryId);
                    const action = btn.dataset.action;
                    
                    if (action === 'edit') {
                        showConfirm('Are you sure you want to edit this entry instead of adding a new one?', () => {
                            startEditingEntry(entryId);
                        });
                    } else if (action === 'delete') {
                        showConfirm('Are you sure you want to delete this entry? This cannot be undone.', () => {
                            deleteEntry(entryId);
                        });
                    }
                });
            });
            
            // Entry edit form buttons
            entriesList.querySelectorAll('.entry-edit-form button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const action = btn.dataset.action;
                    const card = btn.closest('.entry-card');
                    const entryId = parseInt(card.dataset.entryId);
                    
                    if (action === 'cancel-edit') {
                        cancelEditingEntry();
                        renderEntriesList(ann);
                    } else if (action === 'save-edit') {
                        saveEntryEdit(entryId, card);
                    } else if (action === 'add-link') {
                        const input = card.querySelector('[data-field="new-link"]');
                        const link = input.value.trim();
                        if (link) {
                            const entry = ann.entries.find(en => en.id === entryId);
                            if (!entry.links) entry.links = [];
                            entry.links.push(link);
                            input.value = '';
                            renderEntriesList(ann);
                            startEditingEntry(entryId); // Keep in edit mode
                        }
                    }
                });
            });
            
            // Link delete buttons in edit mode
            entriesList.querySelectorAll('.entry-links-list button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const card = btn.closest('.entry-card');
                    const entryId = parseInt(card.dataset.entryId);
                    const linkIndex = parseInt(btn.dataset.linkIndex);
                    const entry = ann.entries.find(en => en.id === entryId);
                    if (entry && entry.links) {
                        entry.links.splice(linkIndex, 1);
                        renderEntriesList(ann);
                        startEditingEntry(entryId);
                    }
                });
            });
        }
        
        function startEditingEntry(entryId) {
            editingEntryId = entryId;
            entriesList.querySelectorAll('.entry-card').forEach(card => {
                if (parseInt(card.dataset.entryId) === entryId) {
                    card.classList.add('editing');
                } else {
                    card.classList.remove('editing');
                }
            });
        }
        
        function cancelEditingEntry() {
            editingEntryId = null;
            entriesList.querySelectorAll('.entry-card').forEach(card => {
                card.classList.remove('editing');
            });
        }
        
        function saveEntryEdit(entryId, card) {
            const entry = editingAnnotation.entries.find(en => en.id === entryId);
            if (!entry) return;
            
            const description = card.querySelector('[data-field="description"]').value.trim();
            const author = card.querySelector('[data-field="author"]').value.trim();
            
            entry.description = description;
            entry.author = author;
            entry.modified = new Date().toISOString();
            saveLastAuthor(author);
            
            editingEntryId = null;
            renderEntriesList(editingAnnotation);
            showStatus('Entry updated');
        }
        
        function deleteEntry(entryId) {
            if (!editingAnnotation || !editingAnnotation.entries) return;
            
            editingAnnotation.entries = editingAnnotation.entries.filter(e => e.id !== entryId);
            renderEntriesList(editingAnnotation);
            updateGroupsList();
            showStatus('Entry deleted');
        }
        
        function showAddEntryForm() {
            isAddingEntry = true;
            newEntryForm.style.display = 'block';
            annDescription.value = '';
            annAuthor.value = getLastAuthor();
            pendingLinks = [];
            updateLinksDisplay();
            annDescription.focus();
        }
        
        function hideAddEntryForm() {
            isAddingEntry = false;
            newEntryForm.style.display = 'none';
        }
        
        function showConfirm(message, callback) {
            confirmMessage.textContent = message;
            confirmCallback = callback;
            confirmOverlay.classList.add('visible');
        }
        
        function hideConfirm() {
            confirmOverlay.classList.remove('visible');
            confirmCallback = null;
        }

        // ============ Scalebar Functions ============
        function getNiceScaleValue(value) {
            // Find a "nice" round number for the scale
            const magnitude = Math.pow(10, Math.floor(Math.log10(value)));
            const normalized = value / magnitude;
            
            let nice;
            if (normalized < 1.5) nice = 1;
            else if (normalized < 3.5) nice = 2;
            else if (normalized < 7.5) nice = 5;
            else nice = 10;
            
            return nice * magnitude;
        }

        function calculateScalebarParams() {
            // Only works in orthographic mode
            if (!isOrthographic || !currentModel) return null;
            
            const viewportWidth = window.innerWidth - 320;
            
            // Account for the camera's zoom factor!
            // The effective frustum width is the base frustum divided by zoom
            const baseFrustumWidth = orthographicCamera.right - orthographicCamera.left;
            const effectiveFrustumWidth = baseFrustumWidth / orthographicCamera.zoom;
            
            // We want the scalebar to be roughly 1/4 of the viewport width
            const targetScalebarUnits = effectiveFrustumWidth * 0.25;
            const niceValue = getNiceScaleValue(targetScalebarUnits);
            
            // Calculate pixel width for this nice value
            const pixelsPerUnit = viewportWidth / effectiveFrustumWidth;
            const scalebarPixelWidth = niceValue * pixelsPerUnit;
            
            return {
                units: niceValue,
                pixelWidth: scalebarPixelWidth
            };
        }

        function drawScalebarOnCanvas(targetCanvas) {
            const params = calculateScalebarParams();
            if (!params) return;
            
            const ctx = targetCanvas.getContext('2d');
            const canvasWidth = targetCanvas.width;
            const canvasHeight = targetCanvas.height;
            
            // Scale for high DPI displays
            const dpr = window.devicePixelRatio || 1;
            const scalebarWidth = params.pixelWidth * dpr;
            const segmentCount = 4; // Number of black/white segments
            const segmentWidth = scalebarWidth / segmentCount;
            const barHeight = 12 * dpr;
            
            // Position: bottom-left with padding
            const padding = 20 * dpr;
            const x = padding;
            const y = canvasHeight - padding - barHeight - 25 * dpr; // Extra space for text
            
            // Draw background box for better visibility
            const bgPadding = 10 * dpr;
            ctx.fillStyle = 'rgba(4, 29, 49, 0.85)';
            ctx.fillRect(
                x - bgPadding, 
                y - bgPadding, 
                scalebarWidth + bgPadding * 2, 
                barHeight + 45 * dpr + bgPadding
            );
            
            // Draw alternating black and white rectangles
            for (let i = 0; i < segmentCount; i++) {
                ctx.fillStyle = i % 2 === 0 ? '#000000' : '#ffffff';
                ctx.fillRect(x + i * segmentWidth, y, segmentWidth, barHeight);
            }
            
            // Draw border around the entire bar
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1 * dpr;
            ctx.strokeRect(x, y, scalebarWidth, barHeight);
            
            // Draw numbers
            ctx.fillStyle = '#ffffff';
            ctx.font = `${12 * dpr}px Arial`;
            ctx.textAlign = 'center';
            
            // Number at start (0)
            ctx.fillText('0', x, y + barHeight + 15 * dpr);
            
            // Number at end
            const endLabel = params.units >= 1 ? params.units.toString() : params.units.toFixed(2);
            ctx.fillText(endLabel, x + scalebarWidth, y + barHeight + 15 * dpr);
            
            // Units label
            ctx.font = `${10 * dpr}px Arial`;
            ctx.fillStyle = '#aaaaaa';
            ctx.textAlign = 'left';
            ctx.fillText('units (scale depends on model source)', x, y + barHeight + 30 * dpr);
        }

        function showScalebarConfirm(switchCallback, noSwitchCallback) {
            scalebarConfirmCallback = switchCallback;
            scalebarNoSwitchCallback = noSwitchCallback;
            scalebarConfirmOverlay.classList.add('visible');
        }

        function hideScalebarConfirm() {
            scalebarConfirmOverlay.classList.remove('visible');
            scalebarConfirmCallback = null;
            scalebarNoSwitchCallback = null;
        }

        function positionPopup(popup, x, y) {
            popup.style.transform = 'none';
            popup.style.left = `${x + 10}px`;
            popup.style.top = `${y + 10}px`;

            requestAnimationFrame(() => {
                const rect = popup.getBoundingClientRect();
                // Check right edge (account for sidebar)
                if (rect.right > window.innerWidth - 320) {
                    popup.style.left = `${x - rect.width - 10}px`;
                }
                // Check bottom edge
                if (rect.bottom > window.innerHeight) {
                    popup.style.top = `${y - rect.height - 10}px`;
                }
                // Check top edge (account for header)
                const newRect = popup.getBoundingClientRect();
                if (newRect.top < 50) {
                    popup.style.top = '60px';
                }
                // Check left edge
                if (newRect.left < 10) {
                    popup.style.left = '10px';
                }
            });
        }

        function saveAnnotation() {
            // Handle Model Information save
            if (editingModelInfo) {
                if (isAddingEntry || modelInfo.entries.length === 0) {
                    const description = annDescription.value.trim();
                    const author = annAuthor.value.trim();
                    
                    if (description || author) {
                        saveLastAuthor(author);
                        modelInfo.entries.push({
                            id: Date.now(),
                            uuid: generateUUID(),
                            description,
                            author,
                            timestamp: new Date().toISOString(),
                            links: [...pendingLinks]
                        });
                    }
                }
                
                annotationPopup.classList.remove('visible');
                isAddingEntry = false;
                editingModelInfo = false;
                updateModelInfoDisplay();
                showStatus('Model information saved');
                return;
            }
            
            const type = annotationPopup.dataset.type;
            const points = JSON.parse(annotationPopup.dataset.points);
            const name = annName.value.trim() || 'Unnamed';
            const groupId = parseInt(annGroup.value) || groups[0].id;

            if (editingAnnotation) {
                // Update name and group
                editingAnnotation.name = name;
                editingAnnotation.groupId = groupId;
                
                // Handle surface projection toggle for line/polygon
                if ((editingAnnotation.type === 'line' || editingAnnotation.type === 'polygon') && surfaceProjectionEnabled) {
                    const wantsProjection = annSurfaceProjection.checked;
                    const hadProjection = editingAnnotation.surfaceProjection !== false;
                    
                    if (wantsProjection && !hadProjection) {
                        // Turned ON: compute projected edges
                        editingAnnotation.projectedEdges = computeProjectedEdges(
                            editingAnnotation.points, editingAnnotation.type === 'polygon'
                        );
                        editingAnnotation.surfaceProjection = true;
                    } else if (!wantsProjection && hadProjection) {
                        // Turned OFF: remove projected edges
                        delete editingAnnotation.projectedEdges;
                        editingAnnotation.surfaceProjection = false;
                    }
                }

                // If adding a new entry
                if (isAddingEntry) {
                    const description = annDescription.value.trim();
                    const author = annAuthor.value.trim();
                    saveLastAuthor(author);
                    
                    if (!editingAnnotation.entries) editingAnnotation.entries = [];
                    editingAnnotation.entries.push({
                        id: Date.now(),
                        uuid: generateUUID(),
                        description,
                        author,
                        timestamp: new Date().toISOString(),
                        links: [...pendingLinks]
                    });
                }
            } else {
                // Create new annotation with first entry
                const description = annDescription.value.trim();
                const author = annAuthor.value.trim();
                saveLastAuthor(author);
                
                const newAnnotation = {
                    id: Date.now(),
                    uuid: generateUUID(),
                    type,
                    name,
                    groupId,
                    points,
                    entries: [{
                        id: Date.now() + 1,
                        uuid: generateUUID(),
                        description,
                        author,
                        timestamp: new Date().toISOString(),
                        links: [...pendingLinks]
                    }]
                };
                
                // Add face data for surface annotations
                if (type === 'surface' && annotationPopup.dataset.faceData) {
                    newAnnotation.faceData = JSON.parse(annotationPopup.dataset.faceData);
                }
                
                // Compute surface-projected edges for lines and polygons
                if ((type === 'line' || type === 'polygon') && points.length >= 2) {
                    const wantsProjection = surfaceProjectionEnabled && annSurfaceProjection.checked;
                    newAnnotation.surfaceProjection = wantsProjection;
                    if (wantsProjection) {
                        newAnnotation.projectedEdges = computeProjectedEdges(points, type === 'polygon');
                    }
                }
                
                annotations.push(newAnnotation);
            }

            annotationPopup.classList.remove('visible');
            isAddingEntry = false;
            clearTempDrawing();
            updateGroupsList();
            renderAnnotations();
            showStatus(`Saved: ${name}`);
        }

        function deleteAnnotation() {
            if (!editingAnnotation) return;
            
            showConfirm('Are you sure you want to delete this annotation and all its entries? This cannot be undone.', () => {
                annotations = annotations.filter(a => a.id !== editingAnnotation.id);
                annotationPopup.classList.remove('visible');
                editingAnnotation = null;
                selectedAnnotation = null;
                updateGroupsList();
                renderAnnotations();
                showStatus('Annotation deleted');
            });
        }

        function selectAnnotation(id) {
            selectedAnnotation = id;
            const ann = annotations.find(a => a.id === id);
            
            if (ann && ann.points.length > 0) {
                const center = new THREE.Vector3();
                ann.points.forEach(p => center.add(new THREE.Vector3(p.x, p.y, p.z)));
                center.divideScalar(ann.points.length);
                controls.target.copy(center);
                controls.update();
            }

            updateGroupsList();
        }

        function updateLinksDisplay() {
            annLinks.innerHTML = pendingLinks.map((link, i) => `
                <div class="link-item">
                    <a href="${escapeHtml(link)}" target="_blank">${escapeHtml(link)}</a>
                    <button data-index="${i}">✕</button>
                </div>
            `).join('');

            annLinks.querySelectorAll('button').forEach(btn => {
                btn.addEventListener('click', () => {
                    pendingLinks.splice(parseInt(btn.dataset.index), 1);
                    updateLinksDisplay();
                });
            });
        }

        function addLink() {
            const url = annNewLink.value.trim();
            if (url) {
                pendingLinks.push(url);
                annNewLink.value = '';
                updateLinksDisplay();
            }
        }

        // ============ Render Annotations ============
        /**
         * Clears and rebuilds all 3D annotation objects (markers, lines, polygons,
         * surface meshes, and text labels). Disposes old GPU resources before recreating.
         * Respects group visibility and applies group colors. Scales markers and labels
         * based on model bounding size with non-linear scaling (exponent 0.8/0.7)
         * so they remain visible across different model scales.
         */
        function renderAnnotations() {
            // Clear existing and dispose GPU resources
            while (annotationObjects.children.length > 0) {
                const child = annotationObjects.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    const mats = Array.isArray(child.material) ? child.material : [child.material];
                    mats.forEach(m => m.dispose());
                }
                annotationObjects.remove(child);
            }

            const modelSize = currentModel ? 
                new THREE.Box3().setFromObject(currentModel).getSize(new THREE.Vector3()) :
                new THREE.Vector3(1, 1, 1);
            const maxDim = Math.max(modelSize.x, modelSize.y, modelSize.z);
            const labelOffset = Math.pow(maxDim, 0.8) * 0.012; // Offset to clear larger markers

            annotations.forEach(ann => {
                const group = groups.find(g => g.id === ann.groupId);
                if (!group || !group.visible) return;

                const color = new THREE.Color(group.color);
                let labelPosition;

                if (ann.type === 'point') {
                    const geometry = new THREE.SphereGeometry(0.02, 16, 16);
                    const material = new THREE.MeshBasicMaterial({ color });
                    const marker = new THREE.Mesh(geometry, material);
                    marker.position.set(ann.points[0].x, ann.points[0].y, ann.points[0].z);
                    marker.scale.setScalar(Math.pow(maxDim, 0.8) * 0.025 * pointSizeMultiplier);
                    marker.userData.annotationId = ann.id;
                    marker.userData.pointIndex = 0;
                    marker.userData.isAnnotationMarker = true;
                    annotationObjects.add(marker);
                    
                    // Label position slightly above the point
                    labelPosition = new THREE.Vector3(
                        ann.points[0].x,
                        ann.points[0].y + labelOffset,
                        ann.points[0].z
                    );
                } else if (ann.type === 'line' || ann.type === 'polygon') {
                    // Build positions array for Line2
                    const positions = [];
                    
                    if (ann.projectedEdges && ann.surfaceProjection && ann.projectedEdges.length > 0) {
                        // Surface-projected rendering: use pre-computed edge polylines
                        ann.projectedEdges.forEach((edge, edgeIdx) => {
                            const startIdx = (edgeIdx === 0) ? 0 : 1; // Skip duplicate junction points
                            for (let j = startIdx; j < edge.length; j++) {
                                positions.push(edge[j].x, edge[j].y, edge[j].z);
                            }
                        });
                    } else {
                        // Classic straight-line rendering (fallback)
                        const points = ann.points.map(p => new THREE.Vector3(p.x, p.y, p.z));
                        if (ann.type === 'polygon' && points.length > 0) {
                            points.push(points[0].clone());
                        }
                        points.forEach(p => positions.push(p.x, p.y, p.z));
                    }

                    // Create thick line
                    const lineGeometry = new LineGeometry();
                    lineGeometry.setPositions(positions);

                    const lineMaterial = new LineMaterial({
                        color: color,
                        linewidth: 3,
                        resolution: new THREE.Vector2(window.innerWidth - 320, window.innerHeight - 50),
                        polygonOffset: true,
                        polygonOffsetFactor: -4,
                        polygonOffsetUnits: -4
                    });

                    const line = new Line2(lineGeometry, lineMaterial);
                    line.userData.annotationId = ann.id;
                    annotationObjects.add(line);

                    // Points along the line/polygon
                    ann.points.forEach((p, index) => {
                        const geometry = new THREE.SphereGeometry(0.02, 12, 12);
                        const material = new THREE.MeshBasicMaterial({ color });
                        const marker = new THREE.Mesh(geometry, material);
                        marker.position.set(p.x, p.y, p.z);
                        marker.scale.setScalar(Math.pow(maxDim, 0.8) * 0.018 * pointSizeMultiplier);
                        marker.userData.annotationId = ann.id;
                        marker.userData.pointIndex = index;
                        marker.userData.isAnnotationMarker = true;
                        annotationObjects.add(marker);
                    });
                    
                    // Label position: centroid for polygons, first point for lines
                    if (ann.type === 'polygon' && ann.points.length > 0) {
                        const centroid = ann.points.reduce(
                            (acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y, z: acc.z + p.z }),
                            { x: 0, y: 0, z: 0 }
                        );
                        labelPosition = new THREE.Vector3(
                            centroid.x / ann.points.length,
                            centroid.y / ann.points.length + labelOffset,
                            centroid.z / ann.points.length
                        );
                    } else if (ann.points.length > 0) {
                        // For lines, place at first point
                        labelPosition = new THREE.Vector3(
                            ann.points[0].x,
                            ann.points[0].y + labelOffset,
                            ann.points[0].z
                        );
                    }
                } else if (ann.type === 'surface' && ann.faceData) {
                    // Render surface annotation
                    const surfaceMesh = renderSurfaceAnnotation(ann, color);
                    if (surfaceMesh) {
                        surfaceMesh.userData.annotationId = ann.id;
                        annotationObjects.add(surfaceMesh);
                    }
                    
                    // Label position from center point
                    if (ann.points && ann.points.length > 0) {
                        labelPosition = new THREE.Vector3(
                            ann.points[0].x,
                            ann.points[0].y + labelOffset,
                            ann.points[0].z
                        );
                    }
                }
                
                // Add name label if annotation has a name
                if (ann.name && labelPosition) {
                    const label = createScaledTextSprite(ann.name, group.color, labelPosition, 0.8);
                    label.userData.annotationId = ann.id;
                    annotationObjects.add(label);
                }
            });

            updateAnnotationsPanel();
        }

        function renderSurfaceAnnotation(ann, color) {
            if (!ann.faceData || ann.faceData.length === 0) return null;

            // Group faces by mesh index
            const facesByMesh = new Map();
            ann.faceData.forEach(faceId => {
                const [meshIdx, faceIdx] = faceId.split('_');
                if (!facesByMesh.has(meshIdx)) {
                    facesByMesh.set(meshIdx, []);
                }
                facesByMesh.get(meshIdx).push(parseInt(faceIdx));
            });

            // Build combined geometry
            const vertices = [];
            
            facesByMesh.forEach((faceIndices, meshIdx) => {
                const mesh = modelMeshes[parseInt(meshIdx)];
                if (!mesh) return;

                const geometry = mesh.geometry;
                const position = geometry.attributes.position;

                faceIndices.forEach(faceIdx => {
                    let a, b, c;
                    if (geometry.index) {
                        a = geometry.index.getX(faceIdx * 3);
                        b = geometry.index.getX(faceIdx * 3 + 1);
                        c = geometry.index.getX(faceIdx * 3 + 2);
                    } else {
                        a = faceIdx * 3;
                        b = faceIdx * 3 + 1;
                        c = faceIdx * 3 + 2;
                    }

                    const vA = new THREE.Vector3().fromBufferAttribute(position, a);
                    const vB = new THREE.Vector3().fromBufferAttribute(position, b);
                    const vC = new THREE.Vector3().fromBufferAttribute(position, c);

                    // Apply mesh world transform
                    vA.applyMatrix4(mesh.matrixWorld);
                    vB.applyMatrix4(mesh.matrixWorld);
                    vC.applyMatrix4(mesh.matrixWorld);

                    vertices.push(vA.x, vA.y, vA.z);
                    vertices.push(vB.x, vB.y, vB.z);
                    vertices.push(vC.x, vC.y, vC.z);
                });
            });

            if (vertices.length === 0) return null;

            // Create highlight geometry
            const highlightGeometry = new THREE.BufferGeometry();
            highlightGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            highlightGeometry.computeVertexNormals();

            const highlightMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide,
                depthTest: true,
                depthWrite: false,
                polygonOffset: true,
                polygonOffsetFactor: -4,
                polygonOffsetUnits: -4
            });

            const mesh = new THREE.Mesh(highlightGeometry, highlightMaterial);
            mesh.renderOrder = 999; // Render after everything else
            return mesh;
        }

        function updateAnnotationsPanel() {
            // Panel content is now integrated into groups list
            // This function kept for compatibility with calls from other functions
        }

        // ============ Screenshot ============
        function takeScreenshot() {
            if (!isOrthographic) {
                // Show confirmation dialog for perspective mode
                showScalebarConfirm(
                    () => {
                        // User chose to switch to orthographic
                        toggleCamera();
                        setTimeout(() => {
                            captureScreenshot(true);
                        }, 100);
                    },
                    () => {
                        // User chose to continue without scalebar
                        captureScreenshot(false);
                    }
                );
            } else {
                captureScreenshot(true);
            }
        }
        
        function captureScreenshot(includeScalebar) {
            renderer.render(scene, camera);
            
            // Create a copy of the canvas to draw scalebar on
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const ctx = tempCanvas.getContext('2d');
            ctx.drawImage(canvas, 0, 0);
            
            // Draw scalebar if in orthographic mode
            if (includeScalebar && isOrthographic) {
                drawScalebarOnCanvas(tempCanvas);
            }
            
            const dataURL = tempCanvas.toDataURL('image/png');
            
            const link = document.createElement('a');
            link.download = `meshnotes-screenshot-${Date.now()}.png`;
            link.href = dataURL;
            link.click();
            
            showStatus('Screenshot saved');
        }

        // ============ Export/Import ============
        // ============ W3C Web Annotation Export/Import ============
        
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        
        /**
         * Transforms a point from Three.js Y-up world space to Z-up export space.
         * MeshNotes always exports in Z-up coordinates for interoperability with
         * photogrammetry/archaeology tools (Agisoft, CloudCompare, Blender, etc.).
         *
         * The model was rotated -90° around X on load (Z-up → Y-up), so the
         * inverse transform converts back: (x, y, z)_threejs → (x, -z, y)_zup
         * @param {{x: number, y: number, z: number}} p - Point in Three.js Y-up space
         * @returns {{x: number, y: number, z: number}} Point in Z-up space
         */
        function pointToZUp(p) {
            return { x: p.x, y: -p.z, z: p.y };
        }

        /**
         * Transforms a point from Z-up import space to Three.js Y-up world space.
         * Inverse of pointToZUp: (x, y, z)_zup → (x, z, -y)_threejs
         * @param {{x: number, y: number, z: number}} p - Point in Z-up space
         * @returns {{x: number, y: number, z: number}} Point in Three.js Y-up space
         */
        function pointFromZUp(p) {
            return { x: p.x, y: p.z, z: -p.y };
        }

        /**
         * Converts an annotation's geometry into a W3C Web Annotation selector.
         * All coordinates are transformed to Z-up space for export.
         * Uses FragmentSelector with IIIF 3D conformance for point/line/polygon types,
         * and a custom MeshNotes surface selector for painted face annotations.
         * @see https://www.w3.org/TR/annotation-model/#fragment-selector
         * @param {Object} ann - Internal annotation object with type and points/faceData
         * @returns {Object} W3C-compliant selector object
         */
        function formatPointsAsSelector(ann) {
            // Create W3C-compliant selector for 3D geometry
            // All coordinates are transformed from Three.js Y-up to Z-up for export
            if (ann.type === 'point') {
                const p = pointToZUp(ann.points[0]);
                return {
                    type: 'PointSelector',
                    refinedBy: {
                        type: 'FragmentSelector',
                        conformsTo: 'https://github.com/IIIF/3d',
                        value: `point=${p.x},${p.y},${p.z}`
                    }
                };
            } else if (ann.type === 'line') {
                const coords = ann.points.map(p => { const z = pointToZUp(p); return `${z.x},${z.y},${z.z}`; }).join(';');
                return {
                    type: 'SvgSelector',
                    refinedBy: {
                        type: 'FragmentSelector',
                        conformsTo: 'https://github.com/IIIF/3d',
                        value: `polyline=${coords}`
                    }
                };
            } else if (ann.type === 'polygon') {
                const coords = ann.points.map(p => { const z = pointToZUp(p); return `${z.x},${z.y},${z.z}`; }).join(';');
                return {
                    type: 'SvgSelector',
                    refinedBy: {
                        type: 'FragmentSelector',
                        conformsTo: 'https://github.com/IIIF/3d',
                        value: `polygon=${coords}`
                    }
                };
            } else if (ann.type === 'surface' && ann.faceData) {
                // Face indices don't need transformation, only the centroid point
                const centroid = ann.points.length > 0 ? pointToZUp(ann.points[0]) : null;
                return {
                    type: 'FragmentSelector',
                    conformsTo: 'https://github.com/IIIF/3d',
                    value: `faces=${ann.faceData.join(',')}`,
                    refinedBy: centroid ? {
                        type: 'PointSelector',
                        value: `centroid=${centroid.x},${centroid.y},${centroid.z}`
                    } : undefined
                };
            }
            return null;
        }
        
        function parseSelector(selector, ann) {
            // Parse W3C selector back to internal format
            if (!selector) return;
            
            // Get main selector value - check direct value first, then refinedBy
            // (Surface annotations have value at top level, others have it in refinedBy)
            let fragmentValue = null;
            if (selector.value) {
                fragmentValue = selector.value;
            } else if (selector.refinedBy && selector.refinedBy.value) {
                fragmentValue = selector.refinedBy.value;
            }
            
            if (!fragmentValue) return;
            
            // Parse point=x,y,z
            if (fragmentValue.startsWith('point=')) {
                const coords = fragmentValue.replace('point=', '').split(',').map(Number);
                if (coords.length === 3) {
                    ann.points = [{ x: coords[0], y: coords[1], z: coords[2] }];
                    ann.type = 'point';
                }
            }
            // Parse polyline=x1,y1,z1;x2,y2,z2;...
            else if (fragmentValue.startsWith('polyline=')) {
                const pointsStr = fragmentValue.replace('polyline=', '').split(';');
                ann.points = pointsStr.map(p => {
                    const coords = p.split(',').map(Number);
                    return { x: coords[0], y: coords[1], z: coords[2] };
                });
                ann.type = 'line';
            }
            // Parse polygon=x1,y1,z1;x2,y2,z2;...
            else if (fragmentValue.startsWith('polygon=')) {
                const pointsStr = fragmentValue.replace('polygon=', '').split(';');
                ann.points = pointsStr.map(p => {
                    const coords = p.split(',').map(Number);
                    return { x: coords[0], y: coords[1], z: coords[2] };
                });
                ann.type = 'polygon';
            }
            // Parse faces=0_1,0_2,...
            else if (fragmentValue.startsWith('faces=')) {
                ann.faceData = fragmentValue.replace('faces=', '').split(',');
                ann.type = 'surface';
                ann.points = [];
                // Check for centroid in refinedBy
                if (selector.refinedBy && selector.refinedBy.value && selector.refinedBy.value.startsWith('centroid=')) {
                    const coords = selector.refinedBy.value.replace('centroid=', '').split(',').map(Number);
                    if (coords.length === 3) {
                        ann.points = [{ x: coords[0], y: coords[1], z: coords[2] }];
                    }
                }
            }
            // Parse centroid for surface types
            else if (fragmentValue.startsWith('centroid=')) {
                const coords = fragmentValue.replace('centroid=', '').split(',').map(Number);
                if (coords.length === 3) {
                    ann.points = [{ x: coords[0], y: coords[1], z: coords[2] }];
                }
            }
        }
        
        /**
         * Converts an internal annotation to the W3C Web Annotation JSON-LD format.
         * Includes annotation metadata, group info, geometry selector, and all entries
         * (mapped to oa:TextualBody with author/timestamp/links).
         * @see https://www.w3.org/TR/annotation-model/
         * @param {Object} ann - Internal annotation object
         * @param {Object} group - The group this annotation belongs to (for color/name)
         * @returns {Object} W3C Web Annotation JSON-LD object
         */
        function convertToW3CAnnotation(ann, group) {
            // Convert internal annotation to W3C Web Annotation format
            const w3cAnn = {
                '@context': 'http://www.w3.org/ns/anno.jsonld',
                type: 'Annotation',
                id: `urn:meshnotes:annotation:${ann.uuid || generateUUID()}`,
                motivation: ann.type === 'surface' ? 'tagging' : 'describing',
                created: ann.entries && ann.entries.length > 0 ? ann.entries[0].timestamp : new Date().toISOString(),
                modified: ann.entries && ann.entries.length > 1 ? ann.entries[ann.entries.length - 1].timestamp : undefined,
                'schema:name': ann.name || 'Unnamed',
                target: {
                    type: 'SpecificResource',
                    source: {
                        id: `urn:meshnotes:model:${modelFileName || 'unknown'}`,
                        type: 'Dataset',
                        format: getModelMimeType()
                    },
                    selector: formatPointsAsSelector(ann)
                }
            };
            
            // Add styleClass for group color
            if (group) {
                w3cAnn.target.styleClass = `group-${group.id}`;
            }
            
            // Convert entries to body array
            if (ann.entries && ann.entries.length > 0) {
                w3cAnn.body = ann.entries.map(entry => {
                    const body = {
                        type: 'TextualBody',
                        value: entry.description || '',
                        format: 'text/plain',
                        language: 'en',
                        'meshnotes:entryUuid': entry.uuid
                    };
                    
                    if (entry.author) {
                        body.creator = {
                            type: 'Person',
                            name: entry.author
                        };
                    }
                    
                    if (entry.timestamp) {
                        body.created = entry.timestamp;
                    }
                    
                    if (entry.modified) {
                        body.modified = entry.modified;
                    }
                    
                    // Store links as custom property
                    if (entry.links && entry.links.length > 0) {
                        body['schema:url'] = entry.links;
                    }
                    
                    return body;
                });
            }
            
            // Store internal ID mapping for round-trip
            w3cAnn['meshnotes:internalId'] = ann.id;
            w3cAnn['meshnotes:groupId'] = ann.groupId;
            w3cAnn['meshnotes:groupUuid'] = group ? group.uuid : undefined;
            w3cAnn['annotationType'] = ann.type;
            if (ann.surfaceProjection === false) {
                w3cAnn['surfaceProjection'] = false;
            }
            
            return w3cAnn;
        }
        
        function convertFromW3CAnnotation(w3cAnn, groupIdMap) {
            // Convert W3C Web Annotation back to internal format
            // Extract persistent UUID from W3C id (urn:meshnotes:annotation:{uuid})
            let importedUuid = null;
            if (w3cAnn.id && w3cAnn.id.startsWith('urn:meshnotes:annotation:')) {
                importedUuid = w3cAnn.id.replace('urn:meshnotes:annotation:', '');
            }
            const ann = {
                id: Date.now() + Math.floor(Math.random() * 10000),
                uuid: importedUuid || generateUUID(),
                type: w3cAnn['annotationType'] || w3cAnn['meshnotes:annotationType'] || 'point',
                name: w3cAnn['schema:name'] || 'Unnamed',
                groupId: null,
                points: [],
                entries: []
            };
            
            // Map group - try UUID first, then internal ID
            const origGroupUuid = w3cAnn['meshnotes:groupUuid'];
            const origGroupId = w3cAnn['meshnotes:groupId'];
            if (origGroupUuid && groupIdMap['uuid:' + origGroupUuid]) {
                ann.groupId = groupIdMap['uuid:' + origGroupUuid];
            } else if (origGroupId && groupIdMap[origGroupId]) {
                ann.groupId = groupIdMap[origGroupId];
            }
            
            // Restore surface projection setting (default true for line/polygon)
            if (w3cAnn['surfaceProjection'] === false || w3cAnn['meshnotes:surfaceProjection'] === false) {
                ann.surfaceProjection = false;
            }

            // Parse selector to get points/faceData
            if (w3cAnn.target && w3cAnn.target.selector) {
                parseSelector(w3cAnn.target.selector, ann);
            }
            
            // Convert body to entries
            if (w3cAnn.body) {
                const bodies = Array.isArray(w3cAnn.body) ? w3cAnn.body : [w3cAnn.body];
                ann.entries = bodies.map((body, idx) => {
                    const entry = {
                        id: Date.now() + idx + Math.floor(Math.random() * 1000),
                        uuid: body['meshnotes:entryUuid'] || generateUUID(),
                        description: body.value || '',
                        author: body.creator ? body.creator.name : '',
                        timestamp: body.created || w3cAnn.created || new Date().toISOString(),
                        modified: body.modified || undefined,
                        links: body['schema:url'] || []
                    };
                    return entry;
                });
            }
            
            return ann;
        }
        
        /**
         * Exports all annotations as a W3C Web Annotation Collection (JSON-LD).
         * Includes group definitions (as CssStylesheet), model info, and all annotations
         * converted to W3C format. Downloads as a .json file.
         * @see https://www.w3.org/TR/annotation-model/#collections
         */
        function exportAnnotations() {
            // Create W3C Web Annotation Collection
            const collectionId = `urn:meshnotes:collection:${generateUUID()}`;
            
            // Convert groups to stylesheet
            const stylesheet = {
                type: 'CssStylesheet',
                value: groups.map(g => `.group-${g.id} { color: ${g.color}; }`).join('\n')
            };
            
            // Convert all annotations to W3C format
            const w3cAnnotations = annotations.map(ann => {
                const group = groups.find(g => g.id === ann.groupId);
                return convertToW3CAnnotation(ann, group);
            });
            
            // Build the W3C AnnotationCollection
            const collection = {
                '@context': [
                    'http://www.w3.org/ns/anno.jsonld',
                    {
                        'meshnotes': 'https://github.com/NilsSchnorr/MeshNotes#',
                        'schema': 'http://schema.org/',
                        'upAxis': 'meshnotes:upAxis',
                        'modelSource': 'meshnotes:modelSource',
                        'annotationType': 'meshnotes:annotationType',
                        'surfaceProjection': 'meshnotes:surfaceProjection',
                        'modelInfo': 'meshnotes:modelInfo'
                    }
                ],
                type: 'AnnotationCollection',
                id: collectionId,
                label: `MeshNotes: ${modelFileName || 'Annotations'}`,
                generator: {
                    type: 'Software',
                    name: 'MeshNotes',
                    'schema:version': '2.0',
                    homepage: 'https://github.com/NilsSchnorr/MeshNotes'
                },
                generated: new Date().toISOString(),
                
                // Coordinate system: MeshNotes always exports Z-up coordinates
                // for interoperability with photogrammetry/archaeology tools
                'upAxis': 'Z',
                
                // Target model
                'modelSource': {
                    id: `urn:meshnotes:model:${modelFileName || 'unknown'}`,
                    type: 'Dataset',
                    'schema:name': modelFileName,
                    format: getModelMimeType()
                },
                
                // Stylesheet for group colors
                stylesheet: stylesheet,
                
                // Groups metadata (custom extension)
                'meshnotes:groups': groups.map(g => ({
                    id: g.id,
                    'meshnotes:uuid': g.uuid,
                    'schema:name': g.name,
                    'schema:color': g.color,
                    'meshnotes:visible': g.visible
                })),
                
                // Model information entries
                'modelInfo': modelInfo.entries.length > 0 ? {
                    type: 'Annotation',
                    motivation: 'describing',
                    'schema:name': 'Model Information',
                    body: modelInfo.entries.map(entry => ({
                        type: 'TextualBody',
                        value: entry.description || '',
                        format: 'text/plain',
                        'meshnotes:entryUuid': entry.uuid,
                        creator: entry.author ? { type: 'Person', name: entry.author } : undefined,
                        created: entry.timestamp,
                        modified: entry.modified || undefined,
                        'schema:url': entry.links && entry.links.length > 0 ? entry.links : undefined
                    }))
                } : undefined,
                
                // Annotations
                total: w3cAnnotations.length,
                first: {
                    type: 'AnnotationPage',
                    items: w3cAnnotations
                }
            };
            
            // Clean up undefined values
            const cleanJSON = JSON.stringify(collection, (key, value) => {
                if (value === undefined) return undefined;
                return value;
            }, 2);
            
            const blob = new Blob([cleanJSON], { type: 'application/ld+json' });
            const url = URL.createObjectURL(blob);

            const link = document.createElement('a');
            link.download = `meshnotes-${modelFileName || 'export'}-${Date.now()}.jsonld`;
            link.href = url;
            link.click();

            URL.revokeObjectURL(url);
            showStatus('W3C annotations exported');
        }

        // ============ PDF Export ============
        async function exportPdfReport() {
            if (!currentModel) {
                showStatus('No model loaded');
                return;
            }
            
            if (!isOrthographic) {
                // Show confirmation dialog for perspective mode
                showScalebarConfirm(
                    () => {
                        // User chose to switch to orthographic
                        toggleCamera();
                        setTimeout(() => {
                            doExportPdfReport(true);
                        }, 100);
                    },
                    () => {
                        // User chose to continue without scalebar
                        doExportPdfReport(false);
                    }
                );
            } else {
                doExportPdfReport(true);
            }
        }
        
        // ============ PDF Helper Functions ============

        /**
         * Captures a screenshot from the renderer, optionally with a scalebar overlay.
         * @param {boolean} includeScalebar - Whether to draw scalebar on screenshot
         * @param {HTMLCanvasElement} [sourceCanvas=canvas] - Source canvas to capture from
         * @returns {string} Data URL of the captured image (JPEG)
         */
        function pdfCaptureScreenshot(includeScalebar, sourceCanvas) {
            const src = sourceCanvas || canvas;
            if (includeScalebar && isOrthographic) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = src.width;
                tempCanvas.height = src.height;
                const ctx = tempCanvas.getContext('2d');
                ctx.drawImage(src, 0, 0);
                drawScalebarOnCanvas(tempCanvas);
                return tempCanvas.toDataURL('image/jpeg', 0.9);
            }
            return src.toDataURL('image/jpeg', 0.9);
        }

        /**
         * Saves the current camera state for later restoration.
         * @returns {Object} Camera state snapshot
         */
        function pdfSaveCameraState() {
            return {
                position: camera.position.clone(),
                target: controls.target.clone(),
                up: camera.up.clone(),
                zoom: camera.zoom,
                frustum: isOrthographic ? {
                    left: camera.left, right: camera.right,
                    top: camera.top, bottom: camera.bottom
                } : null
            };
        }

        /**
         * Restores camera to a previously saved state.
         * @param {Object} saved - State from pdfSaveCameraState()
         */
        function pdfRestoreCamera(saved) {
            camera.up.copy(saved.up);
            camera.position.copy(saved.position);
            controls.target.copy(saved.target);
            if (isOrthographic && saved.frustum) {
                camera.left = saved.frustum.left;
                camera.right = saved.frustum.right;
                camera.top = saved.frustum.top;
                camera.bottom = saved.frustum.bottom;
                camera.zoom = saved.zoom;
                camera.updateProjectionMatrix();
            }
            controls.update();
        }

        /**
         * Renders a list of entries (author, date, description, links) into the PDF.
         * Used for both model info entries on the title page and annotation entries.
         * @param {jsPDF} pdf - The jsPDF instance
         * @param {Array} entries - Array of entry objects with author, timestamp, description, links
         * @param {number} yPos - Starting Y position on the page
         * @param {Object} layout - Page layout constants {margin, contentWidth, pageHeight}
         * @returns {number} Updated Y position after rendering
         */
        function pdfRenderEntries(pdf, entries, yPos, layout) {
            const { margin, contentWidth, pageHeight } = layout;

            entries.forEach(entry => {
                if (yPos > pageHeight - 35) {
                    pdf.addPage();
                    yPos = margin;
                }

                // Author and date
                pdf.setFontSize(9);
                pdf.setTextColor(170, 129, 1);
                const entryDate = new Date(entry.timestamp);
                const entryDateStr = entryDate.toLocaleDateString() + ' ' + entryDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                pdf.text(`${entry.author || 'Unknown'} • ${entryDateStr}`, margin, yPos);
                yPos += 5;

                // Description
                pdf.setFontSize(10);
                pdf.setTextColor(60, 60, 60);
                if (entry.description) {
                    const descLines = pdf.splitTextToSize(entry.description, contentWidth);
                    pdf.text(descLines, margin, yPos);
                    yPos += descLines.length * 5;
                }

                // Links
                if (entry.links && entry.links.length > 0) {
                    yPos += 2;
                    pdf.setFontSize(8);
                    pdf.setTextColor(100, 100, 200);
                    entry.links.forEach(link => {
                        if (yPos > pageHeight - 15) {
                            pdf.addPage();
                            yPos = margin;
                        }
                        const displayLink = link.length > 60 ? link.substring(0, 57) + '...' : link;
                        pdf.textWithLink('\u{1F517} ' + displayLink, margin, yPos, { url: link });
                        yPos += 4;
                    });
                }

                yPos += 6;
            });

            return yPos;
        }

        /**
         * Renders the title page: overview screenshot, model info, and summary stats.
         * @param {jsPDF} pdf - The jsPDF instance
         * @param {Object} layout - Page layout constants
         * @param {boolean} includeScalebar - Whether to include scalebar on screenshots
         * @param {Array} visibleGroups - Currently visible groups
         * @param {Array} visibleAnnotations - Currently visible annotations
         */
        async function pdfRenderTitlePage(pdf, layout, includeScalebar, visibleGroups, visibleAnnotations) {
            const { margin, contentWidth, pageWidth, pageHeight } = layout;

            // Title
            pdf.setFontSize(24);
            pdf.setTextColor(170, 129, 1);
            pdf.text('MeshNotes Report', pageWidth / 2, 25, { align: 'center' });

            // Model filename
            pdf.setFontSize(14);
            pdf.setTextColor(60, 60, 60);
            pdf.text(modelFileName || 'Untitled Model', pageWidth / 2, 35, { align: 'center' });

            // Date
            pdf.setFontSize(10);
            pdf.setTextColor(120, 120, 120);
            const dateStr = new Date().toLocaleDateString() + ' ' + new Date().toLocaleTimeString();
            pdf.text(`Generated: ${dateStr}`, pageWidth / 2, 42, { align: 'center' });

            // Overview screenshot
            await delay(100);
            renderer.render(scene, camera);
            const overviewImg = pdfCaptureScreenshot(includeScalebar);
            const canvasAspect = canvas.width / canvas.height;
            const imgHeight = contentWidth / canvasAspect;
            pdf.addImage(overviewImg, 'JPEG', margin, 50, contentWidth, imgHeight);

            // Model Information
            let yPos = 50 + imgHeight + 10;
            pdf.setFontSize(14);
            pdf.setTextColor(170, 129, 1);
            pdf.text('Model Information', margin, yPos);
            yPos += 8;

            if (modelInfo.entries.length === 0) {
                pdf.setFontSize(10);
                pdf.setTextColor(120, 120, 120);
                pdf.text('No model information entries.', margin, yPos);
            } else {
                yPos = pdfRenderEntries(pdf, modelInfo.entries, yPos, layout);
            }

            // Summary stats
            yPos += 5;
            if (yPos > pageHeight - 30) {
                pdf.addPage();
                yPos = margin;
            }
            pdf.setFontSize(10);
            pdf.setTextColor(100, 100, 100);
            pdf.text(`Total: ${visibleGroups.length} groups, ${visibleAnnotations.length} annotations`, margin, yPos);
        }

        /**
         * Renders the axis views page with an unfolded cube layout showing six orthogonal views.
         * @param {jsPDF} pdf - The jsPDF instance
         * @param {Object} layout - Page layout constants
         * @param {boolean} includeScalebar - Whether to include scalebar on screenshots
         */
        async function pdfRenderAxisViews(pdf, layout, includeScalebar) {
            const { margin } = layout;

            pdf.addPage();
            pdf.setFontSize(18);
            pdf.setTextColor(170, 129, 1);
            pdf.text('Axis Views', margin, 20);
            pdf.setFontSize(10);
            pdf.setTextColor(120, 120, 120);
            pdf.text('Unfolded cube \u2014 six orthogonal views of the model', margin, 28);

            // Calculate model bounds for consistent framing
            const axisBox = new THREE.Box3().setFromObject(currentModel);
            const axisSize = axisBox.getSize(new THREE.Vector3());
            const axisMaxDim = Math.max(axisSize.x, axisSize.y, axisSize.z);
            const axisDist = axisMaxDim * 1.8;
            const axisTarget = new THREE.Vector3(0, 0, 0);

            // Unfolded cube cross layout (Z-up display convention):
            //             [Top Z+]
            // [Left X-] [Front Y+] [Right X+] [Back Y-]
            //            [Bottom Z-]
            // Note: Internally Three.js uses Y-up, but MeshNotes displays Z-up.
            // Mapping: display Z = internal Y, display Y = internal -Z.
            // "Front" = camera at display +Y (internal -Z) looking toward model.
            const cellSize = 42;
            const cellGap = 3;
            const labelSpace = 8; // extra vertical space for labels between rows
            const gridStartY = 35;

            const axisViews = [
                { name: 'Top',    col: 1, row: 0, dir: new THREE.Vector3(0, 1, 0),  up: new THREE.Vector3(0, 0, -1) },
                { name: 'Left',   col: 0, row: 1, dir: new THREE.Vector3(-1, 0, 0), up: new THREE.Vector3(0, 1, 0) },
                { name: 'Front',  col: 1, row: 1, dir: new THREE.Vector3(0, 0, -1), up: new THREE.Vector3(0, 1, 0) },
                { name: 'Right',  col: 2, row: 1, dir: new THREE.Vector3(1, 0, 0),  up: new THREE.Vector3(0, 1, 0) },
                { name: 'Back',   col: 3, row: 1, dir: new THREE.Vector3(0, 0, 1),  up: new THREE.Vector3(0, 1, 0) },
                { name: 'Bottom', col: 1, row: 2, dir: new THREE.Vector3(0, -1, 0), up: new THREE.Vector3(0, 0, 1) },
            ];

            for (const axView of axisViews) {
                camera.position.copy(axisTarget).addScaledVector(axView.dir, axisDist);
                camera.up.copy(axView.up);
                camera.lookAt(axisTarget);

                if (isOrthographic) {
                    const aspect = canvas.width / canvas.height;
                    const frustumHalf = axisMaxDim * 0.75;
                    camera.left = -frustumHalf * aspect;
                    camera.right = frustumHalf * aspect;
                    camera.top = frustumHalf;
                    camera.bottom = -frustumHalf;
                    camera.updateProjectionMatrix();
                }

                renderer.clear();
                renderer.render(scene, camera);
                await delay(50);
                renderer.render(scene, camera);

                // Crop center square from canvas for cube face
                const cropCanvas = document.createElement('canvas');
                const cropSize = Math.min(canvas.width, canvas.height);
                cropCanvas.width = cropSize;
                cropCanvas.height = cropSize;
                const cropCtx = cropCanvas.getContext('2d');
                const offsetX = (canvas.width - cropSize) / 2;
                const offsetY = (canvas.height - cropSize) / 2;
                cropCtx.drawImage(canvas, offsetX, offsetY, cropSize, cropSize, 0, 0, cropSize, cropSize);

                if (includeScalebar && isOrthographic) {
                    drawScalebarOnCanvas(cropCanvas);
                }

                const axImg = cropCanvas.toDataURL('image/jpeg', 0.9);
                const cellX = margin + axView.col * (cellSize + cellGap);
                const cellY = gridStartY + axView.row * (cellSize + cellGap + labelSpace);

                pdf.setDrawColor(180, 180, 180);
                pdf.setLineWidth(0.3);
                pdf.rect(cellX, cellY, cellSize, cellSize);
                pdf.addImage(axImg, 'JPEG', cellX, cellY, cellSize, cellSize);

                pdf.setFontSize(8);
                pdf.setTextColor(120, 120, 120);
                pdf.text(axView.name, cellX + cellSize / 2, cellY + cellSize + 6, { align: 'center' });
            }
        }

        /**
         * Renders the table of contents page.
         * @param {jsPDF} pdf - The jsPDF instance
         * @param {Array} tocData - Array of {type, name, page} entries
         * @param {Object} layout - Page layout constants
         */
        function pdfRenderTOC(pdf, tocData, layout) {
            const { margin, pageWidth, pageHeight } = layout;

            pdf.addPage();
            pdf.setFontSize(18);
            pdf.setTextColor(170, 129, 1);
            pdf.text('Table of Contents', margin, 20);

            let yPos = 35;
            pdf.setFontSize(10);

            tocData.forEach(item => {
                if (yPos > pageHeight - 20) {
                    pdf.addPage();
                    yPos = 20;
                }

                if (item.type === 'group') {
                    pdf.setTextColor(170, 129, 1);
                    pdf.setFont(undefined, 'bold');
                    pdf.text(item.name, margin, yPos);
                    pdf.setTextColor(100, 100, 100);
                    pdf.text(String(item.page), pageWidth - margin, yPos, { align: 'right' });
                    yPos += 7;
                } else {
                    pdf.setTextColor(60, 60, 60);
                    pdf.setFont(undefined, 'normal');
                    pdf.text('   ' + item.name, margin, yPos);
                    pdf.setTextColor(100, 100, 100);
                    pdf.text(String(item.page), pageWidth - margin, yPos, { align: 'right' });
                    yPos += 6;
                }
            });
        }

        /**
         * Renders a single annotation page with screenshot, metadata, coordinates, and entries.
         * @param {jsPDF} pdf - The jsPDF instance
         * @param {Object} ann - The annotation object
         * @param {Object} group - The group this annotation belongs to
         * @param {Array} groupAnns - All annotations in this group
         * @param {number} annIdx - Index of this annotation within the group
         * @param {Object} layout - Page layout constants
         * @param {boolean} includeScalebar - Whether to include scalebar on screenshots
         */
        async function pdfRenderAnnotationPage(pdf, ann, group, groupAnns, annIdx, layout, includeScalebar) {
            const { margin, contentWidth, pageWidth, pageHeight } = layout;

            pdf.addPage();

            // Group header (first annotation) or colored bar (subsequent)
            let contentStartY;
            if (annIdx === 0) {
                pdf.setFillColor(10, 53, 89);
                pdf.rect(0, 0, pageWidth, 25, 'F');

                const rgb = hexToRgb(group.color);
                pdf.setFillColor(rgb.r, rgb.g, rgb.b);
                pdf.rect(margin, 8, 8, 8, 'F');

                pdf.setFontSize(14);
                pdf.setTextColor(255, 255, 255);
                pdf.text(group.name, margin + 12, 14);

                pdf.setFontSize(10);
                pdf.setTextColor(200, 200, 200);
                pdf.text(`${groupAnns.length} annotation${groupAnns.length !== 1 ? 's' : ''}`, margin + 12, 21);
                contentStartY = 32;
            } else {
                const headerRgb = hexToRgb(group.color);
                pdf.setFillColor(headerRgb.r, headerRgb.g, headerRgb.b);
                pdf.rect(0, 0, pageWidth, 12, 'F');

                pdf.setFontSize(10);
                pdf.setTextColor(255, 255, 255);
                pdf.text(group.name, margin, 8);
                contentStartY = 22;
            }

            // Position camera to frame the annotation
            const center = new THREE.Vector3();
            const annPoints = ann.points.map(p => new THREE.Vector3(p.x, p.y, p.z));
            annPoints.forEach(p => center.add(p));
            center.divideScalar(annPoints.length);

            let annExtent = 0;
            if (annPoints.length > 1) {
                const annBox = new THREE.Box3().setFromPoints(annPoints);
                const annSize = annBox.getSize(new THREE.Vector3());
                annExtent = Math.max(annSize.x, annSize.y, annSize.z);
            }

            const box = new THREE.Box3().setFromObject(currentModel);
            const modelSize = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(modelSize.x, modelSize.y, modelSize.z);
            const baseDistance = annExtent > 0 ? annExtent * 2 : maxDim * 0.15;
            const distance = Math.max(baseDistance, maxDim * 0.08);

            const angle = Math.PI / 3; // 60 degrees from horizontal
            const horizontalOffset = distance * Math.cos(angle);
            const verticalOffset = distance * Math.sin(angle);
            const horizontalDir = new THREE.Vector3(1, 0, 1).normalize();

            camera.position.set(
                center.x + horizontalDir.x * horizontalOffset,
                center.y + verticalOffset,
                center.z + horizontalDir.z * horizontalOffset
            );
            controls.target.copy(center);
            camera.lookAt(center);

            if (isOrthographic) {
                const aspect = canvas.width / canvas.height;
                const frustumHalf = distance * 0.8;
                camera.left = -frustumHalf * aspect;
                camera.right = frustumHalf * aspect;
                camera.top = frustumHalf;
                camera.bottom = -frustumHalf;
                camera.zoom = 1;
                camera.updateProjectionMatrix();
            }

            controls.update();

            // Temporarily enlarge markers for visibility in screenshot
            const originalScales = [];
            annotationObjects.children.forEach(obj => {
                if (obj.userData.annotationId === ann.id && obj.isMesh) {
                    originalScales.push({ obj, scale: obj.scale.clone() });
                    if (obj.geometry.type === 'SphereGeometry') {
                        obj.scale.multiplyScalar(2.5);
                    }
                }
            });

            // For surface annotations, temporarily increase opacity
            let originalOpacity = null;
            if (ann.type === 'surface') {
                annotationObjects.children.forEach(obj => {
                    if (obj.userData.annotationId === ann.id && obj.isMesh && obj.material) {
                        originalOpacity = obj.material.opacity;
                        obj.material.opacity = 0.75;
                        obj.material.needsUpdate = true;
                    }
                });
            }

            // Render and capture
            renderer.clear();
            renderer.render(scene, camera);
            await delay(50);
            renderer.render(scene, camera);

            const screenshot = pdfCaptureScreenshot(includeScalebar);

            // Restore marker scales and surface opacity
            originalScales.forEach(({ obj, scale }) => obj.scale.copy(scale));
            if (ann.type === 'surface' && originalOpacity !== null) {
                annotationObjects.children.forEach(obj => {
                    if (obj.userData.annotationId === ann.id && obj.isMesh && obj.material) {
                        obj.material.opacity = originalOpacity;
                        obj.material.needsUpdate = true;
                    }
                });
            }

            // Annotation name and type
            pdf.setFontSize(16);
            pdf.setTextColor(60, 60, 60);
            pdf.text(ann.name || 'Unnamed', margin, contentStartY);

            pdf.setFontSize(9);
            pdf.setTextColor(150, 150, 150);
            const typeLabels = { point: 'Point', line: 'Line', polygon: 'Polygon', surface: 'Surface' };
            pdf.text(typeLabels[ann.type] || ann.type, margin, contentStartY + 6);

            // Screenshot
            const canvasAspect = canvas.width / canvas.height;
            const screenshotHeight = contentWidth / canvasAspect;
            const screenshotY = contentStartY + 10;
            pdf.addImage(screenshot, 'JPEG', margin, screenshotY, contentWidth, screenshotHeight);

            // Coordinates
            pdf.setFontSize(7);
            pdf.setTextColor(150, 150, 150);
            const coordStrings = ann.points.map((p, i) =>
                `P${i + 1}: (${p.x.toFixed(2)}, ${p.y.toFixed(2)}, ${p.z.toFixed(2)})`
            );
            const coordLine = coordStrings.join('  \u2022  ');
            const coordLines = pdf.splitTextToSize(coordLine, contentWidth);
            pdf.text(coordLines, margin, screenshotY + screenshotHeight + 4);
            const coordHeight = coordLines.length * 3;

            // Entries
            let yPos = screenshotY + screenshotHeight + 6 + coordHeight;
            const entries = ann.entries || [];

            if (entries.length === 0) {
                pdf.setFontSize(10);
                pdf.setTextColor(150, 150, 150);
                pdf.text('No entries.', margin, yPos);
            } else {
                pdfRenderEntries(pdf, entries, yPos, layout);
            }
        }

        // ============ PDF Export (main coordinator) ============

        /**
         * Generates a multi-page PDF report with title page, axis views,
         * table of contents, and one page per annotation with auto-screenshots.
         * @param {boolean} includeScalebar - Whether to include scalebar on screenshots
         */
        async function doExportPdfReport(includeScalebar) {
            // Store and override light settings for consistent screenshots
            const originalLightMode = lightFollowsCamera;
            lightFollowsCamera = true;

            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF('p', 'mm', 'a4');
            const layout = {
                pageWidth: 210,
                pageHeight: 297,
                margin: 15,
                contentWidth: 210 - 30  // pageWidth - 2*margin
            };

            // Save camera state
            const savedCamera = pdfSaveCameraState();

            showStatus('Generating PDF report...');
            renderAnnotations();
            await delay(100);

            // Determine visible content
            const visibleGroups = groups.filter(g => g.visible);
            const visibleAnnotations = annotations.filter(ann => {
                const group = groups.find(g => g.id === ann.groupId);
                return group && group.visible;
            });

            // Build table of contents data
            const tocData = [];
            let pageNum = 4; // After title, axis views, and TOC pages
            visibleGroups.forEach(group => {
                const groupAnns = visibleAnnotations.filter(a => a.groupId === group.id);
                if (groupAnns.length > 0) {
                    tocData.push({ type: 'group', name: group.name, page: pageNum });
                    groupAnns.forEach((ann, idx) => {
                        if (idx === 0) {
                            tocData.push({ type: 'annotation', name: ann.name, page: pageNum });
                        } else {
                            tocData.push({ type: 'annotation', name: ann.name, page: pageNum });
                        }
                        pageNum++;
                    });
                }
            });

            // Render each section
            await pdfRenderTitlePage(pdf, layout, includeScalebar, visibleGroups, visibleAnnotations);

            await pdfRenderAxisViews(pdf, layout, includeScalebar);
            pdfRestoreCamera(savedCamera);

            pdfRenderTOC(pdf, tocData, layout);

            // Render annotation pages
            for (const group of visibleGroups) {
                const groupAnns = visibleAnnotations.filter(a => a.groupId === group.id);
                if (groupAnns.length === 0) continue;

                for (let annIdx = 0; annIdx < groupAnns.length; annIdx++) {
                    await pdfRenderAnnotationPage(pdf, groupAnns[annIdx], group, groupAnns, annIdx, layout, includeScalebar);
                }
            }

            // Restore everything
            pdfRestoreCamera(savedCamera);
            lightFollowsCamera = originalLightMode;
            if (!lightFollowsCamera) {
                updateFixedLightDirection();
            }
            renderAnnotations();
            renderer.render(scene, camera);

            // Save
            pdf.save(`meshnotes-report-${modelFileName || 'export'}-${Date.now()}.pdf`);
            showStatus('PDF report exported');
        }

        function getModelMimeType() {
            if (!modelFileName) return 'model/gltf-binary';
            const ext = modelFileName.toLowerCase().split('.').pop();
            if (ext === 'obj') return 'model/obj';
            if (ext === 'ply') return 'model/ply';
            return 'model/gltf-binary';
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 200, g: 200, b: 200 };
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // ============ Download Manual as PDF ============
        function downloadManualAsPdf() {
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF('p', 'mm', 'a4');
            const pageWidth = 210;
            const pageHeight = 297;
            const margin = 20;
            const contentWidth = pageWidth - (margin * 2);
            const lineHeight = 6;
            const headerLineHeight = 8;
            
            let yPos = margin;
            
            // ===== TITLE PAGE =====
            pdf.setFontSize(28);
            pdf.setTextColor(170, 129, 1); // Gold color
            pdf.text('MeshNotes', pageWidth / 2, 50, { align: 'center' });
            
            pdf.setFontSize(20);
            pdf.setTextColor(60, 60, 60);
            pdf.text('User Manual', pageWidth / 2, 65, { align: 'center' });
            
            // Date
            pdf.setFontSize(11);
            pdf.setTextColor(120, 120, 120);
            const dateStr = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
            pdf.text(`Generated: ${dateStr}`, pageWidth / 2, 80, { align: 'center' });
            
            // Subtitle/description
            pdf.setFontSize(11);
            pdf.setTextColor(80, 80, 80);
            const subtitle = 'A browser-based tool for annotating 3D models with points, lines, polygons, and surfaces, designed for cultural heritage documentation.';
            const subtitleLines = pdf.splitTextToSize(subtitle, contentWidth - 20);
            pdf.text(subtitleLines, pageWidth / 2, 100, { align: 'center' });
            
            // Website
            pdf.setFontSize(10);
            pdf.setTextColor(170, 129, 1);
            pdf.textWithLink('github.com/NilsSchnorr/MeshNotes', pageWidth / 2, 130, { 
                align: 'center', 
                url: 'https://github.com/NilsSchnorr/MeshNotes' 
            });
            
            // ===== EXTRACT MANUAL CONTENT =====
            const manualItems = document.querySelectorAll('#about-modal-content .manual-item');
            const manualContent = [];
            
            manualItems.forEach(item => {
                const headerEl = item.querySelector('.manual-item-header');
                const contentEl = item.querySelector('.manual-item-content');
                
                if (headerEl && contentEl) {
                    // Get title text (without the toggle icon)
                    let title = headerEl.textContent.trim();
                    // Remove the toggle icon character at the end
                    title = title.replace(/[\u25B6\u25BC]$/, '').trim();
                    
                    // Get content HTML and extract text
                    // Clone the content to process it
                    const contentClone = contentEl.cloneNode(true);
                    
                    // Extract paragraphs, lists, and notes with proper structure
                    const paragraphs = [];
                    
                    // Helper function to process a limitation note with potential nested content
                    function processLimitationNote(noteEl) {
                        const noteContent = [];
                        
                        // Get direct text content (not from child elements)
                        // by cloning and removing child elements
                        const clonedNote = noteEl.cloneNode(true);
                        const nestedLists = clonedNote.querySelectorAll('ul');
                        nestedLists.forEach(ul => ul.remove());
                        const directText = clonedNote.textContent.trim();
                        
                        if (directText) {
                            noteContent.push({ type: 'note-text', text: directText });
                        }
                        
                        // Process nested lists within the note
                        const lists = noteEl.querySelectorAll('ul');
                        lists.forEach(ul => {
                            const listItems = [];
                            ul.querySelectorAll('li').forEach(li => {
                                listItems.push(li.textContent.trim());
                            });
                            if (listItems.length > 0) {
                                noteContent.push({ type: 'note-list', items: listItems });
                            }
                        });
                        
                        return { type: 'note', content: noteContent };
                    }
                    
                    // Gather all p, ul, and .limitation-note elements
                    const allElements = contentClone.querySelectorAll('p, ul, .limitation-note');
                    
                    if (allElements.length > 0) {
                        allElements.forEach(child => {
                            // Skip if this element is nested inside a limitation-note
                            if (child.closest('.limitation-note') && !child.classList.contains('limitation-note')) {
                                return;
                            }
                            
                            if (child.classList && child.classList.contains('limitation-note')) {
                                // Process limitation note with potential nested content
                                paragraphs.push(processLimitationNote(child));
                            } else if (child.tagName === 'UL') {
                                // Process unordered list
                                const listItems = [];
                                child.querySelectorAll('li').forEach(li => {
                                    listItems.push(li.textContent.trim());
                                });
                                if (listItems.length > 0) {
                                    paragraphs.push({ type: 'list', items: listItems });
                                }
                            } else {
                                // Regular paragraph
                                paragraphs.push({ type: 'paragraph', text: child.textContent.trim() });
                            }
                        });
                    } else {
                        // Fallback: just get all text
                        paragraphs.push({ type: 'paragraph', text: contentEl.textContent.trim() });
                    }
                    
                    manualContent.push({ title, paragraphs });
                }
            });
            
            // ===== ADD CONTENT PAGES =====
            pdf.addPage();
            yPos = margin;
            
            // Table of Contents
            pdf.setFontSize(18);
            pdf.setTextColor(170, 129, 1);
            pdf.text('Table of Contents', margin, yPos);
            yPos += 12;
            
            // List all sections in TOC
            pdf.setFontSize(11);
            pdf.setTextColor(60, 60, 60);
            manualContent.forEach((section, index) => {
                if (yPos > pageHeight - margin) {
                    pdf.addPage();
                    yPos = margin;
                }
                pdf.text(`${index + 1}. ${section.title}`, margin + 5, yPos);
                yPos += 7;
            });
            
            // ===== MANUAL SECTIONS =====
            manualContent.forEach((section, index) => {
                // Always start each section on a new position with some space
                // Check if we need a new page
                if (yPos > pageHeight - 60) {
                    pdf.addPage();
                    yPos = margin;
                } else {
                    yPos += 10; // Add spacing between sections
                }
                
                // Section header
                pdf.setFontSize(14);
                pdf.setTextColor(170, 129, 1);
                pdf.setFont(undefined, 'bold');
                pdf.text(`${index + 1}. ${section.title}`, margin, yPos);
                yPos += headerLineHeight + 2;
                
                // Underline
                pdf.setDrawColor(170, 129, 1);
                pdf.setLineWidth(0.3);
                pdf.line(margin, yPos - 4, margin + contentWidth, yPos - 4);
                yPos += 2;
                
                // Section content
                pdf.setFont(undefined, 'normal');
                pdf.setFontSize(10);
                
                section.paragraphs.forEach(para => {
                    if (yPos > pageHeight - margin - 10) {
                        pdf.addPage();
                        yPos = margin;
                    }
                    
                    if (para.type === 'note') {
                        // Draw note box with potentially nested content (text + lists)
                        pdf.setFillColor(255, 248, 230); // Light yellow background
                        pdf.setDrawColor(232, 163, 60); // Orange border
                        
                        // Calculate total height needed for the note
                        let noteHeight = 8; // Base padding
                        const noteContentLines = [];
                        
                        para.content.forEach(item => {
                            if (item.type === 'note-text') {
                                const textLines = pdf.splitTextToSize(item.text, contentWidth - 14);
                                noteContentLines.push({ type: 'text', lines: textLines });
                                noteHeight += textLines.length * 5 + 2;
                            } else if (item.type === 'note-list') {
                                const listLines = [];
                                item.items.forEach(listItem => {
                                    const itemLines = pdf.splitTextToSize('• ' + listItem, contentWidth - 20);
                                    listLines.push(...itemLines);
                                });
                                noteContentLines.push({ type: 'list', lines: listLines });
                                noteHeight += listLines.length * 5 + 2;
                            }
                        });
                        
                        // Check if note fits on page
                        if (yPos + noteHeight > pageHeight - margin) {
                            pdf.addPage();
                            yPos = margin;
                        }
                        
                        pdf.roundedRect(margin, yPos - 2, contentWidth, noteHeight, 2, 2, 'FD');
                        
                        // Render note content
                        pdf.setTextColor(100, 80, 40);
                        let noteYPos = yPos + 4;
                        
                        noteContentLines.forEach(content => {
                            if (content.type === 'text') {
                                content.lines.forEach(line => {
                                    pdf.text(line, margin + 5, noteYPos);
                                    noteYPos += 5;
                                });
                                noteYPos += 1; // Small gap after text
                            } else if (content.type === 'list') {
                                content.lines.forEach(line => {
                                    pdf.text(line, margin + 8, noteYPos);
                                    noteYPos += 5;
                                });
                                noteYPos += 1; // Small gap after list
                            }
                        });
                        
                        yPos += noteHeight + 4;
                    } else if (para.type === 'list') {
                        // Render standalone list
                        pdf.setTextColor(60, 60, 60);
                        
                        para.items.forEach(item => {
                            const itemLines = pdf.splitTextToSize('• ' + item, contentWidth - 10);
                            
                            itemLines.forEach((line, idx) => {
                                if (yPos > pageHeight - margin) {
                                    pdf.addPage();
                                    yPos = margin;
                                }
                                // Indent continuation lines (lines after the first)
                                const xPos = idx === 0 ? margin + 5 : margin + 8;
                                pdf.text(line, xPos, yPos);
                                yPos += 5;
                            });
                        });
                        yPos += 3; // Extra space after list
                    } else {
                        // Regular paragraph
                        pdf.setTextColor(60, 60, 60);
                        const textLines = pdf.splitTextToSize(para.text, contentWidth);
                        
                        textLines.forEach(line => {
                            if (yPos > pageHeight - margin) {
                                pdf.addPage();
                                yPos = margin;
                            }
                            pdf.text(line, margin, yPos);
                            yPos += 5;
                        });
                        yPos += 3; // Extra space between paragraphs
                    }
                });
            });
            
            // ===== FOOTER ON EACH PAGE =====
            const pageCount = pdf.internal.getNumberOfPages();
            pdf.setFontSize(8);
            pdf.setTextColor(150, 150, 150);
            
            for (let i = 1; i <= pageCount; i++) {
                pdf.setPage(i);
                pdf.text(
                    `MeshNotes Manual - Page ${i} of ${pageCount}`,
                    pageWidth / 2,
                    pageHeight - 10,
                    { align: 'center' }
                );
            }
            
            // Save PDF
            pdf.save(`MeshNotes-Manual-${new Date().toISOString().split('T')[0]}.pdf`);
        }

        function importAnnotations(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Check if this is W3C format (has @context and type: AnnotationCollection)
                    if (data['@context'] && data.type === 'AnnotationCollection') {
                        importW3CAnnotations(data);
                    }
                    // Legacy format support (old MeshNotes format)
                    else if (data.groups && data.annotations) {
                        importLegacyAnnotations(data);
                    }
                    else {
                        showStatus('Invalid annotation file format');
                    }
                } catch (error) {
                    console.error('Import error:', error);
                    showStatus('Error importing file');
                }
            };
            reader.readAsText(file);
        }
        
        /**
         * Imports a W3C Web Annotation Collection with intelligent merge support.
         * Uses UUID-based duplicate detection: existing annotations are updated
         * (entries merged by UUID, newer timestamps win), new annotations are added.
         * Also imports groups and model info with the same merge strategy.
         * @param {Object} data - Parsed W3C AnnotationCollection JSON-LD
         */
        function importW3CAnnotations(data) {
            // Import W3C Web Annotation Collection format with merge support
            const groupIdMap = {};
            let addedCount = 0;
            let mergedCount = 0;
            let skippedCount = 0;
            
            // Detect coordinate system of imported file
            // Files with upAxis 'Z' (or 'z') contain Z-up coordinates that need
            // transformation to Three.js Y-up space. Legacy files (upAxis 'Y',
            // 'y', or missing) are already in Y-up space and need no transform.
            const importedUpAxis = (data['upAxis'] || data['meshnotes:upAxis'] || '').toString().toUpperCase();
            const needsTransform = (importedUpAxis === 'Z');
            
            // Helper: transform all coordinates in an annotation from Z-up to Three.js Y-up
            function transformAnnotationCoords(ann) {
                if (!needsTransform) return;
                ann.points = ann.points.map(p => pointFromZUp(p));
            }
            
            // Helper: get effective timestamp for an entry (modified or created)
            function entryTimestamp(entry) {
                return entry.modified || entry.timestamp || entry.created || '';
            }
            
            // Helper: merge entries from imported annotation into existing annotation
            function mergeEntries(existingEntries, importedEntries) {
                let entriesAdded = 0;
                let entriesUpdated = 0;
                
                importedEntries.forEach(importedEntry => {
                    // Match by UUID first, then fall back to content match
                    // (content match handles old exports without entry UUIDs)
                    let existingEntry = existingEntries.find(e => e.uuid === importedEntry.uuid);
                    if (!existingEntry) {
                        existingEntry = existingEntries.find(e => 
                            e.description === importedEntry.description && 
                            e.author === importedEntry.author && 
                            e.timestamp === importedEntry.timestamp
                        );
                    }
                    
                    if (!existingEntry) {
                        // New entry - add it
                        existingEntries.push(importedEntry);
                        entriesAdded++;
                    } else {
                        // Existing entry - check if imported version is newer
                        const existingTime = entryTimestamp(existingEntry);
                        const importedTime = entryTimestamp(importedEntry);
                        
                        if (importedTime > existingTime) {
                            // Imported version is newer - update
                            existingEntry.description = importedEntry.description;
                            existingEntry.author = importedEntry.author;
                            existingEntry.modified = importedEntry.modified;
                            existingEntry.links = importedEntry.links || [];
                            entriesUpdated++;
                        }
                        // else: local version is same or newer, skip
                    }
                });
                
                // Sort entries chronologically
                existingEntries.sort((a, b) => {
                    const timeA = a.timestamp || '';
                    const timeB = b.timestamp || '';
                    return timeA.localeCompare(timeB);
                });
                
                return { entriesAdded, entriesUpdated };
            }
            
            // Merge model info entries
            const importedModelInfo = data['modelInfo'] || data['meshnotes:modelInfo'];
            if (importedModelInfo && importedModelInfo.body) {
                const bodies = Array.isArray(importedModelInfo.body) 
                    ? importedModelInfo.body 
                    : [importedModelInfo.body];
                
                const importedEntries = bodies.map((body, idx) => ({
                    id: Date.now() + idx + Math.floor(Math.random() * 1000),
                    uuid: body['meshnotes:entryUuid'] || generateUUID(),
                    description: body.value || '',
                    author: body.creator ? body.creator.name : '',
                    timestamp: body.created || new Date().toISOString(),
                    modified: body.modified || undefined,
                    links: body['schema:url'] || []
                }));
                
                mergeEntries(modelInfo.entries, importedEntries);
                updateModelInfoDisplay();
            }
            
            // Import groups - match by UUID first, then by name
            if (data['meshnotes:groups']) {
                data['meshnotes:groups'].forEach(importedGroup => {
                    const groupUuid = importedGroup['meshnotes:uuid'];
                    const groupName = importedGroup['schema:name'] || importedGroup.name || 'Imported Group';
                    
                    // Try to find existing group by UUID first, then by name
                    let existing = null;
                    if (groupUuid) {
                        existing = groups.find(g => g.uuid === groupUuid);
                    }
                    if (!existing) {
                        existing = groups.find(g => g.name === groupName);
                    }
                    
                    if (!existing) {
                        // New group - create it
                        const newGroupId = Date.now() + Math.floor(Math.random() * 10000);
                        const newGroup = {
                            id: newGroupId,
                            uuid: groupUuid || generateUUID(),
                            name: groupName,
                            color: importedGroup['schema:color'] || importedGroup.color || '#4CAF50',
                            visible: importedGroup['meshnotes:visible'] !== false
                        };
                        // Map both internal ID and UUID for annotation lookup
                        groupIdMap[importedGroup.id] = newGroupId;
                        if (groupUuid) groupIdMap['uuid:' + groupUuid] = newGroupId;
                        groups.push(newGroup);
                    } else {
                        // Existing group - map IDs
                        groupIdMap[importedGroup.id] = existing.id;
                        if (groupUuid) groupIdMap['uuid:' + groupUuid] = existing.id;
                    }
                });
            }
            
            // Import annotations from first page with merge
            if (data.first && data.first.items) {
                data.first.items.forEach(w3cAnn => {
                    const importedAnn = convertFromW3CAnnotation(w3cAnn, groupIdMap);
                    
                    // Transform coordinates from Z-up to Three.js Y-up if needed
                    transformAnnotationCoords(importedAnn);
                    
                    // If no group assigned, use default
                    if (!importedAnn.groupId) {
                        if (groups.length === 0) {
                            groups.push({ id: Date.now(), uuid: generateUUID(), name: 'Default', color: '#4CAF50', visible: true });
                        }
                        importedAnn.groupId = groups[0].id;
                    }
                    
                    // Check if annotation with same UUID already exists
                    const existingAnn = annotations.find(a => a.uuid === importedAnn.uuid);
                    
                    if (!existingAnn) {
                        // New annotation - add it
                        annotations.push(importedAnn);
                        addedCount++;
                    } else {
                        // Existing annotation - merge
                        // Determine which version is newer by latest entry timestamp
                        const existingLatest = existingAnn.entries.length > 0 
                            ? Math.max(...existingAnn.entries.map(e => new Date(entryTimestamp(e)).getTime() || 0)) 
                            : 0;
                        const importedLatest = importedAnn.entries.length > 0 
                            ? Math.max(...importedAnn.entries.map(e => new Date(entryTimestamp(e)).getTime() || 0)) 
                            : 0;
                        
                        // Update metadata (name, group, geometry) if imported version is newer
                        if (importedLatest > existingLatest) {
                            existingAnn.name = importedAnn.name;
                            existingAnn.groupId = importedAnn.groupId;
                            existingAnn.points = importedAnn.points;
                            if (importedAnn.faceData) existingAnn.faceData = importedAnn.faceData;
                            if (importedAnn.projectedEdges) existingAnn.projectedEdges = importedAnn.projectedEdges;
                        }
                        
                        // Merge body entries
                        const result = mergeEntries(existingAnn.entries, importedAnn.entries);
                        
                        if (result.entriesAdded > 0 || result.entriesUpdated > 0) {
                            mergedCount++;
                        } else {
                            skippedCount++;
                        }
                    }
                });
            }
            
            // Re-project imported annotations onto current model surface
            reprojectAllAnnotations();
            
            updateGroupsList();
            renderAnnotations();
            
            // Build status message
            const parts = [];
            if (addedCount > 0) parts.push(`${addedCount} added`);
            if (mergedCount > 0) parts.push(`${mergedCount} merged`);
            if (skippedCount > 0) parts.push(`${skippedCount} unchanged`);
            showStatus(`Import: ${parts.join(', ') || 'nothing to import'}`);
        }
        
        function importLegacyAnnotations(data) {
            // Import legacy MeshNotes format (for backward compatibility)
            console.warn('Importing legacy format - consider re-exporting to W3C format');
            
            // Import model info if present
            if (data.modelInfo && data.modelInfo.entries) {
                data.modelInfo.entries.forEach(entry => {
                    modelInfo.entries.push({
                        ...entry,
                        id: Date.now() + Math.floor(Math.random() * 10000),
                        uuid: entry.uuid || generateUUID()
                    });
                });
                updateModelInfoDisplay();
            }
            
            // Merge groups (avoid duplicates by name)
            data.groups.forEach(importedGroup => {
                const existing = groups.find(g => g.name === importedGroup.name);
                if (!existing) {
                    const newGroupId = Date.now() + Math.floor(Math.random() * 10000);
                    const newGroup = {
                        ...importedGroup,
                        id: newGroupId,
                        uuid: importedGroup.uuid || generateUUID()
                    };
                    
                    data.annotations.forEach(ann => {
                        if (ann.groupId === importedGroup.id) {
                            ann.groupId = newGroupId;
                        }
                    });
                    
                    groups.push(newGroup);
                } else {
                    data.annotations.forEach(ann => {
                        if (ann.groupId === importedGroup.id) {
                            ann.groupId = existing.id;
                        }
                    });
                }
            });

            // Add annotations with new IDs
            let idOffset = 0;
            data.annotations.forEach(ann => {
                idOffset++;
                const newAnn = {
                    ...ann,
                    id: Date.now() + idOffset,
                    uuid: ann.uuid || generateUUID()
                };
                // Ensure entries have UUIDs
                if (newAnn.entries) {
                    newAnn.entries = newAnn.entries.map(entry => ({
                        ...entry,
                        uuid: entry.uuid || generateUUID()
                    }));
                }
                annotations.push(newAnn);
            });

            // Re-project imported annotations onto current model surface
            reprojectAllAnnotations();
            
            updateGroupsList();
            renderAnnotations();
            showStatus(`Imported ${data.annotations.length} annotations (legacy format)`);
        }

        // ============ Utilities ============
        function showStatus(message) {
            status.textContent = message;
            status.classList.add('visible');
            setTimeout(() => {
                status.classList.remove('visible');
            }, 3000);
        }
        
        function updateFaceCountDisplay(count) {
            const formatted = count.toLocaleString();
            
            if (count > 1000000) {
                faceCountDisplay.innerHTML = `<span class="warning">⚠️ ${formatted} faces</span> (Surface tool may be slow)`;
            } else if (count > 500000) {
                faceCountDisplay.innerHTML = `<span class="warning">${formatted} faces</span> (Surface tool may lag)`;
            } else {
                faceCountDisplay.textContent = `${formatted} faces`;
            }
            
            modelStats.classList.add('visible');
        }

        function filterAnnotations(searchTerm) {
            const term = searchTerm.toLowerCase().trim();
            
            // Get all group items and annotation items
            const groupItems = groupsContainer.querySelectorAll('.group-item');
            
            groupItems.forEach(groupItem => {
                const annotationItems = groupItem.querySelectorAll('.annotation-item');
                let hasVisibleAnnotation = false;
                
                annotationItems.forEach(annItem => {
                    const name = annItem.querySelector('.name')?.textContent.toLowerCase() || '';
                    
                    if (term === '' || name.includes(term)) {
                        annItem.classList.remove('search-hidden');
                        hasVisibleAnnotation = true;
                    } else {
                        annItem.classList.add('search-hidden');
                    }
                });
                
                // Hide group if no annotations match (unless search is empty)
                if (term === '') {
                    groupItem.classList.remove('search-hidden');
                } else if (hasVisibleAnnotation) {
                    groupItem.classList.remove('search-hidden');
                } else {
                    groupItem.classList.add('search-hidden');
                }
            });
        }

        function toggleManualItem(header) {
            header.classList.toggle('expanded');
            const content = header.nextElementSibling;
            content.classList.toggle('expanded');
        }
        // Make accessible for inline onclick handlers
        window.toggleManualItem = toggleManualItem;

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ============ Event Listeners ============
        btnLoad.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) loadModel(e.target.files[0]);
            fileInput.value = ''; // Reset so same file can be loaded again
        });
        
        // Helper: read selected up-axis from a dialog's radio buttons
        function getSelectedUpAxis(radioName) {
            const selected = document.querySelector(`input[name="${radioName}"]:checked`);
            return selected ? selected.value : 'z-up';
        }

        // OBJ dialog event listeners
        let pendingObjUpAxis = 'z-up'; // Holds up-axis choice while file picker is open
        objLoadPlain.addEventListener('click', () => {
            const upAxis = getSelectedUpAxis('obj-up-axis');
            objDialogOverlay.classList.remove('visible');
            if (pendingObjFile) {
                loadOBJModel(pendingObjFile, null, upAxis);
                pendingObjFile = null;
            }
        });
        
        objAddMaterials.addEventListener('click', () => {
            pendingObjUpAxis = getSelectedUpAxis('obj-up-axis');
            objDialogOverlay.classList.remove('visible');
            objMaterialInput.click();
            
            // Handle case where user cancels the file picker
            const handleCancel = () => {
                window.removeEventListener('focus', handleCancel);
                setTimeout(() => {
                    if (pendingObjFile && objMaterialInput.files.length === 0) {
                        loadOBJModel(pendingObjFile, null, pendingObjUpAxis);
                        pendingObjFile = null;
                    }
                }, 300);
            };
            window.addEventListener('focus', handleCancel);
        });
        
        objMaterialInput.addEventListener('change', (e) => {
            if (pendingObjFile) {
                const materialFiles = Array.from(e.target.files);
                loadOBJModel(pendingObjFile, materialFiles, pendingObjUpAxis);
                pendingObjFile = null;
            }
            objMaterialInput.value = ''; // Reset
        });

        // PLY dialog event listeners
        let pendingPlyUpAxis = 'z-up'; // Holds up-axis choice while file picker is open
        plyLoadPlain.addEventListener('click', () => {
            const upAxis = getSelectedUpAxis('ply-up-axis');
            plyDialogOverlay.classList.remove('visible');
            if (pendingPlyFile) {
                loadPLYModel(pendingPlyFile, null, upAxis);
                pendingPlyFile = null;
            }
        });

        plyAddTexture.addEventListener('click', () => {
            pendingPlyUpAxis = getSelectedUpAxis('ply-up-axis');
            plyDialogOverlay.classList.remove('visible');
            plyTextureInput.click();

            // Handle case where user cancels the file picker
            const handleCancel = () => {
                window.removeEventListener('focus', handleCancel);
                setTimeout(() => {
                    if (pendingPlyFile && plyTextureInput.files.length === 0) {
                        loadPLYModel(pendingPlyFile, null, pendingPlyUpAxis);
                        pendingPlyFile = null;
                    }
                }, 300);
            };
            window.addEventListener('focus', handleCancel);
        });

        plyTextureInput.addEventListener('change', (e) => {
            if (pendingPlyFile) {
                const textureFile = e.target.files[0] || null;
                loadPLYModel(pendingPlyFile, textureFile, pendingPlyUpAxis);
                pendingPlyFile = null;
            }
            plyTextureInput.value = ''; // Reset
        });

        btnTexture.addEventListener('click', toggleTexture);
        btnPoint.addEventListener('click', () => setTool('point'));
        btnLine.addEventListener('click', () => setTool('line'));
        btnPolygon.addEventListener('click', () => setTool('polygon'));
        btnSurface.addEventListener('click', () => setTool('surface'));
        btnMeasure.addEventListener('click', () => setTool('measure'));
        btnScreenshot.addEventListener('click', takeScreenshot);
        btnExport.addEventListener('click', exportAnnotations);
        btnExportPdf.addEventListener('click', exportPdfReport);
        btnImport.addEventListener('click', () => importInput.click());
        importInput.addEventListener('change', (e) => {
            if (e.target.files[0]) importAnnotations(e.target.files[0]);
        });
        
        // Brush size slider
        brushSlider.addEventListener('input', (e) => {
            surfaceBrushSize = parseFloat(e.target.value);
            brushValue.textContent = surfaceBrushSize + '%';
        });
        
        // Search filter
        searchInput.addEventListener('input', (e) => {
            filterAnnotations(e.target.value);
        });

        btnAddGroup.addEventListener('click', () => openGroupPopup());
        btnGroupSave.addEventListener('click', saveGroup);
        btnGroupCancel.addEventListener('click', () => {
            groupPopup.classList.remove('visible');
            editingGroup = null;
        });
        btnGroupDelete.addEventListener('click', () => {
            if (editingGroup) deleteGroup(editingGroup);
        });

        btnPopupSave.addEventListener('click', saveAnnotation);
        btnPopupCancel.addEventListener('click', () => {
            annotationPopup.classList.remove('visible');
            clearTempDrawing();
            editingAnnotation = null;
            editingModelInfo = false;
            isAddingEntry = false;
            editingEntryId = null;
        });
        btnPopupDelete.addEventListener('click', deleteAnnotation);
        btnAddLink.addEventListener('click', addLink);
        annNewLink.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') addLink();
        });
        
        // Add Entry button
        btnAddEntry.addEventListener('click', showAddEntryForm);
        
        // Model Info double-click
        modelInfoItem.addEventListener('dblclick', openModelInfoPopup);
        
        // Confirmation dialog
        confirmOk.addEventListener('click', () => {
            if (confirmCallback) confirmCallback();
            hideConfirm();
        });
        confirmCancel.addEventListener('click', hideConfirm);
        confirmOverlay.addEventListener('click', (e) => {
            if (e.target === confirmOverlay) hideConfirm();
        });
        
        // Scalebar confirmation dialog
        scalebarSwitch.addEventListener('click', () => {
            if (scalebarConfirmCallback) scalebarConfirmCallback();
            hideScalebarConfirm();
        });
        scalebarNoSwitch.addEventListener('click', () => {
            const callback = scalebarNoSwitchCallback;
            hideScalebarConfirm();
            if (callback) callback();
        });
        scalebarConfirmOverlay.addEventListener('click', (e) => {
            if (e.target === scalebarConfirmOverlay) hideScalebarConfirm();
        });

        canvas.addEventListener('click', onCanvasClick);
        canvas.addEventListener('dblclick', onCanvasDblClick);
        canvas.addEventListener('mousedown', onCanvasMouseDown);
        canvas.addEventListener('mousemove', onCanvasMouseMove);
        canvas.addEventListener('mouseup', onCanvasMouseUp);

        brightnessSlider.addEventListener('input', (e) => setBrightness(parseInt(e.target.value)));
        opacitySlider.addEventListener('input', (e) => setModelOpacity(parseInt(e.target.value)));
        
        // Light controls
        lightToggle.addEventListener('click', toggleLightMode);
        lightAzimuthSlider.addEventListener('input', (e) => setLightAzimuth(parseInt(e.target.value)));
        lightElevationSlider.addEventListener('input', (e) => setLightElevation(parseInt(e.target.value)));
        pointSizeSlider.addEventListener('input', (e) => setPointSize(parseInt(e.target.value)));
        textSizeSlider.addEventListener('input', (e) => setTextSize(parseInt(e.target.value)));

        // Sliders panel toggle
        slidersPanelToggle.addEventListener('click', () => {
            slidersPanel.classList.toggle('collapsed');
            slidersPanelToggle.textContent = slidersPanel.classList.contains('collapsed') ? '▲' : '▼';
        });

        // Popup dragging
        popupTitle.addEventListener('mousedown', (e) => {
            isDraggingPopup = true;
            const rect = annotationPopup.getBoundingClientRect();
            popupDragOffsetX = e.clientX - rect.left;
            popupDragOffsetY = e.clientY - rect.top;
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDraggingPopup) return;
            
            const viewportWidth = window.innerWidth - 320; // Account for sidebar
            const viewportHeight = window.innerHeight - 50; // Account for header
            const popupRect = annotationPopup.getBoundingClientRect();
            
            let newX = e.clientX - popupDragOffsetX;
            let newY = e.clientY - popupDragOffsetY - 50; // Offset for header
            
            // Keep popup within viewport bounds
            newX = Math.max(0, Math.min(newX, viewportWidth - popupRect.width));
            newY = Math.max(0, Math.min(newY, viewportHeight - popupRect.height));
            
            annotationPopup.style.left = newX + 'px';
            annotationPopup.style.top = newY + 'px';
            annotationPopup.style.right = 'auto';
            annotationPopup.style.bottom = 'auto';
        });
        
        document.addEventListener('mouseup', () => {
            isDraggingPopup = false;
        });

        // About modal
        btnAbout.addEventListener('click', () => {
            aboutOverlay.classList.add('visible');
        });

        aboutModalClose.addEventListener('click', () => {
            aboutOverlay.classList.remove('visible');
        });

        aboutOverlay.addEventListener('click', (e) => {
            if (e.target === aboutOverlay) {
                aboutOverlay.classList.remove('visible');
            }
        });

        // Download Manual as PDF
        btnDownloadManual.addEventListener('click', downloadManualAsPdf);

        // Legal modal
        btnLegal.addEventListener('click', () => {
            legalOverlay.classList.add('visible');
        });

        legalModalClose.addEventListener('click', () => {
            legalOverlay.classList.remove('visible');
        });

        legalOverlay.addEventListener('click', (e) => {
            if (e.target === legalOverlay) {
                legalOverlay.classList.remove('visible');
            }
        });

        cameraToggle.addEventListener('click', toggleCamera);

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                // Close confirmation dialog if open
                if (confirmOverlay.classList.contains('visible')) {
                    hideConfirm();
                    return;
                }
                
                // Close about modal if open
                if (aboutOverlay.classList.contains('visible')) {
                    aboutOverlay.classList.remove('visible');
                    return;
                }
                
                // Close legal modal if open
                if (legalOverlay.classList.contains('visible')) {
                    legalOverlay.classList.remove('visible');
                    return;
                }
                
                // Close scalebar confirm dialog if open
                if (scalebarConfirmOverlay.classList.contains('visible')) {
                    hideScalebarConfirm();
                    return;
                }
                
                annotationPopup.classList.remove('visible');
                groupPopup.classList.remove('visible');
                isAddingEntry = false;
                editingEntryId = null;
                editingModelInfo = false;
                
                // Clear measurements if in measure mode
                if (currentTool === 'measure') {
                    clearAllMeasurements();
                    showStatus('Measurements cleared');
                }
                
                setTool(null);
                clearTempDrawing();
            }
        });

        // ============ Start ============
        init();
        
        // Expose key variables for console debugging
        window.meshnotesDebug = {
            getScene: () => scene,
            getModel: () => currentModel,
            checkColors: () => {
                if (!currentModel) {
                    console.log('No model loaded');
                    return;
                }
                let report = { vertexColorsAttribute: [], vertexColorsWithData: [], materialColors: [], textures: [] };
                currentModel.traverse((child) => {
                    if (child.isMesh) {
                        const name = child.name || 'unnamed mesh';
                        if (child.geometry.attributes.color) {
                            report.vertexColorsAttribute.push(name);
                            // Check if vertex colors have actual data (not just white)
                            const colorAttr = child.geometry.attributes.color;
                            const count = colorAttr.count;
                            let hasRealColors = false;
                            const samplesToCheck = Math.min(50, count);
                            for (let i = 0; i < samplesToCheck; i++) {
                                const idx = Math.floor(i * count / samplesToCheck);
                                const r = colorAttr.getX(idx);
                                const g = colorAttr.getY(idx);
                                const b = colorAttr.getZ(idx);
                                if (r < 0.99 || g < 0.99 || b < 0.99) {
                                    hasRealColors = true;
                                    break;
                                }
                            }
                            if (hasRealColors) {
                                report.vertexColorsWithData.push(name);
                            }
                        }
                        const materials = Array.isArray(child.material) ? child.material : [child.material];
                        materials.forEach((mat, i) => {
                            if (mat.color && (mat.color.r !== 1 || mat.color.g !== 1 || mat.color.b !== 1)) {
                                report.materialColors.push(`${name}: rgb(${mat.color.r.toFixed(2)}, ${mat.color.g.toFixed(2)}, ${mat.color.b.toFixed(2)})`);
                            }
                            if (mat.map) {
                                report.textures.push(`${name}: has texture map`);
                            }
                        });
                    }
                });
                console.log('=== Model Color Report ===');
                console.log('Vertex color attribute exists:', report.vertexColorsAttribute.length > 0 ? report.vertexColorsAttribute : 'NONE');
                console.log('Vertex colors with actual data:', report.vertexColorsWithData.length > 0 ? report.vertexColorsWithData : 'NONE (all white)');
                console.log('Material Colors found:', report.materialColors.length > 0 ? report.materialColors : 'NONE');
                console.log('Textures found:', report.textures.length > 0 ? report.textures : 'NONE');
                console.log('hasVertexColors flag (enables Colors mode):', hasVertexColors);
                return report;
            }
        };
        
        // Load saved slider settings
        const savedPointSize = localStorage.getItem('meshnotes_pointSize');
        if (savedPointSize) {
            pointSizeSlider.value = savedPointSize;
            pointSizeMultiplier = parseInt(savedPointSize) / 100;
            pointSizeValue.textContent = `${savedPointSize}%`;
        }
        
        const savedTextSize = localStorage.getItem('meshnotes_textSize');
        if (savedTextSize) {
            textSizeSlider.value = savedTextSize;
            textSizeMultiplier = parseInt(savedTextSize) / 100;
            textSizeValue.textContent = `${savedTextSize}%`;
        }
    </script>
</body>
</html>
