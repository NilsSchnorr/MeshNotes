<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MeshNotes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: #041D31;
        }

        /* Header */
        #header {
            height: 50px;
            background: #0A3559;
            border-bottom: 1px solid #1A5A8A;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 500;
        }

        #header h1 {
            font-size: 18px;
            font-weight: 600;
            color: #eee;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #header h1 span.icon {
            font-size: 22px;
        }

        #btn-about {
            padding: 8px 16px;
            background: #1A5A8A;
            border: none;
            border-radius: 6px;
            color: #eee;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        #btn-about:hover {
            background: #2A6A9A;
        }

        #container {
            display: flex;
            height: calc(100vh - 50px);
            margin-top: 50px;
        }

        #viewport {
            flex: 1;
            position: relative;
        }

        #canvas {
            display: block;
        }

        /* Toolbar */
        #toolbar {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            max-width: calc(100% - 340px);
            z-index: 100;
        }

        .tool-btn {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            background: #0A3559;
            color: #eee;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
            white-space: nowrap;
        }

        .tool-btn:hover {
            background: #1A5A8A;
        }

        .tool-btn.active {
            background: #AA8101;
        }

        .tool-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .tool-separator {
            width: 1px;
            background: #1A5A8A;
            margin: 0 4px;
        }

        #file-input, #import-input {
            display: none;
        }

        /* Sidebar */
        #sidebar {
            width: 320px;
            background: #0A3559;
            color: #eee;
            display: flex;
            flex-direction: column;
            border-left: 1px solid #1A5A8A;
        }

        .sidebar-section {
            padding: 16px;
            border-bottom: 1px solid #1A5A8A;
        }

        .sidebar-section h2 {
            font-size: 14px;
            margin-bottom: 12px;
            color: #EDC040;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .sidebar-section h2 button {
            padding: 4px 8px;
            font-size: 11px;
        }

        /* Search Box */
        #search-box {
            padding: 0 16px 12px 16px;
        }

        #search-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #1A5A8A;
            border-radius: 4px;
            background: #041D31;
            color: #eee;
            font-size: 13px;
            box-sizing: border-box;
        }

        #search-input:focus {
            outline: none;
            border-color: #EDC040;
        }

        #search-input::placeholder {
            color: #666;
        }

        .annotation-item.search-hidden {
            display: none !important;
        }

        .group-item.search-hidden {
            display: none !important;
        }

        #annotations-section {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        /* Group List */
        .group-item {
            background: #041D31;
            border-radius: 6px;
            margin-bottom: 8px;
            overflow: hidden;
        }

        .group-header {
            padding: 10px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .group-header:hover {
            background: #1A5A8A;
        }

        .group-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.3);
            cursor: pointer;
        }

        .group-name {
            flex: 1;
            font-weight: 500;
            font-size: 13px;
        }

        .group-visibility {
            padding: 2px 6px;
            background: none;
            border: none;
            color: #eee;
            cursor: pointer;
            font-size: 14px;
            opacity: 0.7;
        }

        .group-visibility:hover {
            opacity: 1;
        }

        .group-visibility.hidden {
            opacity: 0.3;
        }

        .group-actions {
            display: flex;
            gap: 4px;
        }

        .group-actions button {
            padding: 2px 6px;
            background: none;
            border: none;
            color: #aaa;
            cursor: pointer;
            font-size: 12px;
        }

        .group-actions button:hover {
            color: #EDC040;
        }

        /* Model Information Section */
        #model-info-section {
            padding: 0 8px 12px 8px;
            border-bottom: 1px solid #1A5A8A;
            margin-bottom: 12px;
        }

        .model-info-item {
            padding: 12px;
            background: #0A3559;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
            border: 1px solid #1A5A8A;
        }

        .model-info-item:hover {
            background: #1A5A8A;
            border-color: #EDC040;
        }

        .model-info-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }

        .model-info-icon {
            font-size: 16px;
        }

        .model-info-title {
            font-weight: 600;
            font-size: 13px;
            color: #EDC040;
        }

        .model-info-subtitle {
            font-size: 11px;
            color: #888;
            padding-left: 24px;
        }

        /* Annotation List */
        .annotation-list {
            padding: 0 8px 8px 8px;
        }

        .annotation-item {
            padding: 10px;
            background: #0A3559;
            border-radius: 4px;
            margin-bottom: 6px;
            cursor: pointer;
            transition: background 0.2s;
            border-left: 3px solid transparent;
        }

        .annotation-item:hover {
            background: #1A5A8A;
        }

        .annotation-item.selected {
            background: #1A5A8A;
            border-left-color: #EDC040;
        }

        .annotation-item .header {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 4px;
        }

        .annotation-item .type-icon {
            font-size: 12px;
        }

        .annotation-item .name {
            font-weight: 500;
            font-size: 13px;
            flex: 1;
        }

        .annotation-item .description {
            font-size: 11px;
            color: #888;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Popups */
        .popup {
            display: none;
            position: absolute;
            background: #0A3559;
            border: 1px solid #1A5A8A;
            border-radius: 8px;
            padding: 16px;
            z-index: 200;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .popup.visible {
            display: block;
        }

        .popup h3 {
            color: #EDC040;
            margin-bottom: 12px;
            font-size: 14px;
        }

        .popup label {
            display: block;
            color: #aaa;
            font-size: 12px;
            margin-bottom: 4px;
        }

        .popup input,
        .popup textarea,
        .popup select {
            width: 100%;
            padding: 8px;
            border: 1px solid #1A5A8A;
            border-radius: 4px;
            background: #041D31;
            color: #eee;
            font-size: 13px;
            margin-bottom: 10px;
        }

        .popup textarea {
            height: 70px;
            resize: vertical;
            font-family: inherit;
        }

        .popup .btn-row {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-top: 4px;
        }

        .popup button {
            padding: 8px 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        .popup .btn-save {
            background: #AA8101;
            color: white;
        }

        .popup .btn-cancel {
            background: #1A5A8A;
            color: #eee;
        }

        .popup .btn-delete {
            background: #dc3545;
            color: white;
            margin-right: auto;
        }

        #annotation-popup {
            width: 400px;
            max-height: 80vh;
            overflow-y: auto;
        }

        /* Entries in annotation popup */
        #entries-container {
            margin: 12px 0;
            border-top: 1px solid #1A5A8A;
            padding-top: 12px;
        }

        #entries-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 12px;
        }

        .entry-card {
            background: #041D31;
            border: 1px solid #1A5A8A;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .entry-card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .entry-card-meta {
            color: #888;
        }

        .entry-card-meta .author {
            color: #EDC040;
            font-weight: 500;
        }

        .entry-card-actions {
            display: flex;
            gap: 4px;
        }

        .entry-card-actions button {
            padding: 4px 8px;
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 11px;
            border-radius: 3px;
        }

        .entry-card-actions button:hover {
            background: #1A5A8A;
            color: #EDC040;
        }

        .entry-card-description {
            color: #ccc;
            font-size: 13px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .entry-card-links {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #1A5A8A;
        }

        .entry-card-links a {
            display: inline-block;
            color: #EDC040;
            text-decoration: none;
            font-size: 12px;
            margin-right: 12px;
            margin-bottom: 4px;
        }

        .entry-card-links a:hover {
            text-decoration: underline;
        }

        /* Entry edit mode */
        .entry-card.editing {
            border-color: #EDC040;
        }

        .entry-edit-form {
            display: none;
        }

        .entry-card.editing .entry-card-description,
        .entry-card.editing .entry-card-links,
        .entry-card.editing .entry-card-actions {
            display: none;
        }

        .entry-card.editing .entry-edit-form {
            display: block;
        }

        .entry-edit-form textarea {
            width: 100%;
            height: 60px;
            margin-bottom: 8px;
        }

        .entry-edit-form input {
            width: 100%;
            margin-bottom: 8px;
        }

        .entry-edit-buttons {
            display: flex;
            gap: 6px;
            justify-content: flex-end;
        }

        .entry-edit-buttons button {
            padding: 6px 12px;
            font-size: 12px;
        }

        .btn-add-entry {
            width: 100%;
            padding: 10px;
            background: #1A5A8A;
            border: 1px dashed #EDC040;
            border-radius: 6px;
            color: #EDC040;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }

        .btn-add-entry:hover {
            background: #2A6A9A;
        }

        #new-entry-form {
            border-top: 1px solid #1A5A8A;
            padding-top: 12px;
            margin-top: 12px;
        }

        /* Confirmation dialog */
        .confirm-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 300;
            align-items: center;
            justify-content: center;
        }

        .confirm-overlay.visible {
            display: flex;
        }

        .confirm-dialog {
            background: #0A3559;
            border: 1px solid #1A5A8A;
            border-radius: 8px;
            padding: 20px;
            max-width: 350px;
            text-align: center;
        }

        .confirm-dialog p {
            color: #ccc;
            margin-bottom: 16px;
            line-height: 1.5;
        }

        .confirm-dialog .btn-row {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .confirm-dialog button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        #group-popup {
            width: 260px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Links section in popup */
        .links-section {
            margin-bottom: 10px;
        }

        .links-list {
            max-height: 80px;
            overflow-y: auto;
            margin-bottom: 6px;
        }

        .link-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 6px;
            background: #041D31;
            border-radius: 3px;
            margin-bottom: 4px;
            font-size: 12px;
        }

        .link-item a {
            color: #EDC040;
            text-decoration: none;
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .link-item button {
            padding: 2px 6px;
            background: none;
            border: none;
            color: #AA8101;
            cursor: pointer;
            font-size: 10px;
        }

        .add-link-row {
            display: flex;
            gap: 6px;
        }

        .add-link-row input {
            flex: 1;
            margin-bottom: 0;
            font-size: 12px;
            padding: 6px;
        }

        .add-link-row button {
            padding: 6px 10px;
            font-size: 12px;
        }

        /* Measurement display */
        #measurement-display {
            display: none;
            position: absolute;
            top: 70px;
            left: 10px;
            background: rgba(10, 53, 89, 0.95);
            color: #EDC040;
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 14px;
            z-index: 100;
            min-width: 200px;
            max-height: 300px;
            overflow-y: auto;
        }

        #measurement-display.visible {
            display: block;
        }

        #measurements-list {
            margin-bottom: 8px;
        }

        .measurement-item {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid rgba(237, 192, 64, 0.2);
        }

        .measurement-item:last-child {
            border-bottom: none;
        }

        .measurement-item .label {
            color: #aaa;
        }

        .measurement-item .value {
            font-weight: 600;
            color: #EDC040;
        }

        #measurement-display .hint {
            font-size: 11px;
            color: #888;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        /* Brush Display for Surface Tool */
        #brush-display {
            display: none;
            position: absolute;
            top: 70px;
            left: 10px;
            background: rgba(10, 53, 89, 0.95);
            color: #EDC040;
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 14px;
            z-index: 100;
            min-width: 200px;
        }

        #brush-display.visible {
            display: block;
        }

        .brush-controls label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            color: #aaa;
            font-size: 12px;
        }

        .brush-controls label span:last-child {
            color: #EDC040;
            font-weight: 600;
        }

        #brush-slider {
            width: 100%;
            cursor: pointer;
        }

        #brush-display .hint {
            font-size: 11px;
            color: #888;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        /* Instructions */
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(10, 53, 89, 0.9);
            color: #aaa;
            padding: 10px 14px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 100;
        }

        #instructions strong {
            color: #EDC040;
        }

        /* Model Stats */
        #model-stats {
            display: none;
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(10, 53, 89, 0.8);
            color: #888;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 11px;
            z-index: 100;
        }

        #model-stats.visible {
            display: block;
        }

        #model-stats .warning {
            color: #e8a33c;
        }

        /* Status message */
        #status {
            position: absolute;
            bottom: 50px;
            left: 10px;
            color: #EDC040;
            font-size: 13px;
            z-index: 100;
            background: rgba(10, 53, 89, 0.9);
            padding: 8px 12px;
            border-radius: 4px;
            display: none;
        }

        #status.visible {
            display: block;
        }

        /* Loading overlay */
        #loading {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #eee;
            font-size: 18px;
            z-index: 300;
            background: rgba(4, 29, 49, 0.9);
            padding: 20px 30px;
            border-radius: 8px;
        }

        #loading.visible {
            display: block;
        }

        /* Color picker */
        input[type="color"] {
            width: 40px;
            height: 30px;
            padding: 0;
            border: none;
            cursor: pointer;
        }

        /* Empty state */
        .empty-state {
            color: #666;
            font-size: 13px;
            text-align: center;
            padding: 20px;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #041D31;
        }

        ::-webkit-scrollbar-thumb {
            background: #1A5A8A;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #2A6A9A;
        }

        /* Sliders panel */
        #sliders-panel {
            position: absolute;
            bottom: 50px;
            right: 340px;
            background: rgba(10, 53, 89, 0.95);
            padding: 12px 16px;
            border-radius: 6px;
            z-index: 100;
            min-width: 180px;
        }

        /* About Modal */
        #about-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        #about-overlay.visible {
            display: flex;
        }

        #about-modal {
            background: #0A3559;
            border-radius: 12px;
            width: 90%;
            max-width: 700px;
            max-height: 85vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        #about-modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid #1A5A8A;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        #about-modal-header h2 {
            font-size: 20px;
            color: #eee;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #about-modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        #about-modal-close:hover {
            background: #1A5A8A;
            color: #eee;
        }

        #about-modal-content {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
        }

        #about-modal-content section {
            margin-bottom: 24px;
        }

        #about-modal-content section:last-child {
            margin-bottom: 0;
        }

        #about-modal-content h3 {
            font-size: 16px;
            color: #EDC040;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #1A5A8A;
        }

        #about-modal-content p {
            color: #ccc;
            line-height: 1.6;
            margin-bottom: 12px;
        }

        #about-modal-content a {
            color: #EDC040;
            text-decoration: none;
        }

        #about-modal-content a:hover {
            text-decoration: underline;
        }

        /* Manual section */
        #about-modal-content h4 {
            font-size: 14px;
            color: #EDC040;
            margin: 20px 0 8px 0;
            font-weight: 600;
        }

        #about-modal-content h4:first-of-type {
            margin-top: 0;
        }

        /* Collapsible manual items */
        .manual-item {
            background: #041D31;
            border-radius: 6px;
            margin-bottom: 8px;
            overflow: hidden;
        }

        .manual-item-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 14px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            color: #EDC040;
            transition: background 0.2s;
        }

        .manual-item-header:hover {
            background: #0A3559;
        }

        .manual-item-header .toggle-icon {
            font-size: 10px;
            color: #888;
            transition: transform 0.2s;
        }

        .manual-item-header.expanded .toggle-icon {
            transform: rotate(90deg);
        }

        .manual-item-content {
            display: none;
            padding: 0 14px 14px 14px;
            color: #ccc;
            font-size: 13px;
            line-height: 1.6;
        }

        .manual-item-content.expanded {
            display: block;
        }

        .manual-item-content p {
            margin: 0;
        }

        .beta-tag {
            background: #e8a33c;
            color: #000;
            font-size: 9px;
            padding: 2px 5px;
            border-radius: 3px;
            margin-left: 8px;
            font-weight: 700;
            text-transform: uppercase;
        }

        .limitation-note {
            background: rgba(232, 163, 60, 0.15);
            border-left: 3px solid #e8a33c;
            padding: 10px 12px;
            margin-top: 10px;
            border-radius: 0 4px 4px 0;
            font-size: 12px;
            color: #ccc;
        }

        .limitation-note strong {
            color: #e8a33c;
        }

        #about-modal-content code {
            background: #1A5A8A;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 13px;
            color: #EDC040;
        }

        .contact-info {
            background: #041D31;
            padding: 16px;
            border-radius: 6px;
        }

        .contact-info p {
            margin-bottom: 8px;
        }

        .contact-info p:last-child {
            margin-bottom: 0;
        }

        .slider-row {
            margin-bottom: 10px;
        }

        .slider-row:last-child {
            margin-bottom: 0;
        }

        .slider-row label {
            display: flex;
            justify-content: space-between;
            color: #aaa;
            font-size: 12px;
            margin-bottom: 4px;
        }

        .slider-row input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: #041D31;
            border-radius: 3px;
            outline: none;
        }

        .slider-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #EDC040;
            border-radius: 50%;
            cursor: pointer;
        }

        .slider-row input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #EDC040;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header id="header">
        <h1>MeshNotes</h1>
        <button id="btn-about">About / Help</button>
    </header>

    <!-- About Modal -->
    <div id="about-overlay">
        <div id="about-modal">
            <div id="about-modal-header">
                <h2>MeshNotes</h2>
                <button id="about-modal-close">‚úï</button>
            </div>
            <div id="about-modal-content">
                <section>
                    <h3>About</h3>
                    <p>
                        <strong>MeshNotes</strong> is a free, browser-based tool for annotating 3D models with points, lines, and polygons, 
                        designed for cultural heritage documentation. It allows teams to collaboratively mark and describe features 
                        on photogrammetry models of archaeological sites, architecture, and artifacts.
                    </p>
                    <p>
                        Key features include multi-entry annotations (multiple users can add observations to the same feature with individual timestamps), 
                        measurement tools, customizable groups with color coding, draggable points for editing, and JSON export/import for team collaboration.
                    </p>
                    <p>
                        The tool runs entirely in your browser ‚Äî no installation or server required. Simply open the HTML file and start annotating. 
                        Your data stays on your computer unless you share the exported JSON file.
                    </p>
                </section>

                <section>
                    <h3>Contact</h3>
                    <div class="contact-info">
                        <p><strong>Developer:</strong> Nils Schnorr</p>
                        <p><strong>Email:</strong> <a href="mailto:nils.schnorr@uni-saarland.de">nils.schnorr@uni-saarland.de</a></p>
                        <p><strong>Institution:</strong> Department of Classical Archaeology, Saarland University, Saarbr√ºcken, Germany</p>
                    </div>
                </section>

                <section>
                    <h3>Manual</h3>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Loading a Model</span>
                            <span class="toggle-icon">‚ñ∂</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Click <strong>Load GLB</strong> to open a 3D model file. The tool supports <code>.glb</code> and <code>.gltf</code> formats. Convert your OBJ or PLY models to GLB using Blender or MeshLab for best compatibility. After loading, the face count is displayed in the bottom-right corner.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Texture &amp; Display Controls</span>
                            <span class="toggle-icon">‚ñ∂</span>
                        </div>
                        <div class="manual-item-content">
                            <p><strong>Texture:</strong> Toggle the model's texture on/off to see the underlying geometry. <strong>Brightness slider:</strong> Adjust scene lighting from 0% to 300%. <strong>Opacity slider:</strong> Make the model transparent (10-100%) to see annotations that pass through it.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Point Annotations</span>
                            <span class="toggle-icon">‚ñ∂</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Click <strong>Point</strong>, then click on the model surface to place a point marker. A popup will appear where you can enter a name, description, author, and external links. Points are useful for marking specific features or locations.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Line Annotations</span>
                            <span class="toggle-icon">‚ñ∂</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Click <strong>Line</strong> to start drawing a polyline. Single-click to add points along the line, double-click to finish and open the annotation popup. Lines are useful for marking edges, boundaries, cracks, or linear features.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Polygon Annotations</span>
                            <span class="toggle-icon">‚ñ∂</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Click <strong>Polygon</strong> to start drawing a closed shape. Single-click to add vertices, double-click to close the polygon and open the annotation popup. Polygons are useful for marking areas, surfaces, or regions of interest.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Surface Annotations <span class="beta-tag">Beta</span></span>
                            <span class="toggle-icon">‚ñ∂</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Click <strong>Surface</strong> to paint directly on the 3D model's mesh faces. Adjust the brush size using the slider (0.5-20% of model size), then click and drag to highlight faces. <strong>Right-click and drag</strong> to rotate the view while painting ‚Äî this lets you paint a continuous surface annotation from multiple angles (e.g., wrapping around a statue's arm). Hold <strong>Shift</strong> while painting to erase. Double-click to finish and open the annotation popup.</p>
                            <p style="margin-top: 10px;">Surface annotations are ideal for marking 3D regions like weathered areas, specific architectural features, or body parts on sculptures that can't be easily captured with flat polygons.</p>
                            <div class="limitation-note">
                                <strong>Performance Note:</strong> The Surface tool works best on smaller models (statues, ceramics, artifacts). Performance depends on face count:
                                <ul style="margin: 8px 0 0 20px; padding: 0;">
                                    <li><strong>&lt; 500k faces:</strong> Smooth painting</li>
                                    <li><strong>500k - 1M faces:</strong> May experience slight lag</li>
                                    <li><strong>&gt; 1M faces:</strong> Painting may be slow (consider decimating the model)</li>
                                </ul>
                                The face count is shown in the bottom-right corner after loading a model.
                            </div>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Measurement Tool</span>
                            <span class="toggle-icon">‚ñ∂</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Click <strong>Measure</strong> to activate the measurement tool. Click two points on the model to measure the distance between them. Multiple measurements can be taken and all stay visible with their distance labels. Take a screenshot to document your measurements, then press <code>Esc</code> to clear all. Distances are displayed in "units" ‚Äî the actual unit (meters, millimeters, etc.) depends on how your 3D model was created or exported.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Groups</span>
                            <span class="toggle-icon">‚ñ∂</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Groups help organize annotations by category, phase, or team member. Click <strong>+ Group</strong> in the sidebar to create a new group with a custom name and color. All annotations within a group share that color. Use the eye icon to show/hide all annotations in a group, and the edit icon to modify the group name/color or delete the entire group. A default group is created automatically when you first annotate.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Model Information</span>
                            <span class="toggle-icon">‚ñ∂</span>
                        </div>
                        <div class="manual-item-content">
                            <p>At the top of the sidebar is a <strong>Model Information</strong> section for general notes about the entire model. Double-click it to add an introduction, context, or overview that applies to the whole model rather than a specific location. Like annotations, it supports multiple entries from different team members with timestamps ‚Äî useful for documenting the model's origin, processing history, or general observations.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Multi-Entry Annotations</span>
                            <span class="toggle-icon">‚ñ∂</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Each annotation can have multiple entries from different users. When editing an annotation, you'll see all existing entries with their author and timestamp. Click <strong>+ Add Entry</strong> to add your own observation without overwriting previous ones. Each entry has its own description, author name, and links. This is ideal for collaborative documentation where multiple team members contribute observations to the same feature.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Editing Annotations</span>
                            <span class="toggle-icon">‚ñ∂</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Single-click an annotation in the sidebar to focus the camera on it. Double-click to open it for editing. In the edit popup you can: change the annotation name and group, view all entries, edit existing entries (with confirmation for older entries), delete individual entries, or delete the entire annotation. Your author name is remembered for convenience.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Moving Annotation Points</span>
                            <span class="toggle-icon">‚ñ∂</span>
                        </div>
                        <div class="manual-item-content">
                            <p>When no tool is active, you can click and drag any annotation point to reposition it. The cursor changes to a hand when hovering over draggable points. While dragging, the point follows the model surface and lines/polygons update in real-time. This allows you to adjust annotations without recreating them. Note: Surface annotations cannot be edited after creation.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Export &amp; Import</span>
                            <span class="toggle-icon">‚ñ∂</span>
                        </div>
                        <div class="manual-item-content">
                            <p><strong>JSON:</strong> Click to download all annotations and groups as a JSON file. The file includes all entries, timestamps, and metadata. Use JSON for backup and team collaboration. <strong>Import:</strong> Click to load annotations from a JSON file. Imported annotations merge with existing ones ‚Äî groups with the same name are combined, and all annotations are preserved.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>PDF Report</span>
                            <span class="toggle-icon">‚ñ∂</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Click <strong>PDF</strong> to generate a professional PDF report of your annotations. The report includes: a title page with model overview and model information, a table of contents, and one page per annotation with an auto-captured screenshot and all entry details. Only visible annotations are included ‚Äî hide groups you don't want in the report. The PDF is formatted for A4 paper and suitable for academic documentation and publication.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Screenshots</span>
                            <span class="toggle-icon">‚ñ∂</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Click <strong>Screenshot</strong> to save the current view as a PNG image. The screenshot includes all visible annotations, name labels, and measurement lines exactly as shown on screen ‚Äî useful for documentation, reports, and publications.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Navigation Controls</span>
                            <span class="toggle-icon">‚ñ∂</span>
                        </div>
                        <div class="manual-item-content">
                            <p><strong>Left-click + drag:</strong> Rotate the view around the model. <strong>Right-click + drag:</strong> Pan the view. <strong>Scroll wheel:</strong> Zoom in/out. <strong>Escape:</strong> Cancel current drawing action, deselect tool, or clear all measurements.</p>
                        </div>
                    </div>

                    <div class="manual-item">
                        <div class="manual-item-header" onclick="toggleManualItem(this)">
                            <span>Tips</span>
                            <span class="toggle-icon">‚ñ∂</span>
                        </div>
                        <div class="manual-item-content">
                            <p>Use the opacity slider to see annotations on the back side of the model. Group annotations by excavation phase, feature type, or team member for better organization. Export frequently to back up your work. The tool runs entirely in your browser ‚Äî your data stays on your computer unless you share the exported JSON file.</p>
                        </div>
                    </div>

                </section>
            </div>
        </div>
    </div>

    <div id="container">
        <div id="viewport">
            <canvas id="canvas"></canvas>
            
            <div id="toolbar">
                <input type="file" id="file-input" accept=".glb,.gltf">
                <input type="file" id="import-input" accept=".json">
                
                <button class="tool-btn" id="btn-load" title="Load 3D Model">üìÇ Load GLB</button>
                <button class="tool-btn" id="btn-texture" disabled title="Toggle Texture">üñºÔ∏è Texture</button>
                
                <div class="tool-separator"></div>
                
                <button class="tool-btn" id="btn-point" disabled title="Add Point Annotation">üìç Point</button>
                <button class="tool-btn" id="btn-line" disabled title="Add Line Annotation">üìè Line</button>
                <button class="tool-btn" id="btn-polygon" disabled title="Add Polygon Annotation">‚¨° Polygon</button>
                <button class="tool-btn" id="btn-surface" disabled title="Add Surface Annotation (Beta)">üé® Surface</button>
                <button class="tool-btn" id="btn-measure" disabled title="Measure Distance">üìê Measure</button>
                
                <div class="tool-separator"></div>
                
                <button class="tool-btn" id="btn-screenshot" disabled title="Take Screenshot">üì∑ Screenshot</button>
                <button class="tool-btn" id="btn-export" disabled title="Export Annotations as JSON">üíæ JSON</button>
                <button class="tool-btn" id="btn-export-pdf" disabled title="Export as PDF Report">üìÑ PDF</button>
                <button class="tool-btn" id="btn-import" title="Import Annotations">üì• Import</button>
            </div>

            <div id="measurement-display">
                <div id="measurements-list"></div>
                <div class="hint">Click two points to measure. Press Esc to clear all.</div>
            </div>

            <div id="brush-display">
                <div class="brush-controls">
                    <label>
                        <span>Brush Size</span>
                        <span id="brush-value">5%</span>
                    </label>
                    <input type="range" id="brush-slider" min="0.5" max="20" value="5" step="0.5">
                </div>
                <div class="hint">Click/drag to paint. Hold Shift to erase. Double-click to finish.</div>
            </div>

            <div id="instructions">
                <strong>Controls:</strong> Left-drag rotate ¬∑ Right-drag pan ¬∑ Scroll zoom
            </div>

            <div id="model-stats">
                <span id="face-count"></span>
            </div>

            <div id="sliders-panel">
                <div class="slider-row">
                    <label>
                        <span>Brightness</span>
                        <span id="brightness-value">100%</span>
                    </label>
                    <input type="range" id="brightness-slider" min="0" max="300" value="100">
                </div>
                <div class="slider-row">
                    <label>
                        <span>Model Opacity</span>
                        <span id="opacity-value">100%</span>
                    </label>
                    <input type="range" id="opacity-slider" min="10" max="100" value="100">
                </div>
            </div>

            <div id="status"></div>
            <div id="loading">Loading model...</div>

            <!-- Annotation Popup -->
            <div class="popup" id="annotation-popup">
                <h3 id="popup-title">New Annotation</h3>
                
                <div id="popup-main-fields">
                    <label for="ann-name">Name *</label>
                    <input type="text" id="ann-name" placeholder="e.g., Door remains">
                    
                    <label for="ann-group">Group</label>
                    <select id="ann-group"></select>
                </div>
                
                <!-- Entries container (shown when editing) -->
                <div id="entries-container" style="display: none;">
                    <div id="entries-list"></div>
                    <button class="btn-add-entry" id="btn-add-entry">+ Add Entry</button>
                </div>
                
                <!-- New entry form (shown when creating or adding entry) -->
                <div id="new-entry-form">
                    <label for="ann-description">Description</label>
                    <textarea id="ann-description" placeholder="Describe what you observe..."></textarea>
                    
                    <label for="ann-author">Author</label>
                    <input type="text" id="ann-author" placeholder="Your name">
                    
                    <div class="links-section">
                        <label>External Links</label>
                        <div class="links-list" id="ann-links"></div>
                        <div class="add-link-row">
                            <input type="text" id="ann-new-link" placeholder="https://...">
                            <button class="btn-save" id="btn-add-link">+</button>
                        </div>
                    </div>
                </div>
                
                <div class="btn-row">
                    <button class="btn-delete" id="btn-popup-delete" style="display: none;">Delete Annotation</button>
                    <button class="btn-cancel" id="btn-popup-cancel">Cancel</button>
                    <button class="btn-save" id="btn-popup-save">Save</button>
                </div>
            </div>

            <!-- Confirmation Dialog -->
            <div class="confirm-overlay" id="confirm-overlay">
                <div class="confirm-dialog">
                    <p id="confirm-message">Are you sure?</p>
                    <div class="btn-row">
                        <button class="btn-cancel" id="confirm-cancel">Cancel</button>
                        <button class="btn-save" id="confirm-ok">Confirm</button>
                    </div>
                </div>
            </div>

            <!-- Group Popup -->
            <div class="popup" id="group-popup">
                <h3 id="group-popup-title">New Group</h3>
                <label for="group-name">Name</label>
                <input type="text" id="group-name" placeholder="e.g., Phase 1 features">
                
                <label for="group-color">Color</label>
                <input type="color" id="group-color" value="#EDC040">
                
                <div class="btn-row">
                    <button class="btn-delete" id="btn-group-delete" style="display: none;">Delete</button>
                    <button class="btn-cancel" id="btn-group-cancel">Cancel</button>
                    <button class="btn-save" id="btn-group-save">Save</button>
                </div>
            </div>
        </div>

        <div id="sidebar">
            <div class="sidebar-section" style="flex: 1; overflow-y: auto;">
                <h2>
                    Annotations
                    <button class="tool-btn" id="btn-add-group">+ Group</button>
                </h2>
                
                <!-- Search Box -->
                <div id="search-box">
                    <input type="text" id="search-input" placeholder="Search annotations...">
                </div>
                
                <!-- Model Information -->
                <div id="model-info-section">
                    <div class="model-info-item" id="model-info-item">
                        <div class="model-info-header">
                            <span class="model-info-icon">üìã</span>
                            <span class="model-info-title">Model Information</span>
                        </div>
                        <div class="model-info-subtitle" id="model-info-subtitle">No entries yet</div>
                    </div>
                </div>
                
                <div id="groups-container">
                    <div class="empty-state" id="no-groups">No annotations yet. Load a model and use the tools to annotate.</div>
                </div>
            </div>
        </div>
    </div>

    <!-- jsPDF library for PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { Line2 } from 'three/addons/lines/Line2.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import { LineGeometry } from 'three/addons/lines/LineGeometry.js';

        // ============ State ============
        let scene, camera, renderer, controls;
        let ambientLight, dirLight1, dirLight2;
        let currentModel = null;
        let modelFileName = '';
        let originalMaterials = new Map();
        let textureVisible = true;
        let modelOpacity = 1.0;
        
        // Tools
        let currentTool = null; // 'point', 'line', 'polygon', 'measure'
        let tempPoints = [];
        let tempLine = null;
        let measurePoints = [];
        let measureMarkers = [];
        let measureLine = null;
        let measurements = []; // Array of {id, distance, markers, line}

        // Data
        let groups = [];
        let annotations = [];
        let selectedAnnotation = null;
        let editingAnnotation = null;
        
        // Model Information (general info about the whole model)
        let modelInfo = {
            entries: []
        };
        let editingModelInfo = false;

        // Point dragging
        let isDraggingPoint = false;
        let draggedAnnotation = null;
        let draggedPointIndex = -1;
        let draggedMarker = null;
        let wasDragging = false; // Prevent click event after drag

        // Surface painting
        let isPaintingSurface = false;
        let surfaceBrushSize = 5; // Percentage of model size
        let paintedFaces = new Set(); // Set of face indices
        let surfaceHighlightMesh = null; // Mesh showing painted areas
        let isErasingMode = false;
        let modelMeshes = []; // Cache of meshes in the model
        let modelBoundingSize = 1; // For brush size calculation

        // Three.js objects for annotations
        let annotationObjects = new THREE.Group();

        // ============ DOM Elements ============
        const canvas = document.getElementById('canvas');
        const fileInput = document.getElementById('file-input');
        const importInput = document.getElementById('import-input');
        
        const btnLoad = document.getElementById('btn-load');
        const btnTexture = document.getElementById('btn-texture');
        const btnPoint = document.getElementById('btn-point');
        const btnLine = document.getElementById('btn-line');
        const btnPolygon = document.getElementById('btn-polygon');
        const btnSurface = document.getElementById('btn-surface');
        const btnMeasure = document.getElementById('btn-measure');
        const btnScreenshot = document.getElementById('btn-screenshot');
        const btnExport = document.getElementById('btn-export');
        const btnExportPdf = document.getElementById('btn-export-pdf');
        const btnImport = document.getElementById('btn-import');
        const btnAddGroup = document.getElementById('btn-add-group');
        
        const brushDisplay = document.getElementById('brush-display');
        const brushSlider = document.getElementById('brush-slider');
        const brushValue = document.getElementById('brush-value');

        const annotationPopup = document.getElementById('annotation-popup');
        const popupTitle = document.getElementById('popup-title');
        const annName = document.getElementById('ann-name');
        const annGroup = document.getElementById('ann-group');
        const annDescription = document.getElementById('ann-description');
        const annAuthor = document.getElementById('ann-author');
        const annLinks = document.getElementById('ann-links');
        const annNewLink = document.getElementById('ann-new-link');
        const btnAddLink = document.getElementById('btn-add-link');
        const btnPopupSave = document.getElementById('btn-popup-save');
        const btnPopupCancel = document.getElementById('btn-popup-cancel');
        const btnPopupDelete = document.getElementById('btn-popup-delete');
        
        const entriesContainer = document.getElementById('entries-container');
        const entriesList = document.getElementById('entries-list');
        const btnAddEntry = document.getElementById('btn-add-entry');
        const newEntryForm = document.getElementById('new-entry-form');
        
        const confirmOverlay = document.getElementById('confirm-overlay');
        const confirmMessage = document.getElementById('confirm-message');
        const confirmOk = document.getElementById('confirm-ok');
        const confirmCancel = document.getElementById('confirm-cancel');
        
        const modelInfoItem = document.getElementById('model-info-item');
        const modelInfoSubtitle = document.getElementById('model-info-subtitle');
        
        const modelStats = document.getElementById('model-stats');
        const faceCountDisplay = document.getElementById('face-count');

        const groupPopup = document.getElementById('group-popup');
        const groupPopupTitle = document.getElementById('group-popup-title');
        const groupName = document.getElementById('group-name');
        const groupColor = document.getElementById('group-color');
        const btnGroupSave = document.getElementById('btn-group-save');
        const btnGroupCancel = document.getElementById('btn-group-cancel');
        const btnGroupDelete = document.getElementById('btn-group-delete');

        const groupsContainer = document.getElementById('groups-container');
        const noGroups = document.getElementById('no-groups');
        const searchInput = document.getElementById('search-input');

        const measurementDisplay = document.getElementById('measurement-display');
        const measurementsList = document.getElementById('measurements-list');
        const loading = document.getElementById('loading');
        const status = document.getElementById('status');

        const brightnessSlider = document.getElementById('brightness-slider');
        const brightnessValue = document.getElementById('brightness-value');
        const opacitySlider = document.getElementById('opacity-slider');
        const opacityValue = document.getElementById('opacity-value');

        const aboutOverlay = document.getElementById('about-overlay');
        const btnAbout = document.getElementById('btn-about');
        const aboutModalClose = document.getElementById('about-modal-close');

        let pendingLinks = [];
        let editingGroup = null;
        let editingEntryId = null;
        let isAddingEntry = false;
        let confirmCallback = null;
        
        // Get last used author from localStorage
        const AUTHOR_STORAGE_KEY = 'meshnotes_author';
        function getLastAuthor() {
            return localStorage.getItem(AUTHOR_STORAGE_KEY) || '';
        }
        function saveLastAuthor(author) {
            if (author) localStorage.setItem(AUTHOR_STORAGE_KEY, author);
        }

        // ============ Initialize Three.js ============
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x041D31);

            camera = new THREE.PerspectiveCamera(
                60,
                (window.innerWidth - 320) / (window.innerHeight - 50),
                0.001,
                1000
            );
            camera.position.set(2, 2, 2);

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth - 320, window.innerHeight - 50);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputColorSpace = THREE.SRGBColorSpace;

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lights
            ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            dirLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight1.position.set(5, 10, 7);
            scene.add(dirLight1);

            dirLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            dirLight2.position.set(-5, -5, -5);
            scene.add(dirLight2);

            // Annotation objects group
            scene.add(annotationObjects);

            // Grid helper
            const gridHelper = new THREE.GridHelper(10, 10, 0x1A5A8A, 0x1A5A8A);
            gridHelper.name = 'gridHelper';
            scene.add(gridHelper);

            window.addEventListener('resize', onWindowResize);
            animate();

            // Create default group
            createDefaultGroup();
        }

        function onWindowResize() {
            const width = window.innerWidth - 320;
            const height = window.innerHeight - 50;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            
            // Update line material resolutions
            annotationObjects.traverse((child) => {
                if (child.material && child.material.isLineMaterial) {
                    child.material.resolution.set(width, height);
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // ============ Model Loading ============
        function loadModel(file) {
            loading.classList.add('visible');
            modelFileName = file.name;
            
            // Reset model info for new model
            modelInfo = { entries: [] };
            updateModelInfoDisplay();
            
            const loader = new GLTFLoader();
            const url = URL.createObjectURL(file);

            loader.load(
                url,
                (gltf) => {
                    if (currentModel) {
                        scene.remove(currentModel);
                    }

                    const grid = scene.getObjectByName('gridHelper');
                    if (grid) scene.remove(grid);

                    currentModel = gltf.scene;
                    scene.add(currentModel);

                    originalMaterials.clear();
                    modelMeshes = []; // Clear mesh cache
                    let totalFaces = 0;
                    currentModel.traverse((child) => {
                        if (child.isMesh) {
                            originalMaterials.set(child.uuid, child.material.clone());
                            modelMeshes.push(child); // Cache meshes for surface painting
                            
                            // Count faces
                            const geometry = child.geometry;
                            if (geometry.index) {
                                totalFaces += geometry.index.count / 3;
                            } else if (geometry.attributes.position) {
                                totalFaces += geometry.attributes.position.count / 3;
                            }
                        }
                    });
                    
                    // Display face count
                    updateFaceCountDisplay(totalFaces);

                    // Center and fit
                    const box = new THREE.Box3().setFromObject(currentModel);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    modelBoundingSize = maxDim; // Store for brush size calculation

                    currentModel.position.sub(center);
                    camera.position.set(maxDim * 1.5, maxDim * 1.5, maxDim * 1.5);
                    controls.target.set(0, 0, 0);
                    controls.update();

                    // Enable tools
                    btnTexture.disabled = false;
                    btnPoint.disabled = false;
                    btnLine.disabled = false;
                    btnPolygon.disabled = false;
                    btnSurface.disabled = false;
                    btnMeasure.disabled = false;
                    btnScreenshot.disabled = false;
                    btnExport.disabled = false;
                    btnExportPdf.disabled = false;
                    textureVisible = true;

                    // Apply current opacity setting
                    if (modelOpacity < 1.0) {
                        setModelOpacity(parseInt(opacitySlider.value));
                    }

                    loading.classList.remove('visible');
                    showStatus(`Loaded: ${file.name}`);
                    URL.revokeObjectURL(url);
                },
                undefined,
                (error) => {
                    console.error('Error loading model:', error);
                    loading.classList.remove('visible');
                    showStatus('Error loading model!');
                }
            );
        }

        // ============ Texture Toggle ============
        function toggleTexture() {
            if (!currentModel) return;
            textureVisible = !textureVisible;

            currentModel.traverse((child) => {
                if (child.isMesh) {
                    if (textureVisible) {
                        const original = originalMaterials.get(child.uuid);
                        if (original) {
                            child.material = original.clone();
                        }
                    } else {
                        child.material = new THREE.MeshStandardMaterial({
                            color: 0x888888,
                            roughness: 0.7,
                            metalness: 0.0
                        });
                    }
                    // Preserve opacity setting
                    child.material.transparent = true;
                    child.material.opacity = modelOpacity;
                    child.material.depthWrite = modelOpacity > 0.9;
                }
            });

            btnTexture.classList.toggle('active', !textureVisible);
            showStatus(textureVisible ? 'Texture ON' : 'Texture OFF');
        }

        // ============ Brightness Control ============
        function setBrightness(value) {
            const factor = value / 100;
            ambientLight.intensity = 0.6 * factor;
            dirLight1.intensity = 0.8 * factor;
            dirLight2.intensity = 0.4 * factor;
            brightnessValue.textContent = `${value}%`;
        }

        // ============ Opacity Control ============
        function setModelOpacity(value) {
            modelOpacity = value / 100;
            opacityValue.textContent = `${value}%`;
            
            if (!currentModel) return;

            currentModel.traverse((child) => {
                if (child.isMesh) {
                    child.material.transparent = true;
                    child.material.opacity = modelOpacity;
                    child.material.depthWrite = modelOpacity > 0.9;
                    child.material.needsUpdate = true;
                }
            });
        }

        // ============ Text Sprite Helper ============
        function createTextSprite(text, color = '#EDC040', backgroundColor = null, fontSize = 48) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            
            // Measure text to size canvas appropriately
            context.font = `bold ${fontSize}px Arial`;
            const metrics = context.measureText(text);
            const textWidth = metrics.width;
            const textHeight = fontSize;
            
            // Add small padding for text outline
            const padding = 8;
            canvas.width = textWidth + padding * 2;
            canvas.height = textHeight + padding * 2;
            
            // Draw text with outline for readability
            context.font = `bold ${fontSize}px Arial`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // Dark outline for contrast
            context.strokeStyle = 'rgba(0, 0, 0, 0.8)';
            context.lineWidth = 4;
            context.strokeText(text, canvas.width / 2, canvas.height / 2);
            
            // Main text color
            context.fillStyle = color;
            context.fillText(text, canvas.width / 2, canvas.height / 2);
            
            // Create sprite
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                depthTest: false,
                depthWrite: false
            });
            
            const sprite = new THREE.Sprite(spriteMaterial);
            
            // Scale sprite based on canvas aspect ratio
            const aspect = canvas.width / canvas.height;
            sprite.scale.set(aspect * 0.15, 0.15, 1);
            
            return sprite;
        }

        function createScaledTextSprite(text, color, position, scaleFactor = 1) {
            const sprite = createTextSprite(text, color);
            sprite.position.copy(position);
            
            // Scale using power of 0.7 - keeps large model labels the same, shrinks small model labels more
            if (currentModel) {
                const box = new THREE.Box3().setFromObject(currentModel);
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                sprite.scale.multiplyScalar(Math.pow(maxDim, 0.7) * 0.085 * scaleFactor);
            }
            
            return sprite;
        }

        // ============ Tool Selection ============
        function setTool(tool) {
            // Clear previous tool state
            clearTempDrawing();
            
            // If switching away from measure tool, clear all measurements
            if (currentTool === 'measure' && tool !== 'measure') {
                clearAllMeasurements();
                measurementDisplay.classList.remove('visible');
            }
            
            // If switching away from surface tool, clear temp surface
            if (currentTool === 'surface' && tool !== 'surface') {
                clearTempSurface();
                brushDisplay.classList.remove('visible');
            }

            if (currentTool === tool) {
                // If clicking same tool, deactivate it
                if (currentTool === 'measure') {
                    clearAllMeasurements();
                }
                if (currentTool === 'surface') {
                    clearTempSurface();
                }
                currentTool = null;
                canvas.style.cursor = 'default';
                measurementDisplay.classList.remove('visible');
                brushDisplay.classList.remove('visible');
            } else {
                currentTool = tool;
                canvas.style.cursor = 'crosshair';
            }

            // Update button states
            btnPoint.classList.toggle('active', currentTool === 'point');
            btnLine.classList.toggle('active', currentTool === 'line');
            btnPolygon.classList.toggle('active', currentTool === 'polygon');
            btnSurface.classList.toggle('active', currentTool === 'surface');
            btnMeasure.classList.toggle('active', currentTool === 'measure');

            if (currentTool === 'measure') {
                measurementDisplay.classList.add('visible');
                updateMeasurementsDisplay();
            }
            
            if (currentTool === 'surface') {
                brushDisplay.classList.add('visible');
                // Change right-click from pan to rotate for easier multi-angle painting
                controls.mouseButtons.RIGHT = THREE.MOUSE.ROTATE;
            } else {
                // Restore default right-click = pan behavior
                controls.mouseButtons.RIGHT = THREE.MOUSE.PAN;
            }

            updateInstructions();
        }

        function updateInstructions() {
            const instr = document.getElementById('instructions');
            let text = '<strong>Controls:</strong> Left-drag rotate ¬∑ Right-drag pan ¬∑ Scroll zoom';
            
            if (currentTool === 'point') {
                text = '<strong>Point:</strong> Click on model to place point';
            } else if (currentTool === 'line') {
                text = '<strong>Line:</strong> Click to add points ¬∑ Double-click to finish';
            } else if (currentTool === 'polygon') {
                text = '<strong>Polygon:</strong> Click to add points ¬∑ Double-click to close';
            } else if (currentTool === 'surface') {
                text = '<strong>Surface:</strong> Click/drag to paint ¬∑ Right-drag to rotate ¬∑ Hold Shift to erase ¬∑ Double-click to finish';
            } else if (currentTool === 'measure') {
                text = '<strong>Measure:</strong> Click two points to measure distance';
            }
            
            instr.innerHTML = text;
        }

        function clearTempDrawing() {
            tempPoints = [];
            if (tempLine) {
                annotationObjects.remove(tempLine);
                tempLine = null;
            }
            // Only clear in-progress measurement points, not saved measurements
            measurePoints = [];
            measureMarkers.forEach(m => annotationObjects.remove(m));
            measureMarkers = [];
            if (measureLine) {
                annotationObjects.remove(measureLine);
                measureLine = null;
            }
            // Clear temp surface painting
            clearTempSurface();
        }

        // ============ Surface Painting ============
        function clearTempSurface() {
            paintedFaces.clear();
            isPaintingSurface = false;
            if (surfaceHighlightMesh) {
                annotationObjects.remove(surfaceHighlightMesh);
                surfaceHighlightMesh.geometry.dispose();
                surfaceHighlightMesh.material.dispose();
                surfaceHighlightMesh = null;
            }
        }

        function getIntersectionWithFace(event) {
            if (!currentModel) return null;

            const rect = canvas.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(modelMeshes, false);

            if (intersects.length > 0) {
                return {
                    point: intersects[0].point.clone(),
                    faceIndex: intersects[0].faceIndex,
                    mesh: intersects[0].object
                };
            }
            return null;
        }

        function paintAtPoint(point, mesh, faceIndex) {
            if (!mesh || !mesh.geometry) return;

            const brushRadius = (surfaceBrushSize / 100) * modelBoundingSize;
            const geometry = mesh.geometry;
            const position = geometry.attributes.position;
            
            // Get faces within brush radius
            const faceCount = geometry.index 
                ? geometry.index.count / 3 
                : position.count / 3;

            for (let i = 0; i < faceCount; i++) {
                // Get face center
                let a, b, c;
                if (geometry.index) {
                    a = geometry.index.getX(i * 3);
                    b = geometry.index.getX(i * 3 + 1);
                    c = geometry.index.getX(i * 3 + 2);
                } else {
                    a = i * 3;
                    b = i * 3 + 1;
                    c = i * 3 + 2;
                }

                const vA = new THREE.Vector3().fromBufferAttribute(position, a);
                const vB = new THREE.Vector3().fromBufferAttribute(position, b);
                const vC = new THREE.Vector3().fromBufferAttribute(position, c);

                // Apply mesh world transform
                vA.applyMatrix4(mesh.matrixWorld);
                vB.applyMatrix4(mesh.matrixWorld);
                vC.applyMatrix4(mesh.matrixWorld);

                const faceCenter = new THREE.Vector3()
                    .addVectors(vA, vB)
                    .add(vC)
                    .divideScalar(3);

                const distance = faceCenter.distanceTo(point);
                
                if (distance <= brushRadius) {
                    // Create unique face ID combining mesh index and face index
                    // Use mesh index (not UUID) so it persists across model reloads
                    const meshIndex = modelMeshes.indexOf(mesh);
                    const faceId = `${meshIndex}_${i}`;
                    if (isErasingMode) {
                        paintedFaces.delete(faceId);
                    } else {
                        paintedFaces.add(faceId);
                    }
                }
            }

            updateSurfaceHighlight();
        }

        function updateSurfaceHighlight() {
            // Remove old highlight mesh
            if (surfaceHighlightMesh) {
                annotationObjects.remove(surfaceHighlightMesh);
                surfaceHighlightMesh.geometry.dispose();
                surfaceHighlightMesh.material.dispose();
                surfaceHighlightMesh = null;
            }

            if (paintedFaces.size === 0) return;

            // Group faces by mesh index
            const facesByMesh = new Map();
            paintedFaces.forEach(faceId => {
                const [meshIdx, faceIdx] = faceId.split('_');
                if (!facesByMesh.has(meshIdx)) {
                    facesByMesh.set(meshIdx, []);
                }
                facesByMesh.set(meshIdx, [...facesByMesh.get(meshIdx), parseInt(faceIdx)]);
            });

            // Build combined geometry
            const vertices = [];
            
            facesByMesh.forEach((faceIndices, meshIdx) => {
                const mesh = modelMeshes[parseInt(meshIdx)];
                if (!mesh) return;

                const geometry = mesh.geometry;
                const position = geometry.attributes.position;

                faceIndices.forEach(faceIdx => {
                    let a, b, c;
                    if (geometry.index) {
                        a = geometry.index.getX(faceIdx * 3);
                        b = geometry.index.getX(faceIdx * 3 + 1);
                        c = geometry.index.getX(faceIdx * 3 + 2);
                    } else {
                        a = faceIdx * 3;
                        b = faceIdx * 3 + 1;
                        c = faceIdx * 3 + 2;
                    }

                    const vA = new THREE.Vector3().fromBufferAttribute(position, a);
                    const vB = new THREE.Vector3().fromBufferAttribute(position, b);
                    const vC = new THREE.Vector3().fromBufferAttribute(position, c);

                    // Apply mesh world transform
                    vA.applyMatrix4(mesh.matrixWorld);
                    vB.applyMatrix4(mesh.matrixWorld);
                    vC.applyMatrix4(mesh.matrixWorld);

                    vertices.push(vA.x, vA.y, vA.z);
                    vertices.push(vB.x, vB.y, vB.z);
                    vertices.push(vC.x, vC.y, vC.z);
                });
            });

            if (vertices.length === 0) return;

            // Create highlight geometry
            const highlightGeometry = new THREE.BufferGeometry();
            highlightGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            highlightGeometry.computeVertexNormals();

            // Get current group color or use default gold
            const color = groups.length > 0 ? groups[0].color : '#EDC040';

            const highlightMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide,
                depthTest: true,
                depthWrite: false,
                polygonOffset: true,
                polygonOffsetFactor: -4,
                polygonOffsetUnits: -4
            });

            surfaceHighlightMesh = new THREE.Mesh(highlightGeometry, highlightMaterial);
            surfaceHighlightMesh.renderOrder = 999;
            annotationObjects.add(surfaceHighlightMesh);
        }

        function finishSurfacePainting(event) {
            if (paintedFaces.size === 0) {
                showStatus('No surface painted');
                clearTempSurface();
                return;
            }

            // Calculate center point from all painted faces
            const center = new THREE.Vector3();
            let count = 0;

            paintedFaces.forEach(faceId => {
                const [meshIdx, faceIdx] = faceId.split('_');
                const mesh = modelMeshes[parseInt(meshIdx)];
                if (!mesh) return;

                const geometry = mesh.geometry;
                const position = geometry.attributes.position;
                const idx = parseInt(faceIdx);

                let a, b, c;
                if (geometry.index) {
                    a = geometry.index.getX(idx * 3);
                    b = geometry.index.getX(idx * 3 + 1);
                    c = geometry.index.getX(idx * 3 + 2);
                } else {
                    a = idx * 3;
                    b = idx * 3 + 1;
                    c = idx * 3 + 2;
                }

                const vA = new THREE.Vector3().fromBufferAttribute(position, a);
                const vB = new THREE.Vector3().fromBufferAttribute(position, b);
                const vC = new THREE.Vector3().fromBufferAttribute(position, c);

                vA.applyMatrix4(mesh.matrixWorld);
                vB.applyMatrix4(mesh.matrixWorld);
                vC.applyMatrix4(mesh.matrixWorld);

                const faceCenter = new THREE.Vector3()
                    .addVectors(vA, vB)
                    .add(vC)
                    .divideScalar(3);

                center.add(faceCenter);
                count++;
            });

            center.divideScalar(count);

            // Store face IDs as the "points" data for surface annotations
            const faceData = Array.from(paintedFaces);

            // Open popup with center point
            openAnnotationPopup(event, 'surface', [center], faceData);
            
            // Clear temp highlight (will be re-rendered as annotation)
            if (surfaceHighlightMesh) {
                annotationObjects.remove(surfaceHighlightMesh);
                surfaceHighlightMesh.geometry.dispose();
                surfaceHighlightMesh.material.dispose();
                surfaceHighlightMesh = null;
            }
            paintedFaces.clear();
            isPaintingSurface = false;
        }

        // ============ Raycasting ============
        function getIntersection(event) {
            if (!currentModel) return null;

            const rect = canvas.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(currentModel, true);

            return intersects.length > 0 ? intersects[0].point.clone() : null;
        }

        // ============ Canvas Events ============
        function onCanvasClick(event) {
            // Prevent click event right after dragging
            if (wasDragging) {
                wasDragging = false;
                return;
            }
            
            if (!currentTool || !currentModel) return;

            const point = getIntersection(event);
            if (!point) return;

            if (currentTool === 'point') {
                openAnnotationPopup(event, 'point', [point]);
                setTool(null);
            } else if (currentTool === 'line') {
                tempPoints.push(point);
                updateTempLine();
            } else if (currentTool === 'polygon') {
                tempPoints.push(point);
                updateTempLine();
            } else if (currentTool === 'measure') {
                measurePoints.push(point);
                addMeasureMarker(point);
                
                if (measurePoints.length === 2) {
                    const dist = measurePoints[0].distanceTo(measurePoints[1]);
                    
                    // Create the line
                    updateMeasureLine();
                    
                    // Create label at midpoint
                    const midpoint = new THREE.Vector3().addVectors(measurePoints[0], measurePoints[1]).multiplyScalar(0.5);
                    const labelText = `${dist.toFixed(3)} units`;
                    const label = createScaledTextSprite(labelText, '#AA8101', midpoint, 0.5);
                    annotationObjects.add(label);
                    
                    // Store this measurement
                    const measurementId = measurements.length + 1;
                    measurements.push({
                        id: measurementId,
                        distance: dist,
                        markers: [...measureMarkers],
                        line: measureLine,
                        label: label
                    });
                    
                    // Update display
                    updateMeasurementsDisplay();
                    
                    // Reset for next measurement but keep existing ones
                    measurePoints = [];
                    measureMarkers = [];
                    measureLine = null;
                }
            } else if (currentTool === 'surface') {
                // Surface painting is handled by mousedown/mousemove
                // Single click just paints at that point
                isErasingMode = event.shiftKey;
                const hitInfo = getIntersectionWithFace(event);
                if (hitInfo) {
                    paintAtPoint(hitInfo.point, hitInfo.mesh, hitInfo.faceIndex);
                }
            }
        }

        function onCanvasDblClick(event) {
            if (!currentModel) return;

            const point = getIntersection(event);

            if (currentTool === 'line' && tempPoints.length >= 2) {
                openAnnotationPopup(event, 'line', [...tempPoints]);
                setTool(null);
            } else if (currentTool === 'polygon' && tempPoints.length >= 3) {
                openAnnotationPopup(event, 'polygon', [...tempPoints]);
                setTool(null);
            } else if (currentTool === 'surface' && paintedFaces.size > 0) {
                finishSurfacePainting(event);
                setTool(null);
            }
        }

        function onCanvasMouseDown(event) {
            // Handle surface painting - only on left click (button 0)
            // Right click (button 2) allows panning to rotate view while painting
            if (currentTool === 'surface' && currentModel && event.button === 0) {
                isPaintingSurface = true;
                isErasingMode = event.shiftKey;
                controls.enabled = false; // Disable orbit during painting
                
                const hitInfo = getIntersectionWithFace(event);
                if (hitInfo) {
                    paintAtPoint(hitInfo.point, hitInfo.mesh, hitInfo.faceIndex);
                }
                return;
            }
            
            if (!currentModel || currentTool) return; // Don't drag when a tool is active
            
            const rect = canvas.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            // Check for intersection with annotation markers
            const markerObjects = annotationObjects.children.filter(obj => 
                obj.userData.isAnnotationMarker && obj.isMesh
            );
            
            const intersects = raycaster.intersectObjects(markerObjects);
            
            if (intersects.length > 0) {
                const marker = intersects[0].object;
                const annId = marker.userData.annotationId;
                const pointIndex = marker.userData.pointIndex;
                
                draggedAnnotation = annotations.find(a => a.id === annId);
                if (draggedAnnotation) {
                    isDraggingPoint = true;
                    draggedPointIndex = pointIndex;
                    draggedMarker = marker;
                    controls.enabled = false; // Disable orbit controls during drag
                    canvas.style.cursor = 'grabbing';
                }
            }
        }

        function onCanvasMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );
            
            // Handle surface painting
            if (isPaintingSurface && currentTool === 'surface' && currentModel) {
                isErasingMode = event.shiftKey;
                const hitInfo = getIntersectionWithFace(event);
                if (hitInfo) {
                    paintAtPoint(hitInfo.point, hitInfo.mesh, hitInfo.faceIndex);
                }
                return;
            }
            
            // Handle active dragging
            if (isDraggingPoint && draggedMarker && currentModel) {
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);
                
                const intersects = raycaster.intersectObject(currentModel, true);
                
                if (intersects.length > 0) {
                    const newPos = intersects[0].point;
                    draggedMarker.position.copy(newPos);
                    
                    // Update the annotation data in real-time for visual feedback
                    if (draggedAnnotation && draggedPointIndex >= 0) {
                        draggedAnnotation.points[draggedPointIndex] = {
                            x: newPos.x,
                            y: newPos.y,
                            z: newPos.z
                        };
                        
                        // Re-render to update lines/polygons
                        renderAnnotations();
                        
                        // Re-find the marker after re-render
                        const markers = annotationObjects.children.filter(obj => 
                            obj.userData.isAnnotationMarker && 
                            obj.userData.annotationId === draggedAnnotation.id &&
                            obj.userData.pointIndex === draggedPointIndex
                        );
                        if (markers.length > 0) {
                            draggedMarker = markers[0];
                        }
                    }
                }
                return;
            }
            
            // Handle hover cursor when not dragging and no tool active
            if (!currentTool && currentModel) {
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);
                
                const markerObjects = annotationObjects.children.filter(obj => 
                    obj.userData.isAnnotationMarker && obj.isMesh
                );
                
                const intersects = raycaster.intersectObjects(markerObjects);
                
                if (intersects.length > 0) {
                    canvas.style.cursor = 'grab';
                } else {
                    canvas.style.cursor = 'default';
                }
            }
        }

        function onCanvasMouseUp(event) {
            // Handle surface painting stop
            if (isPaintingSurface) {
                isPaintingSurface = false;
                controls.enabled = true; // Re-enable orbit controls
            }
            
            if (isDraggingPoint) {
                wasDragging = true; // Prevent click event
                isDraggingPoint = false;
                draggedAnnotation = null;
                draggedPointIndex = -1;
                draggedMarker = null;
                controls.enabled = true; // Re-enable orbit controls
                canvas.style.cursor = 'default';
                
                // Final render and update UI
                renderAnnotations();
                updateGroupsList();
                showStatus('Point moved');
            }
        }

        function updateTempLine() {
            if (tempLine) {
                annotationObjects.remove(tempLine);
            }

            if (tempPoints.length < 2) return;

            const positions = [];
            tempPoints.forEach(p => positions.push(p.x, p.y, p.z));

            const geometry = new LineGeometry();
            geometry.setPositions(positions);

            const material = new LineMaterial({
                color: 0xEDC040,
                linewidth: 3,
                resolution: new THREE.Vector2(window.innerWidth - 320, window.innerHeight - 50),
                polygonOffset: true,
                polygonOffsetFactor: -4,
                polygonOffsetUnits: -4
            });

            tempLine = new Line2(geometry, material);
            annotationObjects.add(tempLine);
        }

        function addMeasureMarker(point) {
            const geometry = new THREE.SphereGeometry(0.01, 16, 16);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xFFFFFF,  // White for contrast
                depthTest: true,
                polygonOffset: true,
                polygonOffsetFactor: -5,
                polygonOffsetUnits: -5
            });
            const marker = new THREE.Mesh(geometry, material);
            marker.position.copy(point);
            marker.renderOrder = 1000;  // Render on top
            
            if (currentModel) {
                const box = new THREE.Box3().setFromObject(currentModel);
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                marker.scale.setScalar(Math.pow(maxDim, 0.8) * 0.05);  // Larger markers
            }

            annotationObjects.add(marker);
            measureMarkers.push(marker);
        }

        function updateMeasureLine() {
            if (measureLine) {
                annotationObjects.remove(measureLine);
            }

            if (measurePoints.length !== 2) return;

            const positions = [
                measurePoints[0].x, measurePoints[0].y, measurePoints[0].z,
                measurePoints[1].x, measurePoints[1].y, measurePoints[1].z
            ];

            const geometry = new LineGeometry();
            geometry.setPositions(positions);

            const material = new LineMaterial({
                color: 0xAA8101,
                linewidth: 3,
                resolution: new THREE.Vector2(window.innerWidth - 320, window.innerHeight - 50),
                polygonOffset: true,
                polygonOffsetFactor: -4,
                polygonOffsetUnits: -4
            });

            measureLine = new Line2(geometry, material);
            annotationObjects.add(measureLine);
        }

        function updateMeasurementsDisplay() {
            if (measurements.length === 0) {
                measurementsList.innerHTML = '<div style="color: #888;">No measurements yet</div>';
            } else {
                measurementsList.innerHTML = measurements.map(m => `
                    <div class="measurement-item">
                        <span class="label">Distance ${m.id}:</span>
                        <span class="value">${m.distance.toFixed(3)} units</span>
                    </div>
                `).join('');
            }
        }

        function clearAllMeasurements() {
            // Clear current in-progress measurement
            measurePoints = [];
            measureMarkers.forEach(m => annotationObjects.remove(m));
            measureMarkers = [];
            if (measureLine) {
                annotationObjects.remove(measureLine);
                measureLine = null;
            }
            
            // Clear all saved measurements
            measurements.forEach(m => {
                m.markers.forEach(marker => annotationObjects.remove(marker));
                if (m.line) annotationObjects.remove(m.line);
                if (m.label) annotationObjects.remove(m.label);
            });
            measurements = [];
            
            updateMeasurementsDisplay();
        }

        // ============ Groups ============
        function createDefaultGroup() {
            if (groups.length === 0) {
                groups.push({
                    id: Date.now(),
                    name: 'Default',
                    color: '#EDC040',
                    visible: true
                });
                updateGroupsList();
            }
        }

        function openGroupPopup(group = null) {
            editingGroup = group;
            
            if (group) {
                groupPopupTitle.textContent = 'Edit Group';
                groupName.value = group.name;
                groupColor.value = group.color;
                btnGroupDelete.style.display = groups.length > 1 ? 'block' : 'none';
            } else {
                groupPopupTitle.textContent = 'New Group';
                groupName.value = '';
                groupColor.value = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
                btnGroupDelete.style.display = 'none';
            }

            groupPopup.classList.add('visible');
            groupName.focus();
        }

        function saveGroup() {
            const name = groupName.value.trim() || 'Unnamed Group';
            const color = groupColor.value;

            if (editingGroup) {
                editingGroup.name = name;
                editingGroup.color = color;
            } else {
                groups.push({
                    id: Date.now(),
                    name,
                    color,
                    visible: true
                });
            }

            groupPopup.classList.remove('visible');
            editingGroup = null;
            updateGroupsList();
            updateGroupSelect();
            renderAnnotations();
        }

        function deleteGroup(group) {
            if (groups.length <= 1) {
                showStatus('Cannot delete the last group');
                return;
            }

            // Move annotations to first other group
            const targetGroup = groups.find(g => g.id !== group.id);
            annotations.forEach(ann => {
                if (ann.groupId === group.id) {
                    ann.groupId = targetGroup.id;
                }
            });

            groups = groups.filter(g => g.id !== group.id);
            groupPopup.classList.remove('visible');
            editingGroup = null;
            updateGroupsList();
            updateGroupSelect();
            renderAnnotations();
        }

        function toggleGroupVisibility(group) {
            group.visible = !group.visible;
            updateGroupsList();
            renderAnnotations();
        }

        function updateGroupsList() {
            if (groups.length === 0) {
                noGroups.style.display = 'block';
                groupsContainer.innerHTML = '';
                return;
            }

            noGroups.style.display = 'none';
            
            groupsContainer.innerHTML = groups.map(group => {
                const groupAnnotations = annotations.filter(a => a.groupId === group.id);
                return `
                    <div class="group-item" data-id="${group.id}">
                        <div class="group-header">
                            <div class="group-color" style="background: ${group.color}" data-action="edit"></div>
                            <span class="group-name" data-action="edit">${escapeHtml(group.name)} (${groupAnnotations.length})</span>
                            <button class="group-visibility ${group.visible ? '' : 'hidden'}" data-action="visibility">
                                ${group.visible ? 'üëÅ' : 'üëÅ‚Äçüó®'}
                            </button>
                            <div class="group-actions">
                                <button data-action="edit">‚úèÔ∏è</button>
                            </div>
                        </div>
                        ${group.visible ? `
                            <div class="annotation-list">
                                ${groupAnnotations.map(ann => renderAnnotationItem(ann)).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');

            // Event listeners
            groupsContainer.querySelectorAll('.group-header').forEach(header => {
                header.addEventListener('click', (e) => {
                    const groupId = parseInt(header.closest('.group-item').dataset.id);
                    const group = groups.find(g => g.id === groupId);
                    const action = e.target.dataset.action || e.target.closest('[data-action]')?.dataset.action;

                    if (action === 'visibility') {
                        toggleGroupVisibility(group);
                    } else if (action === 'edit') {
                        openGroupPopup(group);
                    }
                });
            });

            // Annotation click handlers
            groupsContainer.querySelectorAll('.annotation-item').forEach(item => {
                item.addEventListener('click', () => {
                    const id = parseInt(item.dataset.id);
                    selectAnnotation(id);
                });
                item.addEventListener('dblclick', () => {
                    const id = parseInt(item.dataset.id);
                    const ann = annotations.find(a => a.id === id);
                    if (ann) openAnnotationPopupForEdit(ann);
                });
            });
        }

        function renderAnnotationItem(ann) {
            const icons = { point: 'üìç', line: 'üìè', polygon: '‚¨°', surface: 'üé®' };
            const entryCount = (ann.entries && ann.entries.length) || 0;
            const entryText = entryCount === 1 ? '1 entry' : `${entryCount} entries`;
            return `
                <div class="annotation-item ${selectedAnnotation === ann.id ? 'selected' : ''}" data-id="${ann.id}">
                    <div class="header">
                        <span class="type-icon">${icons[ann.type] || 'üìç'}</span>
                        <span class="name">${escapeHtml(ann.name)}</span>
                    </div>
                    <div class="description">${entryText}</div>
                </div>
            `;
        }

        function updateGroupSelect() {
            annGroup.innerHTML = groups.map(g => 
                `<option value="${g.id}">${escapeHtml(g.name)}</option>`
            ).join('');
        }

        // ============ Annotations ============
        function openAnnotationPopup(event, type, points, faceData = null) {
            editingAnnotation = null;
            editingModelInfo = false;
            isAddingEntry = false;
            editingEntryId = null;
            pendingLinks = [];
            
            popupTitle.textContent = `New ${type.charAt(0).toUpperCase() + type.slice(1)}`;
            annName.value = '';
            annDescription.value = '';
            annAuthor.value = getLastAuthor();
            updateGroupSelect();
            updateLinksDisplay();
            btnPopupDelete.style.display = 'none';
            
            // Show name/group fields, new entry form, hide entries container
            document.getElementById('popup-main-fields').style.display = 'block';
            entriesContainer.style.display = 'none';
            newEntryForm.style.display = 'block';

            // Store temp data
            annotationPopup.dataset.type = type;
            annotationPopup.dataset.points = JSON.stringify(points.map(p => ({ x: p.x, y: p.y, z: p.z })));
            
            // Store face data for surface annotations
            if (faceData) {
                annotationPopup.dataset.faceData = JSON.stringify(faceData);
            } else {
                delete annotationPopup.dataset.faceData;
            }

            // For surface annotations, center the popup since double-click position is arbitrary
            if (type === 'surface') {
                annotationPopup.style.left = '50%';
                annotationPopup.style.top = '50%';
                annotationPopup.style.transform = 'translate(-50%, -50%)';
            } else {
                positionPopup(annotationPopup, event.clientX, event.clientY);
            }
            annotationPopup.classList.add('visible');
            annName.focus();
        }

        function openAnnotationPopupForEdit(ann) {
            editingAnnotation = ann;
            editingModelInfo = false;
            isAddingEntry = false;
            editingEntryId = null;
            pendingLinks = [];

            popupTitle.textContent = `Edit ${ann.type.charAt(0).toUpperCase() + ann.type.slice(1)}`;
            annName.value = ann.name;
            updateGroupSelect();
            annGroup.value = ann.groupId;
            btnPopupDelete.style.display = 'block';

            annotationPopup.dataset.type = ann.type;
            annotationPopup.dataset.points = JSON.stringify(ann.points);

            // Show name/group fields, entries container, hide new entry form initially
            document.getElementById('popup-main-fields').style.display = 'block';
            entriesContainer.style.display = 'block';
            newEntryForm.style.display = 'none';
            
            // Render existing entries
            renderEntriesList(ann);

            annotationPopup.style.left = '50%';
            annotationPopup.style.top = '50%';
            annotationPopup.style.transform = 'translate(-50%, -50%)';
            annotationPopup.classList.add('visible');
            annName.focus();
        }
        
        // ============ Model Information ============
        function openModelInfoPopup() {
            editingAnnotation = null;
            editingModelInfo = true;
            isAddingEntry = false;
            editingEntryId = null;
            pendingLinks = [];

            popupTitle.textContent = 'Model Information';
            
            // Hide name/group fields for model info
            document.getElementById('popup-main-fields').style.display = 'none';
            btnPopupDelete.style.display = 'none';

            // Show entries container
            entriesContainer.style.display = 'block';
            
            // Show new entry form if no entries exist, otherwise hide it
            if (modelInfo.entries.length === 0) {
                newEntryForm.style.display = 'block';
                annDescription.value = '';
                annAuthor.value = getLastAuthor();
                updateLinksDisplay();
            } else {
                newEntryForm.style.display = 'none';
            }
            
            // Render existing entries
            renderModelInfoEntriesList();

            annotationPopup.style.left = '50%';
            annotationPopup.style.top = '50%';
            annotationPopup.style.transform = 'translate(-50%, -50%)';
            annotationPopup.classList.add('visible');
        }
        
        function renderModelInfoEntriesList() {
            const entries = modelInfo.entries || [];
            
            if (entries.length === 0) {
                entriesList.innerHTML = '<div style="color: #888; padding: 10px; text-align: center;">No entries yet. Add general information about this model.</div>';
                return;
            }
            
            entriesList.innerHTML = entries.map((entry, index) => {
                const date = new Date(entry.timestamp);
                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                const linksHtml = (entry.links && entry.links.length > 0) ? `
                    <div class="entry-card-links">
                        ${entry.links.map(link => `<a href="${escapeHtml(link)}" target="_blank">üîó ${escapeHtml(link.split('/').pop() || link)}</a>`).join('')}
                    </div>
                ` : '';
                
                return `
                    <div class="entry-card" data-entry-id="${entry.id}">
                        <div class="entry-card-header">
                            <div class="entry-card-meta">
                                <span class="author">${escapeHtml(entry.author || 'Unknown')}</span> ‚Ä¢ ${dateStr}
                            </div>
                            <div class="entry-card-actions">
                                <button data-action="edit" data-entry-id="${entry.id}">‚úèÔ∏è Edit</button>
                                <button data-action="delete" data-entry-id="${entry.id}">üóëÔ∏è</button>
                            </div>
                        </div>
                        <div class="entry-card-description">${escapeHtml(entry.description || '')}</div>
                        ${linksHtml}
                        <div class="entry-edit-form">
                            <textarea data-field="description">${escapeHtml(entry.description || '')}</textarea>
                            <input type="text" data-field="author" value="${escapeHtml(entry.author || '')}" placeholder="Author">
                            <div class="links-section">
                                <label>Links</label>
                                <div class="entry-links-list" data-entry-id="${entry.id}">
                                    ${(entry.links || []).map((link, li) => `
                                        <div class="link-item">
                                            <a href="${escapeHtml(link)}" target="_blank">${escapeHtml(link)}</a>
                                            <button data-link-index="${li}">‚úï</button>
                                        </div>
                                    `).join('')}
                                </div>
                                <div class="add-link-row">
                                    <input type="text" data-field="new-link" placeholder="https://...">
                                    <button class="btn-save" data-action="add-link">+</button>
                                </div>
                            </div>
                            <div class="entry-edit-buttons">
                                <button class="btn-cancel" data-action="cancel-edit">Cancel</button>
                                <button class="btn-save" data-action="save-edit">Save Entry</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Add event listeners for model info entries
            entriesList.querySelectorAll('.entry-card-actions button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const entryId = parseInt(btn.dataset.entryId);
                    const action = btn.dataset.action;
                    
                    if (action === 'edit') {
                        const entry = modelInfo.entries.find(en => en.id === entryId);
                        const isOldEntry = modelInfo.entries.indexOf(entry) < modelInfo.entries.length - 1;
                        
                        if (isOldEntry) {
                            showConfirm('This is an older entry. Are you sure you want to edit it instead of adding a new entry?', () => {
                                startEditingModelInfoEntry(entryId);
                            });
                        } else {
                            startEditingModelInfoEntry(entryId);
                        }
                    } else if (action === 'delete') {
                        showConfirm('Are you sure you want to delete this entry? This cannot be undone.', () => {
                            deleteModelInfoEntry(entryId);
                        });
                    }
                });
            });
            
            // Entry edit form buttons
            entriesList.querySelectorAll('.entry-edit-form button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const action = btn.dataset.action;
                    const card = btn.closest('.entry-card');
                    const entryId = parseInt(card.dataset.entryId);
                    
                    if (action === 'cancel-edit') {
                        cancelEditingEntry();
                        renderModelInfoEntriesList();
                    } else if (action === 'save-edit') {
                        saveModelInfoEntryEdit(entryId, card);
                    } else if (action === 'add-link') {
                        const input = card.querySelector('[data-field="new-link"]');
                        const link = input.value.trim();
                        if (link) {
                            const entry = modelInfo.entries.find(en => en.id === entryId);
                            if (!entry.links) entry.links = [];
                            entry.links.push(link);
                            input.value = '';
                            renderModelInfoEntriesList();
                            startEditingModelInfoEntry(entryId);
                        }
                    }
                });
            });
            
            // Link delete buttons in edit mode
            entriesList.querySelectorAll('.entry-links-list button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const card = btn.closest('.entry-card');
                    const entryId = parseInt(card.dataset.entryId);
                    const linkIndex = parseInt(btn.dataset.linkIndex);
                    const entry = modelInfo.entries.find(en => en.id === entryId);
                    if (entry && entry.links) {
                        entry.links.splice(linkIndex, 1);
                        renderModelInfoEntriesList();
                        startEditingModelInfoEntry(entryId);
                    }
                });
            });
        }
        
        function startEditingModelInfoEntry(entryId) {
            editingEntryId = entryId;
            entriesList.querySelectorAll('.entry-card').forEach(card => {
                if (parseInt(card.dataset.entryId) === entryId) {
                    card.classList.add('editing');
                } else {
                    card.classList.remove('editing');
                }
            });
        }
        
        function saveModelInfoEntryEdit(entryId, card) {
            const entry = modelInfo.entries.find(en => en.id === entryId);
            if (!entry) return;
            
            const description = card.querySelector('[data-field="description"]').value.trim();
            const author = card.querySelector('[data-field="author"]').value.trim();
            
            entry.description = description;
            entry.author = author;
            saveLastAuthor(author);
            
            editingEntryId = null;
            renderModelInfoEntriesList();
            updateModelInfoDisplay();
            showStatus('Entry updated');
        }
        
        function deleteModelInfoEntry(entryId) {
            modelInfo.entries = modelInfo.entries.filter(e => e.id !== entryId);
            renderModelInfoEntriesList();
            updateModelInfoDisplay();
            showStatus('Entry deleted');
        }
        
        function updateModelInfoDisplay() {
            const entryCount = modelInfo.entries.length;
            if (entryCount === 0) {
                modelInfoSubtitle.textContent = 'No entries yet';
            } else {
                modelInfoSubtitle.textContent = entryCount === 1 ? '1 entry' : `${entryCount} entries`;
            }
        }
        
        function renderEntriesList(ann) {
            const entries = ann.entries || [];
            
            if (entries.length === 0) {
                entriesList.innerHTML = '<div style="color: #888; padding: 10px; text-align: center;">No entries yet</div>';
                return;
            }
            
            entriesList.innerHTML = entries.map((entry, index) => {
                const date = new Date(entry.timestamp);
                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                const linksHtml = (entry.links && entry.links.length > 0) ? `
                    <div class="entry-card-links">
                        ${entry.links.map(link => `<a href="${escapeHtml(link)}" target="_blank">üîó ${escapeHtml(link.split('/').pop() || link)}</a>`).join('')}
                    </div>
                ` : '';
                
                return `
                    <div class="entry-card" data-entry-id="${entry.id}">
                        <div class="entry-card-header">
                            <div class="entry-card-meta">
                                <span class="author">${escapeHtml(entry.author || 'Unknown')}</span> ‚Ä¢ ${dateStr}
                            </div>
                            <div class="entry-card-actions">
                                <button data-action="edit" data-entry-id="${entry.id}">‚úèÔ∏è Edit</button>
                                <button data-action="delete" data-entry-id="${entry.id}">üóëÔ∏è</button>
                            </div>
                        </div>
                        <div class="entry-card-description">${escapeHtml(entry.description || '')}</div>
                        ${linksHtml}
                        <div class="entry-edit-form">
                            <textarea data-field="description">${escapeHtml(entry.description || '')}</textarea>
                            <input type="text" data-field="author" value="${escapeHtml(entry.author || '')}" placeholder="Author">
                            <div class="links-section">
                                <label>Links</label>
                                <div class="entry-links-list" data-entry-id="${entry.id}">
                                    ${(entry.links || []).map((link, li) => `
                                        <div class="link-item">
                                            <a href="${escapeHtml(link)}" target="_blank">${escapeHtml(link)}</a>
                                            <button data-link-index="${li}">‚úï</button>
                                        </div>
                                    `).join('')}
                                </div>
                                <div class="add-link-row">
                                    <input type="text" data-field="new-link" placeholder="https://...">
                                    <button class="btn-save" data-action="add-link">+</button>
                                </div>
                            </div>
                            <div class="entry-edit-buttons">
                                <button class="btn-cancel" data-action="cancel-edit">Cancel</button>
                                <button class="btn-save" data-action="save-edit">Save Entry</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Add event listeners
            entriesList.querySelectorAll('.entry-card-actions button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const entryId = parseInt(btn.dataset.entryId);
                    const action = btn.dataset.action;
                    
                    if (action === 'edit') {
                        const entry = ann.entries.find(en => en.id === entryId);
                        const isOldEntry = ann.entries.indexOf(entry) < ann.entries.length - 1;
                        
                        if (isOldEntry) {
                            showConfirm('This is an older entry. Are you sure you want to edit it instead of adding a new entry?', () => {
                                startEditingEntry(entryId);
                            });
                        } else {
                            startEditingEntry(entryId);
                        }
                    } else if (action === 'delete') {
                        showConfirm('Are you sure you want to delete this entry? This cannot be undone.', () => {
                            deleteEntry(entryId);
                        });
                    }
                });
            });
            
            // Entry edit form buttons
            entriesList.querySelectorAll('.entry-edit-form button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const action = btn.dataset.action;
                    const card = btn.closest('.entry-card');
                    const entryId = parseInt(card.dataset.entryId);
                    
                    if (action === 'cancel-edit') {
                        cancelEditingEntry();
                        renderEntriesList(ann);
                    } else if (action === 'save-edit') {
                        saveEntryEdit(entryId, card);
                    } else if (action === 'add-link') {
                        const input = card.querySelector('[data-field="new-link"]');
                        const link = input.value.trim();
                        if (link) {
                            const entry = ann.entries.find(en => en.id === entryId);
                            if (!entry.links) entry.links = [];
                            entry.links.push(link);
                            input.value = '';
                            renderEntriesList(ann);
                            startEditingEntry(entryId); // Keep in edit mode
                        }
                    }
                });
            });
            
            // Link delete buttons in edit mode
            entriesList.querySelectorAll('.entry-links-list button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const card = btn.closest('.entry-card');
                    const entryId = parseInt(card.dataset.entryId);
                    const linkIndex = parseInt(btn.dataset.linkIndex);
                    const entry = ann.entries.find(en => en.id === entryId);
                    if (entry && entry.links) {
                        entry.links.splice(linkIndex, 1);
                        renderEntriesList(ann);
                        startEditingEntry(entryId);
                    }
                });
            });
        }
        
        function startEditingEntry(entryId) {
            editingEntryId = entryId;
            entriesList.querySelectorAll('.entry-card').forEach(card => {
                if (parseInt(card.dataset.entryId) === entryId) {
                    card.classList.add('editing');
                } else {
                    card.classList.remove('editing');
                }
            });
        }
        
        function cancelEditingEntry() {
            editingEntryId = null;
            entriesList.querySelectorAll('.entry-card').forEach(card => {
                card.classList.remove('editing');
            });
        }
        
        function saveEntryEdit(entryId, card) {
            const entry = editingAnnotation.entries.find(en => en.id === entryId);
            if (!entry) return;
            
            const description = card.querySelector('[data-field="description"]').value.trim();
            const author = card.querySelector('[data-field="author"]').value.trim();
            
            entry.description = description;
            entry.author = author;
            saveLastAuthor(author);
            
            editingEntryId = null;
            renderEntriesList(editingAnnotation);
            showStatus('Entry updated');
        }
        
        function deleteEntry(entryId) {
            if (!editingAnnotation || !editingAnnotation.entries) return;
            
            editingAnnotation.entries = editingAnnotation.entries.filter(e => e.id !== entryId);
            renderEntriesList(editingAnnotation);
            updateGroupsList();
            showStatus('Entry deleted');
        }
        
        function showAddEntryForm() {
            isAddingEntry = true;
            newEntryForm.style.display = 'block';
            annDescription.value = '';
            annAuthor.value = getLastAuthor();
            pendingLinks = [];
            updateLinksDisplay();
            annDescription.focus();
        }
        
        function hideAddEntryForm() {
            isAddingEntry = false;
            newEntryForm.style.display = 'none';
        }
        
        function showConfirm(message, callback) {
            confirmMessage.textContent = message;
            confirmCallback = callback;
            confirmOverlay.classList.add('visible');
        }
        
        function hideConfirm() {
            confirmOverlay.classList.remove('visible');
            confirmCallback = null;
        }

        function positionPopup(popup, x, y) {
            popup.style.transform = 'none';
            popup.style.left = `${x + 10}px`;
            popup.style.top = `${y + 10}px`;

            requestAnimationFrame(() => {
                const rect = popup.getBoundingClientRect();
                // Check right edge (account for sidebar)
                if (rect.right > window.innerWidth - 320) {
                    popup.style.left = `${x - rect.width - 10}px`;
                }
                // Check bottom edge
                if (rect.bottom > window.innerHeight) {
                    popup.style.top = `${y - rect.height - 10}px`;
                }
                // Check top edge (account for header)
                const newRect = popup.getBoundingClientRect();
                if (newRect.top < 50) {
                    popup.style.top = '60px';
                }
                // Check left edge
                if (newRect.left < 10) {
                    popup.style.left = '10px';
                }
            });
        }

        function saveAnnotation() {
            // Handle Model Information save
            if (editingModelInfo) {
                if (isAddingEntry || modelInfo.entries.length === 0) {
                    const description = annDescription.value.trim();
                    const author = annAuthor.value.trim();
                    
                    if (description || author) {
                        saveLastAuthor(author);
                        modelInfo.entries.push({
                            id: Date.now(),
                            description,
                            author,
                            timestamp: new Date().toISOString(),
                            links: [...pendingLinks]
                        });
                    }
                }
                
                annotationPopup.classList.remove('visible');
                isAddingEntry = false;
                editingModelInfo = false;
                updateModelInfoDisplay();
                showStatus('Model information saved');
                return;
            }
            
            const type = annotationPopup.dataset.type;
            const points = JSON.parse(annotationPopup.dataset.points);
            const name = annName.value.trim() || 'Unnamed';
            const groupId = parseInt(annGroup.value) || groups[0].id;

            if (editingAnnotation) {
                // Update name and group
                editingAnnotation.name = name;
                editingAnnotation.groupId = groupId;
                
                // If adding a new entry
                if (isAddingEntry) {
                    const description = annDescription.value.trim();
                    const author = annAuthor.value.trim();
                    saveLastAuthor(author);
                    
                    if (!editingAnnotation.entries) editingAnnotation.entries = [];
                    editingAnnotation.entries.push({
                        id: Date.now(),
                        description,
                        author,
                        timestamp: new Date().toISOString(),
                        links: [...pendingLinks]
                    });
                }
            } else {
                // Create new annotation with first entry
                const description = annDescription.value.trim();
                const author = annAuthor.value.trim();
                saveLastAuthor(author);
                
                const newAnnotation = {
                    id: Date.now(),
                    type,
                    name,
                    groupId,
                    points,
                    entries: [{
                        id: Date.now() + 1,
                        description,
                        author,
                        timestamp: new Date().toISOString(),
                        links: [...pendingLinks]
                    }]
                };
                
                // Add face data for surface annotations
                if (type === 'surface' && annotationPopup.dataset.faceData) {
                    newAnnotation.faceData = JSON.parse(annotationPopup.dataset.faceData);
                }
                
                annotations.push(newAnnotation);
            }

            annotationPopup.classList.remove('visible');
            isAddingEntry = false;
            clearTempDrawing();
            updateGroupsList();
            renderAnnotations();
            showStatus(`Saved: ${name}`);
        }

        function deleteAnnotation() {
            if (!editingAnnotation) return;
            
            showConfirm('Are you sure you want to delete this annotation and all its entries? This cannot be undone.', () => {
                annotations = annotations.filter(a => a.id !== editingAnnotation.id);
                annotationPopup.classList.remove('visible');
                editingAnnotation = null;
                selectedAnnotation = null;
                updateGroupsList();
                renderAnnotations();
                showStatus('Annotation deleted');
            });
        }

        function selectAnnotation(id) {
            selectedAnnotation = id;
            const ann = annotations.find(a => a.id === id);
            
            if (ann && ann.points.length > 0) {
                const center = new THREE.Vector3();
                ann.points.forEach(p => center.add(new THREE.Vector3(p.x, p.y, p.z)));
                center.divideScalar(ann.points.length);
                controls.target.copy(center);
                controls.update();
            }

            updateGroupsList();
        }

        function updateLinksDisplay() {
            annLinks.innerHTML = pendingLinks.map((link, i) => `
                <div class="link-item">
                    <a href="${escapeHtml(link)}" target="_blank">${escapeHtml(link)}</a>
                    <button data-index="${i}">‚úï</button>
                </div>
            `).join('');

            annLinks.querySelectorAll('button').forEach(btn => {
                btn.addEventListener('click', () => {
                    pendingLinks.splice(parseInt(btn.dataset.index), 1);
                    updateLinksDisplay();
                });
            });
        }

        function addLink() {
            const url = annNewLink.value.trim();
            if (url) {
                pendingLinks.push(url);
                annNewLink.value = '';
                updateLinksDisplay();
            }
        }

        // ============ Render Annotations ============
        function renderAnnotations() {
            // Clear existing
            while (annotationObjects.children.length > 0) {
                annotationObjects.remove(annotationObjects.children[0]);
            }

            const modelSize = currentModel ? 
                new THREE.Box3().setFromObject(currentModel).getSize(new THREE.Vector3()) :
                new THREE.Vector3(1, 1, 1);
            const maxDim = Math.max(modelSize.x, modelSize.y, modelSize.z);
            const labelOffset = Math.pow(maxDim, 0.8) * 0.012; // Offset to clear larger markers

            annotations.forEach(ann => {
                const group = groups.find(g => g.id === ann.groupId);
                if (!group || !group.visible) return;

                const color = new THREE.Color(group.color);
                let labelPosition;

                if (ann.type === 'point') {
                    const geometry = new THREE.SphereGeometry(0.02, 16, 16);
                    const material = new THREE.MeshBasicMaterial({ color });
                    const marker = new THREE.Mesh(geometry, material);
                    marker.position.set(ann.points[0].x, ann.points[0].y, ann.points[0].z);
                    marker.scale.setScalar(Math.pow(maxDim, 0.8) * 0.025);
                    marker.userData.annotationId = ann.id;
                    marker.userData.pointIndex = 0;
                    marker.userData.isAnnotationMarker = true;
                    annotationObjects.add(marker);
                    
                    // Label position slightly above the point
                    labelPosition = new THREE.Vector3(
                        ann.points[0].x,
                        ann.points[0].y + labelOffset,
                        ann.points[0].z
                    );
                } else if (ann.type === 'line' || ann.type === 'polygon') {
                    const points = ann.points.map(p => new THREE.Vector3(p.x, p.y, p.z));
                    
                    if (ann.type === 'polygon' && points.length > 0) {
                        points.push(points[0].clone()); // Close the polygon
                    }

                    // Build positions array for Line2
                    const positions = [];
                    points.forEach(p => positions.push(p.x, p.y, p.z));

                    // Create thick line
                    const lineGeometry = new LineGeometry();
                    lineGeometry.setPositions(positions);

                    const lineMaterial = new LineMaterial({
                        color: color,
                        linewidth: 3,
                        resolution: new THREE.Vector2(window.innerWidth - 320, window.innerHeight - 50),
                        polygonOffset: true,
                        polygonOffsetFactor: -4,
                        polygonOffsetUnits: -4
                    });

                    const line = new Line2(lineGeometry, lineMaterial);
                    line.userData.annotationId = ann.id;
                    annotationObjects.add(line);

                    // Points along the line/polygon
                    ann.points.forEach((p, index) => {
                        const geometry = new THREE.SphereGeometry(0.02, 12, 12);
                        const material = new THREE.MeshBasicMaterial({ color });
                        const marker = new THREE.Mesh(geometry, material);
                        marker.position.set(p.x, p.y, p.z);
                        marker.scale.setScalar(Math.pow(maxDim, 0.8) * 0.018);
                        marker.userData.annotationId = ann.id;
                        marker.userData.pointIndex = index;
                        marker.userData.isAnnotationMarker = true;
                        annotationObjects.add(marker);
                    });
                    
                    // Label position: centroid for polygons, first point for lines
                    if (ann.type === 'polygon' && ann.points.length > 0) {
                        const centroid = ann.points.reduce(
                            (acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y, z: acc.z + p.z }),
                            { x: 0, y: 0, z: 0 }
                        );
                        labelPosition = new THREE.Vector3(
                            centroid.x / ann.points.length,
                            centroid.y / ann.points.length + labelOffset,
                            centroid.z / ann.points.length
                        );
                    } else if (ann.points.length > 0) {
                        // For lines, place at first point
                        labelPosition = new THREE.Vector3(
                            ann.points[0].x,
                            ann.points[0].y + labelOffset,
                            ann.points[0].z
                        );
                    }
                } else if (ann.type === 'surface' && ann.faceData) {
                    // Render surface annotation
                    const surfaceMesh = renderSurfaceAnnotation(ann, color);
                    if (surfaceMesh) {
                        surfaceMesh.userData.annotationId = ann.id;
                        annotationObjects.add(surfaceMesh);
                    }
                    
                    // Label position from center point
                    if (ann.points && ann.points.length > 0) {
                        labelPosition = new THREE.Vector3(
                            ann.points[0].x,
                            ann.points[0].y + labelOffset,
                            ann.points[0].z
                        );
                    }
                }
                
                // Add name label if annotation has a name
                if (ann.name && labelPosition) {
                    const label = createScaledTextSprite(ann.name, group.color, labelPosition, 0.8);
                    label.userData.annotationId = ann.id;
                    annotationObjects.add(label);
                }
            });

            updateAnnotationsPanel();
        }

        function renderSurfaceAnnotation(ann, color) {
            if (!ann.faceData || ann.faceData.length === 0) return null;

            // Group faces by mesh index
            const facesByMesh = new Map();
            ann.faceData.forEach(faceId => {
                const [meshIdx, faceIdx] = faceId.split('_');
                if (!facesByMesh.has(meshIdx)) {
                    facesByMesh.set(meshIdx, []);
                }
                facesByMesh.get(meshIdx).push(parseInt(faceIdx));
            });

            // Build combined geometry
            const vertices = [];
            
            facesByMesh.forEach((faceIndices, meshIdx) => {
                const mesh = modelMeshes[parseInt(meshIdx)];
                if (!mesh) return;

                const geometry = mesh.geometry;
                const position = geometry.attributes.position;

                faceIndices.forEach(faceIdx => {
                    let a, b, c;
                    if (geometry.index) {
                        a = geometry.index.getX(faceIdx * 3);
                        b = geometry.index.getX(faceIdx * 3 + 1);
                        c = geometry.index.getX(faceIdx * 3 + 2);
                    } else {
                        a = faceIdx * 3;
                        b = faceIdx * 3 + 1;
                        c = faceIdx * 3 + 2;
                    }

                    const vA = new THREE.Vector3().fromBufferAttribute(position, a);
                    const vB = new THREE.Vector3().fromBufferAttribute(position, b);
                    const vC = new THREE.Vector3().fromBufferAttribute(position, c);

                    // Apply mesh world transform
                    vA.applyMatrix4(mesh.matrixWorld);
                    vB.applyMatrix4(mesh.matrixWorld);
                    vC.applyMatrix4(mesh.matrixWorld);

                    vertices.push(vA.x, vA.y, vA.z);
                    vertices.push(vB.x, vB.y, vB.z);
                    vertices.push(vC.x, vC.y, vC.z);
                });
            });

            if (vertices.length === 0) return null;

            // Create highlight geometry
            const highlightGeometry = new THREE.BufferGeometry();
            highlightGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            highlightGeometry.computeVertexNormals();

            const highlightMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide,
                depthTest: true,
                depthWrite: false,
                polygonOffset: true,
                polygonOffsetFactor: -4,
                polygonOffsetUnits: -4
            });

            const mesh = new THREE.Mesh(highlightGeometry, highlightMaterial);
            mesh.renderOrder = 999; // Render after everything else
            return mesh;
        }

        function updateAnnotationsPanel() {
            // Panel content is now integrated into groups list
            // This function kept for compatibility with calls from other functions
        }

        // ============ Screenshot ============
        function takeScreenshot() {
            renderer.render(scene, camera);
            const dataURL = renderer.domElement.toDataURL('image/png');
            
            const link = document.createElement('a');
            link.download = `meshnotes-screenshot-${Date.now()}.png`;
            link.href = dataURL;
            link.click();
            
            showStatus('Screenshot saved');
        }

        // ============ Export/Import ============
        function exportAnnotations() {
            const data = {
                software: 'MeshNotes',
                version: '1.0',
                modelFileName,
                exportDate: new Date().toISOString(),
                modelInfo,
                groups,
                annotations
            };

            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const link = document.createElement('a');
            link.download = `meshnotes-${modelFileName || 'export'}-${Date.now()}.json`;
            link.href = url;
            link.click();

            URL.revokeObjectURL(url);
            showStatus('Annotations exported');
        }

        // ============ PDF Export ============
        async function exportPdfReport() {
            if (!currentModel) {
                showStatus('No model loaded');
                return;
            }

            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF('p', 'mm', 'a4');
            const pageWidth = 210;
            const pageHeight = 297;
            const margin = 15;
            const contentWidth = pageWidth - (margin * 2);

            // Store original camera position
            const originalCamPos = camera.position.clone();
            const originalTarget = controls.target.clone();

            showStatus('Generating PDF report...');
            
            // Ensure all annotations (including surfaces) are rendered
            renderAnnotations();
            await delay(100);

            // Get visible groups and their annotations
            const visibleGroups = groups.filter(g => g.visible);
            const visibleAnnotations = annotations.filter(ann => {
                const group = groups.find(g => g.id === ann.groupId);
                return group && group.visible;
            });

            // Build table of contents data
            const tocData = [];
            let pageNum = 3; // Start after title page and TOC

            visibleGroups.forEach(group => {
                const groupAnns = visibleAnnotations.filter(a => a.groupId === group.id);
                if (groupAnns.length > 0) {
                    tocData.push({ type: 'group', name: group.name, page: pageNum });
                    pageNum++; // Group header page
                    groupAnns.forEach(ann => {
                        tocData.push({ type: 'annotation', name: ann.name, page: pageNum });
                        pageNum++;
                    });
                }
            });

            // ===== TITLE PAGE =====
            // Add title
            pdf.setFontSize(24);
            pdf.setTextColor(170, 129, 1); // Gold
            pdf.text('MeshNotes Report', pageWidth / 2, 25, { align: 'center' });

            // Model filename
            pdf.setFontSize(14);
            pdf.setTextColor(60, 60, 60);
            pdf.text(modelFileName || 'Untitled Model', pageWidth / 2, 35, { align: 'center' });

            // Date
            pdf.setFontSize(10);
            pdf.setTextColor(120, 120, 120);
            const dateStr = new Date().toLocaleDateString() + ' ' + new Date().toLocaleTimeString();
            pdf.text(`Generated: ${dateStr}`, pageWidth / 2, 42, { align: 'center' });

            // Overview screenshot
            await delay(100);
            renderer.render(scene, camera);
            const overviewImg = renderer.domElement.toDataURL('image/jpeg', 0.9);
            // Calculate height based on canvas aspect ratio
            const canvasAspect = canvas.width / canvas.height;
            const imgHeight = contentWidth / canvasAspect;
            pdf.addImage(overviewImg, 'JPEG', margin, 50, contentWidth, imgHeight);

            // Model Information
            let yPos = 50 + imgHeight + 10;
            pdf.setFontSize(14);
            pdf.setTextColor(170, 129, 1);
            pdf.text('Model Information', margin, yPos);
            yPos += 8;

            if (modelInfo.entries.length === 0) {
                pdf.setFontSize(10);
                pdf.setTextColor(120, 120, 120);
                pdf.text('No model information entries.', margin, yPos);
            } else {
                modelInfo.entries.forEach(entry => {
                    if (yPos > pageHeight - 40) {
                        pdf.addPage();
                        yPos = margin;
                    }

                    // Author and date
                    pdf.setFontSize(9);
                    pdf.setTextColor(170, 129, 1);
                    const entryDate = new Date(entry.timestamp);
                    const entryDateStr = entryDate.toLocaleDateString() + ' ' + entryDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                    pdf.text(`${entry.author || 'Unknown'} ‚Ä¢ ${entryDateStr}`, margin, yPos);
                    yPos += 5;

                    // Description
                    pdf.setFontSize(10);
                    pdf.setTextColor(60, 60, 60);
                    const descLines = pdf.splitTextToSize(entry.description || '', contentWidth);
                    pdf.text(descLines, margin, yPos);
                    yPos += descLines.length * 5 + 3;

                    // Links
                    if (entry.links && entry.links.length > 0) {
                        pdf.setFontSize(8);
                        pdf.setTextColor(100, 100, 200);
                        entry.links.forEach(link => {
                            pdf.textWithLink(link, margin, yPos, { url: link });
                            yPos += 4;
                        });
                    }
                    yPos += 5;
                });
            }

            // Summary stats
            yPos += 5;
            if (yPos > pageHeight - 30) {
                pdf.addPage();
                yPos = margin;
            }
            pdf.setFontSize(10);
            pdf.setTextColor(100, 100, 100);
            pdf.text(`Total: ${visibleGroups.length} groups, ${visibleAnnotations.length} annotations`, margin, yPos);

            // ===== TABLE OF CONTENTS =====
            pdf.addPage();
            pdf.setFontSize(18);
            pdf.setTextColor(170, 129, 1);
            pdf.text('Table of Contents', margin, 20);

            yPos = 35;
            pdf.setFontSize(10);

            tocData.forEach(item => {
                if (yPos > pageHeight - 20) {
                    pdf.addPage();
                    yPos = 20;
                }

                if (item.type === 'group') {
                    pdf.setTextColor(170, 129, 1);
                    pdf.setFont(undefined, 'bold');
                    pdf.text(item.name, margin, yPos);
                    pdf.setTextColor(100, 100, 100);
                    pdf.text(String(item.page), pageWidth - margin, yPos, { align: 'right' });
                    yPos += 7;
                } else {
                    pdf.setTextColor(60, 60, 60);
                    pdf.setFont(undefined, 'normal');
                    pdf.text('   ' + item.name, margin, yPos);
                    pdf.setTextColor(100, 100, 100);
                    pdf.text(String(item.page), pageWidth - margin, yPos, { align: 'right' });
                    yPos += 6;
                }
            });

            // ===== ANNOTATION PAGES =====
            for (const group of visibleGroups) {
                const groupAnns = visibleAnnotations.filter(a => a.groupId === group.id);
                if (groupAnns.length === 0) continue;

                // Group header page
                pdf.addPage();
                pdf.setFillColor(10, 53, 89); // Dark blue
                pdf.rect(0, 0, pageWidth, 40, 'F');

                // Color indicator
                const rgb = hexToRgb(group.color);
                pdf.setFillColor(rgb.r, rgb.g, rgb.b);
                pdf.rect(margin, 15, 10, 10, 'F');

                pdf.setFontSize(20);
                pdf.setTextColor(255, 255, 255);
                pdf.text(group.name, margin + 15, 23);

                pdf.setFontSize(12);
                pdf.setTextColor(200, 200, 200);
                pdf.text(`${groupAnns.length} annotation${groupAnns.length !== 1 ? 's' : ''}`, margin + 15, 32);

                // Annotations in this group
                for (const ann of groupAnns) {
                    pdf.addPage();

                    // Calculate annotation center and bounding box
                    const center = new THREE.Vector3();
                    const annPoints = ann.points.map(p => new THREE.Vector3(p.x, p.y, p.z));
                    annPoints.forEach(p => center.add(p));
                    center.divideScalar(annPoints.length);

                    // Calculate annotation extent (bounding box)
                    let annExtent = 0;
                    if (annPoints.length > 1) {
                        const annBox = new THREE.Box3().setFromPoints(annPoints);
                        const annSize = annBox.getSize(new THREE.Vector3());
                        annExtent = Math.max(annSize.x, annSize.y, annSize.z);
                    }

                    // Get model size for reference
                    const box = new THREE.Box3().setFromObject(currentModel);
                    const modelSize = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(modelSize.x, modelSize.y, modelSize.z);

                    // Calculate zoom distance - close enough to see annotation clearly
                    // Use annotation extent if available, otherwise use a fraction of model size
                    const baseDistance = annExtent > 0 ? annExtent * 2 : maxDim * 0.15;
                    const distance = Math.max(baseDistance, maxDim * 0.08); // Minimum distance

                    // Position camera from top-down angle (about 60 degrees from horizontal)
                    // This gives a good view of the annotation on the surface
                    const angle = Math.PI / 3; // 60 degrees
                    const horizontalOffset = distance * Math.cos(angle);
                    const verticalOffset = distance * Math.sin(angle);

                    // Use a consistent horizontal direction (towards positive X and Z)
                    const horizontalDir = new THREE.Vector3(1, 0, 1).normalize();
                    
                    camera.position.set(
                        center.x + horizontalDir.x * horizontalOffset,
                        center.y + verticalOffset,
                        center.z + horizontalDir.z * horizontalOffset
                    );
                    controls.target.copy(center);
                    controls.update();

                    // Temporarily enlarge markers for this annotation
                    const originalScales = [];
                    annotationObjects.children.forEach(obj => {
                        if (obj.userData.annotationId === ann.id && obj.isMesh) {
                            originalScales.push({ obj, scale: obj.scale.clone() });
                            // Only scale point/vertex markers, not surface meshes
                            if (obj.geometry.type === 'SphereGeometry') {
                                obj.scale.multiplyScalar(2.5); // Make markers 2.5x larger
                            }
                        }
                    });

                    // For surface annotations, temporarily increase opacity for visibility
                    let originalOpacity = null;
                    if (ann.type === 'surface') {
                        annotationObjects.children.forEach(obj => {
                            if (obj.userData.annotationId === ann.id && obj.isMesh && obj.material) {
                                originalOpacity = obj.material.opacity;
                                obj.material.opacity = 0.75; // More visible for screenshot
                                obj.material.needsUpdate = true;
                            }
                        });
                    }

                    // Force clear and multiple render passes to ensure surface is captured
                    renderer.clear();
                    renderer.render(scene, camera);
                    await delay(50);
                    renderer.render(scene, camera);

                    // Capture screenshot
                    const screenshot = renderer.domElement.toDataURL('image/jpeg', 0.9);

                    // Restore original marker scales
                    originalScales.forEach(({ obj, scale }) => {
                        obj.scale.copy(scale);
                    });
                    
                    // Restore original surface opacity
                    if (ann.type === 'surface' && originalOpacity !== null) {
                        annotationObjects.children.forEach(obj => {
                            if (obj.userData.annotationId === ann.id && obj.isMesh && obj.material) {
                                obj.material.opacity = originalOpacity;
                                obj.material.needsUpdate = true;
                            }
                        });
                    }

                    // Header bar
                    const headerRgb = hexToRgb(group.color);
                    pdf.setFillColor(headerRgb.r, headerRgb.g, headerRgb.b);
                    pdf.rect(0, 0, pageWidth, 12, 'F');

                    pdf.setFontSize(10);
                    pdf.setTextColor(255, 255, 255);
                    pdf.text(group.name, margin, 8);

                    // Annotation name
                    pdf.setFontSize(16);
                    pdf.setTextColor(60, 60, 60);
                    pdf.text(ann.name || 'Unnamed', margin, 22);

                    // Type badge
                    pdf.setFontSize(9);
                    pdf.setTextColor(150, 150, 150);
                    const typeLabels = { point: 'Point', line: 'Line', polygon: 'Polygon', surface: 'Surface' };
                    pdf.text(typeLabels[ann.type] || ann.type, margin, 28);

                    // Screenshot - calculate height based on canvas aspect ratio
                    const canvasAspect = canvas.width / canvas.height;
                    const screenshotHeight = contentWidth / canvasAspect;
                    pdf.addImage(screenshot, 'JPEG', margin, 32, contentWidth, screenshotHeight);

                    // Coordinates (subtle, right under screenshot)
                    pdf.setFontSize(7);
                    pdf.setTextColor(150, 150, 150);
                    const coordStrings = ann.points.map((p, i) => 
                        `P${i + 1}: (${p.x.toFixed(2)}, ${p.y.toFixed(2)}, ${p.z.toFixed(2)})`
                    );
                    const coordLine = coordStrings.join('  ‚Ä¢  ');
                    // Split into multiple lines if too long
                    const coordLines = pdf.splitTextToSize(coordLine, contentWidth);
                    pdf.text(coordLines, margin, 32 + screenshotHeight + 4);
                    const coordHeight = coordLines.length * 3;

                    // Entries
                    yPos = 32 + screenshotHeight + 6 + coordHeight;
                    const entries = ann.entries || [];

                    if (entries.length === 0) {
                        pdf.setFontSize(10);
                        pdf.setTextColor(150, 150, 150);
                        pdf.text('No entries.', margin, yPos);
                    } else {
                        entries.forEach((entry, idx) => {
                            if (yPos > pageHeight - 35) {
                                pdf.addPage();
                                yPos = margin;
                            }

                            // Entry header
                            pdf.setFontSize(9);
                            pdf.setTextColor(170, 129, 1);
                            const entryDate = new Date(entry.timestamp);
                            const entryDateStr = entryDate.toLocaleDateString() + ' ' + entryDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                            pdf.text(`${entry.author || 'Unknown'} ‚Ä¢ ${entryDateStr}`, margin, yPos);
                            yPos += 5;

                            // Description
                            pdf.setFontSize(10);
                            pdf.setTextColor(60, 60, 60);
                            if (entry.description) {
                                const descLines = pdf.splitTextToSize(entry.description, contentWidth);
                                pdf.text(descLines, margin, yPos);
                                yPos += descLines.length * 5;
                            }

                            // Links
                            if (entry.links && entry.links.length > 0) {
                                yPos += 2;
                                pdf.setFontSize(8);
                                pdf.setTextColor(100, 100, 200);
                                entry.links.forEach(link => {
                                    if (yPos > pageHeight - 15) {
                                        pdf.addPage();
                                        yPos = margin;
                                    }
                                    const displayLink = link.length > 60 ? link.substring(0, 57) + '...' : link;
                                    pdf.textWithLink('üîó ' + displayLink, margin, yPos, { url: link });
                                    yPos += 4;
                                });
                            }

                            yPos += 6;
                        });
                    }
                }
            }

            // Restore camera position
            camera.position.copy(originalCamPos);
            controls.target.copy(originalTarget);
            controls.update();
            
            // Re-render annotations to ensure normal marker sizes
            renderAnnotations();
            renderer.render(scene, camera);

            // Save PDF
            pdf.save(`meshnotes-report-${modelFileName || 'export'}-${Date.now()}.pdf`);
            showStatus('PDF report exported');
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 200, g: 200, b: 200 };
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function importAnnotations(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    if (data.groups && data.annotations) {
                        // Import model info if present
                        if (data.modelInfo && data.modelInfo.entries) {
                            // Merge entries from imported modelInfo
                            data.modelInfo.entries.forEach(entry => {
                                modelInfo.entries.push({
                                    ...entry,
                                    id: Date.now() + Math.floor(Math.random() * 10000)
                                });
                            });
                            updateModelInfoDisplay();
                        }
                        
                        // Merge groups (avoid duplicates by name)
                        data.groups.forEach(importedGroup => {
                            const existing = groups.find(g => g.name === importedGroup.name);
                            if (!existing) {
                                // Create new group with new ID (integer)
                                const newGroupId = Date.now() + Math.floor(Math.random() * 10000);
                                const newGroup = {
                                    ...importedGroup,
                                    id: newGroupId
                                };
                                
                                // Update annotations to reference new group ID
                                data.annotations.forEach(ann => {
                                    if (ann.groupId === importedGroup.id) {
                                        ann.groupId = newGroupId;
                                    }
                                });
                                
                                groups.push(newGroup);
                            } else {
                                // Map to existing group
                                data.annotations.forEach(ann => {
                                    if (ann.groupId === importedGroup.id) {
                                        ann.groupId = existing.id;
                                    }
                                });
                            }
                        });

                        // Add annotations with new IDs (integers)
                        let idOffset = 0;
                        data.annotations.forEach(ann => {
                            idOffset++;
                            annotations.push({
                                ...ann,
                                id: Date.now() + idOffset
                            });
                        });

                        updateGroupsList();
                        renderAnnotations();
                        showStatus(`Imported ${data.annotations.length} annotations`);
                    } else {
                        showStatus('Invalid annotation file');
                    }
                } catch (error) {
                    console.error('Import error:', error);
                    showStatus('Error importing file');
                }
            };
            reader.readAsText(file);
        }

        // ============ Utilities ============
        function showStatus(message) {
            status.textContent = message;
            status.classList.add('visible');
            setTimeout(() => {
                status.classList.remove('visible');
            }, 3000);
        }
        
        function updateFaceCountDisplay(count) {
            const formatted = count.toLocaleString();
            
            if (count > 1000000) {
                faceCountDisplay.innerHTML = `<span class="warning">‚ö†Ô∏è ${formatted} faces</span> (Surface tool may be slow)`;
            } else if (count > 500000) {
                faceCountDisplay.innerHTML = `<span class="warning">${formatted} faces</span> (Surface tool may lag)`;
            } else {
                faceCountDisplay.textContent = `${formatted} faces`;
            }
            
            modelStats.classList.add('visible');
        }

        function filterAnnotations(searchTerm) {
            const term = searchTerm.toLowerCase().trim();
            
            // Get all group items and annotation items
            const groupItems = groupsContainer.querySelectorAll('.group-item');
            
            groupItems.forEach(groupItem => {
                const annotationItems = groupItem.querySelectorAll('.annotation-item');
                let hasVisibleAnnotation = false;
                
                annotationItems.forEach(annItem => {
                    const name = annItem.querySelector('.name')?.textContent.toLowerCase() || '';
                    
                    if (term === '' || name.includes(term)) {
                        annItem.classList.remove('search-hidden');
                        hasVisibleAnnotation = true;
                    } else {
                        annItem.classList.add('search-hidden');
                    }
                });
                
                // Hide group if no annotations match (unless search is empty)
                if (term === '') {
                    groupItem.classList.remove('search-hidden');
                } else if (hasVisibleAnnotation) {
                    groupItem.classList.remove('search-hidden');
                } else {
                    groupItem.classList.add('search-hidden');
                }
            });
        }

        function toggleManualItem(header) {
            header.classList.toggle('expanded');
            const content = header.nextElementSibling;
            content.classList.toggle('expanded');
        }
        // Make accessible for inline onclick handlers
        window.toggleManualItem = toggleManualItem;

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ============ Event Listeners ============
        btnLoad.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) loadModel(e.target.files[0]);
        });

        btnTexture.addEventListener('click', toggleTexture);
        btnPoint.addEventListener('click', () => setTool('point'));
        btnLine.addEventListener('click', () => setTool('line'));
        btnPolygon.addEventListener('click', () => setTool('polygon'));
        btnSurface.addEventListener('click', () => setTool('surface'));
        btnMeasure.addEventListener('click', () => setTool('measure'));
        btnScreenshot.addEventListener('click', takeScreenshot);
        btnExport.addEventListener('click', exportAnnotations);
        btnExportPdf.addEventListener('click', exportPdfReport);
        btnImport.addEventListener('click', () => importInput.click());
        importInput.addEventListener('change', (e) => {
            if (e.target.files[0]) importAnnotations(e.target.files[0]);
        });
        
        // Brush size slider
        brushSlider.addEventListener('input', (e) => {
            surfaceBrushSize = parseFloat(e.target.value);
            brushValue.textContent = surfaceBrushSize + '%';
        });
        
        // Search filter
        searchInput.addEventListener('input', (e) => {
            filterAnnotations(e.target.value);
        });

        btnAddGroup.addEventListener('click', () => openGroupPopup());
        btnGroupSave.addEventListener('click', saveGroup);
        btnGroupCancel.addEventListener('click', () => {
            groupPopup.classList.remove('visible');
            editingGroup = null;
        });
        btnGroupDelete.addEventListener('click', () => {
            if (editingGroup) deleteGroup(editingGroup);
        });

        btnPopupSave.addEventListener('click', saveAnnotation);
        btnPopupCancel.addEventListener('click', () => {
            annotationPopup.classList.remove('visible');
            clearTempDrawing();
            editingAnnotation = null;
            editingModelInfo = false;
            isAddingEntry = false;
            editingEntryId = null;
        });
        btnPopupDelete.addEventListener('click', deleteAnnotation);
        btnAddLink.addEventListener('click', addLink);
        annNewLink.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') addLink();
        });
        
        // Add Entry button
        btnAddEntry.addEventListener('click', showAddEntryForm);
        
        // Model Info double-click
        modelInfoItem.addEventListener('dblclick', openModelInfoPopup);
        
        // Confirmation dialog
        confirmOk.addEventListener('click', () => {
            if (confirmCallback) confirmCallback();
            hideConfirm();
        });
        confirmCancel.addEventListener('click', hideConfirm);
        confirmOverlay.addEventListener('click', (e) => {
            if (e.target === confirmOverlay) hideConfirm();
        });

        canvas.addEventListener('click', onCanvasClick);
        canvas.addEventListener('dblclick', onCanvasDblClick);
        canvas.addEventListener('mousedown', onCanvasMouseDown);
        canvas.addEventListener('mousemove', onCanvasMouseMove);
        canvas.addEventListener('mouseup', onCanvasMouseUp);

        brightnessSlider.addEventListener('input', (e) => setBrightness(parseInt(e.target.value)));
        opacitySlider.addEventListener('input', (e) => setModelOpacity(parseInt(e.target.value)));

        // About modal
        btnAbout.addEventListener('click', () => {
            aboutOverlay.classList.add('visible');
        });

        aboutModalClose.addEventListener('click', () => {
            aboutOverlay.classList.remove('visible');
        });

        aboutOverlay.addEventListener('click', (e) => {
            if (e.target === aboutOverlay) {
                aboutOverlay.classList.remove('visible');
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                // Close confirmation dialog if open
                if (confirmOverlay.classList.contains('visible')) {
                    hideConfirm();
                    return;
                }
                
                // Close about modal if open
                if (aboutOverlay.classList.contains('visible')) {
                    aboutOverlay.classList.remove('visible');
                    return;
                }
                
                annotationPopup.classList.remove('visible');
                groupPopup.classList.remove('visible');
                isAddingEntry = false;
                editingEntryId = null;
                editingModelInfo = false;
                
                // Clear measurements if in measure mode
                if (currentTool === 'measure') {
                    clearAllMeasurements();
                    showStatus('Measurements cleared');
                }
                
                setTool(null);
                clearTempDrawing();
            }
        });

        // ============ Start ============
        init();
    </script>
</body>
</html>
